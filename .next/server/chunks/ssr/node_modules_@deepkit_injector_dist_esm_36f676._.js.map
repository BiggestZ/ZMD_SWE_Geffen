{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"provider.js","sources":["turbopack://[project]/node_modules/@deepkit/injector/src/provider.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\nimport { AbstractClassType, ClassType, isClass, isFunction } from '@deepkit/core';\nimport type { InjectorModule } from './module.js';\nimport { ReceiveType, resolveReceiveType, Type } from '@deepkit/type';\n\nexport interface ProviderBase {\n    /**\n     * Per default all instances are singleton (scoped to its scope). Enabling transient makes the\n     * Injector create always a new instance for every consumer.\n     */\n    transient?: true;\n}\n\n/** @reflection never */\nexport interface ProviderScope {\n    scope?: 'module' | 'rpc' | 'http' | 'cli' | string;\n}\n\n/** @reflection never */\nexport type Token<T = any> = symbol | number | bigint | RegExp | boolean | string | AbstractClassType<T> | Type | TagProvider<T> | Function | T;\n\nexport function provide<T>(\n    provider:\n        | (ProviderBase & ProviderScope &\n        (\n            | { useValue: T }\n            | { useClass: ClassType }\n            | { useExisting: any }\n            | { useFactory: (...args: any[]) => T | undefined }\n            ))\n        | ClassType\n        | ((...args: any[]) => T)\n    ,\n    type?: ReceiveType<T>,\n): NormalizedProvider {\n    if (isClass(provider)) return { provide: resolveReceiveType(type), useClass: provider };\n    if (isFunction(provider)) return { provide: resolveReceiveType(type), useFactory: provider };\n    return { ...provider, provide: resolveReceiveType(type) };\n}\n\nexport interface ValueProvider<T> extends ProviderBase {\n    /**\n     * An injection token.\n     */\n    provide: Token<T>;\n\n    /**\n     * The value to inject.\n     */\n    useValue: T;\n}\n\nexport interface ClassProvider<T> extends ProviderBase {\n    /**\n     * An injection token.\n     */\n    provide: Token<T>;\n\n    /**\n     * Class to instantiate for the `token`.\n     */\n    useClass?: ClassType<T>;\n}\n\nexport interface ExistingProvider<T> extends ProviderBase {\n    /**\n     * An injection token.\n     */\n    provide: Token<T>;\n\n    /**\n     * Existing `token` to return. (equivalent to `injector.get(useExisting)`)\n     */\n    useExisting: ClassType<T>;\n}\n\nexport interface FactoryProvider<T> extends ProviderBase {\n    /**\n     * An injection token.\n     */\n    provide: Token<T>;\n\n    /**\n     * A function to invoke to create a value for this `token`.\n     */\n    useFactory: (...args: any[]) => T | undefined;\n}\n\n/** @reflection never */\nexport type Provider<T = any> = AbstractClassType | ValueProvider<T> | ClassProvider<T> | ExistingProvider<T> | FactoryProvider<T> | TagProvider<T>;\n\n/** @reflection never */\nexport type ProviderProvide<T = any> = ValueProvider<T> | ClassProvider<T> | ExistingProvider<T> | FactoryProvider<T>;\n\n/** @reflection never */\ninterface TagRegistryEntry<T> {\n    tagProvider: TagProvider<T>;\n    module: InjectorModule;\n}\n\n/** @reflection never */\nexport class TagRegistry {\n    constructor(\n        public tags: TagRegistryEntry<any>[] = []\n    ) {\n    }\n\n    register(tagProvider: TagProvider<any>, module: InjectorModule) {\n        return this.tags.push({ tagProvider, module });\n    }\n\n    resolve<T extends ClassType<Tag<any>>>(tag: T): TagRegistryEntry<InstanceType<T>>[] {\n        return this.tags.filter(v => v.tagProvider.tag instanceof tag);\n    }\n}\n\n/** @reflection never */\nexport class TagProvider<T> {\n    constructor(\n        public provider: NormalizedProvider<T>,\n        public tag: Tag<T>,\n    ) {\n    }\n}\n\n/** @reflection never */\nexport class Tag<T, TP extends TagProvider<T> = TagProvider<T>> {\n    _!: () => T;\n    _2!: () => TP;\n\n    constructor(\n        public readonly services: T[] = []\n    ) {\n    }\n\n    protected createTagProvider(provider: NormalizedProvider<any>): TP {\n        return new TagProvider(provider, this) as TP;\n    }\n\n    static provide<P extends ClassType<T> | ValueProvider<T> | ClassProvider<T> | ExistingProvider<T> | FactoryProvider<T>,\n        T extends ReturnType<InstanceType<B>['_']>,\n        TP extends ReturnType<InstanceType<B>['_2']>,\n        B extends ClassType<Tag<any>>>(this: B, provider: P): TP {\n        const t = new this;\n\n        if (isClass(provider)) {\n            return t.createTagProvider({ provide: provider }) as TP;\n        }\n\n        return t.createTagProvider(provider as NormalizedProvider<T>) as TP;\n    }\n}\n\n/** @reflection never */\nexport type NormalizedProvider<T = any> = ProviderProvide<T> & ProviderScope;\n\n/** @reflection never */\nexport type ProviderWithScope<T = any> = AbstractClassType | (ProviderProvide<T> & ProviderScope) | TagProvider<any>;\n\nexport function isScopedProvider(obj: any): obj is ProviderProvide & ProviderScope {\n    return obj.provide && obj.hasOwnProperty('scope');\n}\n\nexport function isValueProvider(obj: any): obj is ValueProvider<any> {\n    return obj.provide && obj.hasOwnProperty('useValue');\n}\n\nexport function isClassProvider(obj: any): obj is ClassProvider<any> {\n    return obj.provide && !isValueProvider(obj) && !isExistingProvider(obj) && !isFactoryProvider(obj);\n}\n\nexport function isExistingProvider(obj: any): obj is ExistingProvider<any> {\n    return obj.provide && obj.hasOwnProperty('useExisting');\n}\n\nexport function isFactoryProvider(obj: any): obj is FactoryProvider<any> {\n    return obj.provide && obj.hasOwnProperty('useFactory');\n}\n\nexport function isInjectionProvider(obj: any): obj is Provider<any> {\n    return isValueProvider(obj) || isClassProvider(obj) || isExistingProvider(obj) || isFactoryProvider(obj);\n}\n\nexport function isTransient(provider: ProviderWithScope): boolean {\n    if (isClass(provider)) return false;\n    if (provider instanceof TagProvider) return false;\n    return provider.transient === true;\n}\n\nexport function getProviders(\n    providers: ProviderWithScope[],\n    requestScope: 'module' | 'session' | 'request' | string,\n) {\n    const result: Provider<any>[] = [];\n\n    function normalize(provider: ProviderWithScope<any>): Provider<any> {\n        if (isClass(provider)) {\n            return provider;\n        }\n\n        return provider;\n    }\n\n    for (const provider of providers) {\n        if (isClass(provider)) {\n            if (requestScope === 'module') result.push(provider);\n            continue;\n        }\n\n        if (isClass(provider)) {\n            if (requestScope === 'module') result.push(provider);\n            continue;\n        }\n\n        const scope = isScopedProvider(provider) ? provider.scope : 'module';\n        if (scope === requestScope) {\n            result.push(normalize(provider));\n        }\n    }\n\n    return result;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 267, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"file":"types.js","sources":["turbopack://[project]/node_modules/@deepkit/injector/src/types.ts"],"sourcesContent":["import { reflect, ReflectionKind, Type } from '@deepkit/type';\nimport { getParentClass } from '@deepkit/core';\n\nexport type InjectMeta<T = never> = { __meta?: never & ['inject', T] }\nexport type Inject<Type, Token = never> = Type & InjectMeta<Token>\n\n/**\n * Checks if given type is nominally compatible with the given interface.\n *\n * 0 means not compatible, 1 means exactly compatible, n>1 means compatible but not exactly. The higher the number the further away the compatibility is (the inheritance chain).\n *\n * @example\n * ```typescript\n * class A {\n * }\n *\n * class B extends A {\n * }\n *\n * interface B0 extends B {}\n *\n * class C {\n * }\n *\n * nominalCompatibility(A, A) // true\n * nominalCompatibility(A, B) // true\n * nominalCompatibility(A, B0) // true\n * nominalCompatibility(A, C) // false\n *\n */\nexport function nominalCompatibility(token: Type, provider: Type): number {\n    //we want to check if the token is nominal the same with the provider.\n    if (token === provider) return 1;\n\n    const stack: { spec: number, type: Type }[] = [{ spec: 1, type: provider }];\n\n    while (stack.length) {\n        const entry = stack.pop()!;\n        const current = entry.type;\n        if (current.id && current.id === token.id) return entry.spec;\n\n        if (!current.id && !token.id) {\n            //both have no nominal ID, so compare by value identity (literal, classType, function)\n            if (current.kind === ReflectionKind.function && token.kind === ReflectionKind.function && current.function && current.function === token.function) return entry.spec;\n            if (current.kind === ReflectionKind.class && token.kind === ReflectionKind.class && current.classType && current.classType === token.classType) return entry.spec;\n            if (current.kind === ReflectionKind.literal && token.kind === ReflectionKind.literal && current.literal === token.literal) return entry.spec;\n        }\n\n        if (current.kind === ReflectionKind.class) {\n            const parent = getParentClass(current.classType);\n            if (parent && (parent as any).__type) {\n                const next = reflect(parent);\n                stack.push({ spec: entry.spec + 1, type: next });\n            }\n        }\n\n        if ((current.kind === ReflectionKind.class || current.kind === ReflectionKind.objectLiteral) && current.implements) {\n            for (const i of current.implements) {\n                stack.push({ spec: entry.spec + 1, type: i });\n            }\n        }\n    }\n\n    return 0;\n}\n"],"names":[],"mappings":";;;;;AAAA,OAAO,EAAE,OAAO,EAAE,cAAc,EAAQ,MAAM,eAAe,CAAC;AAC9D,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;;;;;;;;;;;;;;;;;;;;;;AA6BzC,SAAU,oBAAoB,CAAC,KAAW,EAAE,QAAc;IAC5D,sEAAsE;IACtE,IAAI,KAAK,KAAK,QAAQ,EAAE,OAAO,CAAC,CAAC;IAEjC,MAAM,KAAK,GAAmC;QAAC;YAAE,IAAI,EAAE,CAAC;YAAE,IAAI,EAAE,QAAQ;QAAA,CAAE;KAAC,CAAC;IAE5E,MAAO,KAAK,CAAC,MAAM,CAAE,CAAC;QAClB,MAAM,KAAK,GAAG,KAAK,CAAC,GAAG,EAAG,CAAC;QAC3B,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC;QAC3B,IAAI,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC,EAAE,KAAK,KAAK,CAAC,EAAE,EAAE,OAAO,KAAK,CAAC,IAAI,CAAC;QAE7D,IAAI,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC;YAC3B,sFAAsF;YACtF,IAAI,OAAO,CAAC,IAAI,KAAK,+LAAc,CAAC,QAAQ,IAAI,KAAK,CAAC,IAAI,mLAAK,iBAAc,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,KAAK,KAAK,CAAC,QAAQ,EAAE,OAAO,KAAK,CAAC,IAAI,CAAC;YACrK,IAAI,OAAO,CAAC,IAAI,mLAAK,iBAAc,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,mLAAK,iBAAc,CAAC,KAAK,IAAI,OAAO,CAAC,SAAS,IAAI,OAAO,CAAC,SAAS,KAAK,KAAK,CAAC,SAAS,EAAE,OAAO,KAAK,CAAC,IAAI,CAAC;YAClK,IAAI,OAAO,CAAC,IAAI,mLAAK,iBAAc,CAAC,OAAO,IAAI,KAAK,CAAC,IAAI,KAAK,+LAAc,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,EAAE,OAAO,KAAK,CAAC,IAAI,CAAC;QACjJ,CAAC;QAED,IAAI,OAAO,CAAC,IAAI,mLAAK,iBAAc,CAAC,KAAK,EAAE,CAAC;YACxC,MAAM,MAAM,uKAAG,iBAAA,AAAc,EAAC,OAAO,CAAC,SAAS,CAAC,CAAC;YACjD,IAAI,MAAM,IAAK,MAAc,CAAC,MAAM,EAAE,CAAC;gBACnC,MAAM,IAAI,2LAAG,UAAA,AAAO,EAAC,MAAM,CAAC,CAAC;gBAC7B,KAAK,CAAC,IAAI,CAAC;oBAAE,IAAI,EAAE,KAAK,CAAC,IAAI,GAAG,CAAC;oBAAE,IAAI,EAAE,IAAI;gBAAA,CAAE,CAAC,CAAC;YACrD,CAAC;QACL,CAAC;QAED,IAAI,CAAC,OAAO,CAAC,IAAI,mLAAK,iBAAc,CAAC,KAAK,IAAI,OAAO,CAAC,IAAI,mLAAK,iBAAc,CAAC,aAAa,CAAC,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;YACjH,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,UAAU,CAAE,CAAC;gBACjC,KAAK,CAAC,IAAI,CAAC;oBAAE,IAAI,EAAE,KAAK,CAAC,IAAI,GAAG,CAAC;oBAAE,IAAI,EAAE,CAAC;gBAAA,CAAE,CAAC,CAAC;YAClD,CAAC;QACL,CAAC;IACL,CAAC;IAED,OAAO,CAAC,CAAC;AACb,CAAC"}},
    {"offset": {"line": 348, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 354, "column": 0}, "map": {"version":3,"file":"module.js","sources":["turbopack://[project]/node_modules/@deepkit/injector/src/module.ts"],"sourcesContent":["import { NormalizedProvider, ProviderWithScope, TagProvider, Token } from './provider.js';\nimport { arrayRemoveItem, ClassType, getClassName, isClass, isPlainObject, isPrototypeOfBase } from '@deepkit/core';\nimport { BuildContext, getContainerToken, Injector, resolveToken } from './injector.js';\nimport {\n    hasTypeInformation,\n    isType,\n    ReceiveType,\n    reflect,\n    ReflectionKind,\n    reflectOrUndefined,\n    resolveReceiveType,\n    Type,\n    TypeClass,\n    typeInfer,\n    TypeObjectLiteral,\n    visit,\n} from '@deepkit/type';\nimport { nominalCompatibility } from './types.js';\n\nexport interface ConfigureProviderOptions {\n    /**\n     * If there are several registered configuration functions for the same token,\n     * they are executed in order of their `order` value ascending. The default is 0.\n     * The lower the number, the earlier it is executed.\n     */\n    order: number;\n\n    /**\n     * Replaces the instance with the value returned by the configuration function.\n     */\n    replace: boolean;\n\n    /**\n     * Per default only providers in the same module are configured.\n     * If you want to configure providers of all modules, set this to true.\n     */\n    global: boolean;\n}\n\nexport interface ConfigureProviderEntry {\n    type: Type;\n    options: ConfigureProviderOptions;\n    call: Function;\n}\n\nexport class ConfigurationProviderRegistry {\n    public configurations: ConfigureProviderEntry[] = [];\n\n    public add(type: Type, call: Function, options: ConfigureProviderOptions) {\n        this.configurations.push({ type, options, call });\n    }\n\n    mergeInto(registry: ConfigurationProviderRegistry): void {\n        for (const { type, options, call } of this.configurations) {\n            registry.add(type, call, options);\n        }\n    }\n\n    public get(token: Token): ConfigureProviderEntry[] {\n        const results: ConfigureProviderEntry[] = [];\n        for (const configure of this.configurations) {\n            const lookup = isClass(token) ? resolveReceiveType(token) : token;\n            if (dependencyLookupMatcher(configure.type, lookup)) {\n                results.push(configure);\n            }\n        }\n        return results;\n    }\n}\n\nlet moduleIds: number = 0;\n\nexport interface PreparedProvider {\n    token: Token;\n\n    /**\n     * The modules from which dependencies can be resolved. The first item is always the module from which this provider was declared.\n     *\n     * This is per default the module in which the provider was declared,\n     * but if the provider was moved (by exporting), then if\n     *   a) the parent had this provider already, then this array has additionally the one from which the provider was exported.\n     *   b) the parent had no provider of that token, then this array is just the module from which the provider was exported.\n     *\n     * This is important otherwise exported provider won't have access in their dependencies to their original (encapsulated) injector.\n     */\n    modules: InjectorModule[];\n\n    /**\n     * A token can have multiple providers, for each scope its own entry.\n     * Each scoped provider can only exist once.\n     */\n    providers: NormalizedProvider[];\n\n    /**\n     * When this provider was exported to another module and thus is actually instantiated in another module, then this is set.\n     * This is necessary to tell the module who declared this provider to not instantiate it, but redirects resolve requests\n     * to `resolveFrom` instead.\n     */\n    resolveFrom?: InjectorModule;\n}\n\n/**\n * 0 means not compatible, 1 means exactly compatible, n>1 means compatible but not exactly. The higher the number the further away the compatibility is (the inheritance chain).\n */\nfunction getSpecificity(a: Type, b: Type): number {\n    return nominalCompatibility(a, b);\n}\n\nfunction getTypeFromToken(token: Token): Type {\n    return isClass(token) && hasTypeInformation(token) ? reflect(token) : isType(token) ? token : typeInfer(token);\n}\n\nfunction getTypeFromProvider(preparedProvider: PreparedProvider): Type {\n    return isClass(preparedProvider.token) && hasTypeInformation(preparedProvider.token)\n        ? reflect(preparedProvider.token) : isType(preparedProvider.token) ? preparedProvider.token : typeInfer(preparedProvider.token);\n}\n\ntype LookupMatcher = (token: Type, provider: Type, candidate?: Type) => boolean;\n\nfunction exportLookupMatcher(token: Type, provider: Type, candidate?: Type): boolean {\n    if (token.id) return token.id === provider.id;\n\n    if (token.kind === ReflectionKind.function && provider.kind === ReflectionKind.function && provider.function && provider.function === token.function) return true;\n    if (token.kind === ReflectionKind.class && provider.kind === ReflectionKind.class && provider.classType && provider.classType === token.classType) return true;\n    if (token.kind === ReflectionKind.literal && provider.kind === ReflectionKind.literal && provider.literal === token.literal) return true;\n    return false;\n}\n\nfunction dependencyLookupMatcher(token: Type, provider: Type, candidate?: Type): boolean {\n    if (token.id && token.id === provider.id) return true;\n\n    const spec = getSpecificity(token, provider);\n    if (!spec) return false;\n\n    if (candidate) {\n        //if we have already a matching old candidate, we check if the old candidate was more specific than the new one.\n        //if the old one was more specific, we don't want to replace it. (lower number means more specific)\n        const oldSpec = getSpecificity(token, candidate);\n        if (oldSpec <= spec) return false;\n    }\n\n    return true;\n}\n\nfunction lookupPreparedProviders(\n    preparedProviders: PreparedProvider[],\n    token: Token | PreparedProvider,\n    matcher: LookupMatcher,\n    candidate?: PreparedProvider,\n): PreparedProvider | undefined {\n    const tokenProvider: any | undefined = (isPlainObject(token) && 'provide' in token && !('kind' in token)) ? token : undefined;\n    const tokenType = tokenProvider ? undefined : getTypeFromToken(token);\n\n    for (const preparedProvider of preparedProviders) {\n        if (tokenProvider) {\n            //token is a PreparedProvider, which matches only by identity\n            if (preparedProvider === tokenProvider || preparedProvider.providers.includes(tokenProvider)) return preparedProvider;\n            continue;\n        }\n        if (!tokenType) continue;\n\n        const preparedProviderType = getTypeFromToken(preparedProvider.token);\n\n        if (matcher(tokenType, preparedProviderType, candidate ? getTypeFromProvider(candidate) : undefined)) {\n            candidate = preparedProvider;\n        }\n    }\n\n    return candidate;\n}\n\nfunction registerPreparedProvider(preparedProviders: PreparedProvider[], modules: InjectorModule[], providers: NormalizedProvider[], replaceExistingScope: boolean = true) {\n    const token = providers[0].provide;\n    if (token === undefined) {\n        throw new Error('token is undefined: ' + JSON.stringify(providers));\n    }\n\n    const preparedProvider = lookupPreparedProviders(preparedProviders, token, exportLookupMatcher);\n    if (preparedProvider) {\n        preparedProvider.token = token;\n        for (const m of modules) {\n            if (preparedProvider.modules.includes(m)) continue;\n            preparedProvider.modules.push(m);\n        }\n        for (const provider of providers) {\n            const scope = getScope(provider);\n            //check if given provider has an unknown scope, if so set it.\n            //if the scope is known, overwrite it (we want always the last known provider to be valid)\n            const knownProvider = preparedProvider.providers.findIndex(v => getScope(v) === scope);\n            if (knownProvider === -1) {\n                //scope not known, add it\n                preparedProvider.providers.push(provider);\n            } else if (replaceExistingScope) {\n                //scope already known, replace it\n                preparedProvider.providers.splice(knownProvider, 1, provider);\n            }\n        }\n    } else {\n        //just add it\n        preparedProviders.push({ token, modules, providers: providers.slice() });\n    }\n}\n\nfunction isInChildOfConfig(findType: TypeClass | TypeObjectLiteral, inType?: ClassType): string | undefined {\n    if (!inType) return;\n    const inTypeType = reflect(inType);\n    if (inTypeType.kind !== ReflectionKind.class && inTypeType.kind !== ReflectionKind.objectLiteral) return;\n\n    let found: string | undefined = undefined;\n    visit(inTypeType, (type, path): false | void => {\n        if (type === findType) {\n            found = path;\n            return false;\n        } else if (type.kind === ReflectionKind.class && findType.kind === ReflectionKind.class && type.classType === findType.classType) {\n            found = path;\n            return false;\n        }\n    });\n\n    return found;\n}\n\nexport function findModuleForConfig(config: ClassType, modules: InjectorModule[]): { module: InjectorModule, path: string } | undefined {\n    //go first through first level tree, then second, the third, etc., until no left\n    const next: InjectorModule[] = modules.slice();\n\n    const configType = reflectOrUndefined(config);\n    if (!configType) return;\n\n    if (configType.kind !== ReflectionKind.class && configType.kind !== ReflectionKind.objectLiteral) return;\n\n    while (next.length) {\n        const iterateOver: InjectorModule[] = next.slice();\n        next.length = 0;\n\n        for (const m of iterateOver) {\n            if (m.configDefinition === config) return { module: m, path: '' };\n            const foundInChild = isInChildOfConfig(configType, m.configDefinition);\n            if (foundInChild) return { module: m, path: foundInChild };\n\n            let parent = m.parent;\n            while (parent) {\n                if (parent.configDefinition === config) return { module: parent, path: '' };\n                const foundInChild = isInChildOfConfig(configType, parent.configDefinition);\n                if (foundInChild) return { module: parent, path: foundInChild };\n                parent = parent.parent;\n            }\n            next.push(...m.imports);\n        }\n    }\n\n    return undefined;\n}\n\nexport type ExportType = Token | InjectorModule;\n\n\nexport function isProvided<T>(providers: ProviderWithScope[], token: Token<T>): boolean {\n    return providers.some(v => getContainerToken(resolveToken(v)) === getContainerToken(token));\n}\n\nexport function getScope(provider: ProviderWithScope): string {\n    return (isClass(provider) ? '' : provider instanceof TagProvider ? provider.provider.scope : provider.scope) || '';\n}\n\n/**\n * @reflection never\n */\nexport class InjectorModule<C extends { [name: string]: any } = any, IMPORT = InjectorModule<any, any>> {\n    public id: number = moduleIds++;\n\n    /**\n     * Whether this module is for the root module. All its providers are automatically exported and moved to the root level.\n     */\n    public root: boolean = false;\n\n    /**\n     * The built injector. This is set once an Injector for this module has been created.\n     */\n    injector?: Injector;\n\n    public configurationProviderRegistry: ConfigurationProviderRegistry = new ConfigurationProviderRegistry;\n    public globalConfigurationProviderRegistry: ConfigurationProviderRegistry = new ConfigurationProviderRegistry;\n\n    imports: InjectorModule[] = [];\n\n    protected exportsDisabled: boolean = false;\n\n    public configDefinition?: ClassType;\n\n    constructor(\n        public providers: ProviderWithScope[] = [],\n        public parent?: InjectorModule,\n        public config: C = {} as C,\n        public exports: ExportType[] = [],\n    ) {\n        if (this.parent) this.parent.registerAsChildren(this);\n    }\n\n    registerAsChildren(child: InjectorModule): void {\n        if (this.imports.includes(child)) return;\n        this.imports.push(child);\n    }\n\n    /**\n     * When the module exports providers the importer doesn't want, then `disableExports` disable all exports.\n     */\n    disableExports(): this {\n        this.exportsDisabled = true;\n        return this;\n    }\n\n    /**\n     * Makes all the providers, controllers, etc available at the root module, basically exporting everything.\n     */\n    forRoot(): this {\n        this.root = true;\n        return this;\n    }\n\n    /**\n     * Reverts the root default setting to false.\n     */\n    notForRoot(): this {\n        this.root = false;\n        return this;\n    }\n\n    unregisterAsChildren(child: InjectorModule): void {\n        if (!this.imports.includes(child)) return;\n        child.parent = undefined;\n        arrayRemoveItem(this.imports, child);\n    }\n\n    getChildren(): InjectorModule[] {\n        return this.imports;\n    }\n\n    setConfigDefinition(config: ClassType): this {\n        this.configDefinition = config;\n        const configDefaults = new config;\n        this.config = Object.assign(configDefaults, this.config);\n        return this;\n    }\n\n    setParent(parent: InjectorModule): this {\n        if (this.parent === parent) return this;\n        this.assertInjectorNotBuilt();\n        if (this.parent) this.parent.unregisterAsChildren(this);\n        this.parent = parent;\n        this.parent.registerAsChildren(this);\n        return this;\n    }\n\n    getParent(): InjectorModule | undefined {\n        return this.parent;\n    }\n\n    protected assertInjectorNotBuilt(): void {\n        if (!this.injector) return;\n        throw new Error(`Injector already built for ${getClassName(this)}. Can not modify its provider or tree structure.`);\n    }\n\n    addExport(...types: (ExportType | ExportType[])[]): this {\n        this.assertInjectorNotBuilt();\n        this.exports.push(...types.flat());\n        return this;\n    }\n\n    isExported(token: Token): boolean {\n        return this.exports.includes(token);\n    }\n\n    isProvided<T>(token?: Token<T>, type?: ReceiveType<T>): boolean {\n        if (!token) {\n            token = resolveReceiveType(type);\n        }\n        return isProvided<T>(this.getProviders(), token);\n    }\n\n    addProvider(...provider: (ProviderWithScope | ProviderWithScope[])[]): this {\n        this.assertInjectorNotBuilt();\n        this.providers.push(...provider.flat());\n        return this;\n    }\n\n    getProviders(): ProviderWithScope[] {\n        return this.providers;\n    }\n\n    getConfig(): C {\n        return this.config;\n    }\n\n    configure(config: Partial<C>): this {\n        Object.assign(this.config, config);\n        return this;\n    }\n\n    getImports(): InjectorModule[] {\n        return this.imports;\n    }\n\n    getImportedModulesByClass<T extends InjectorModule>(classType: ClassType<T>): T[] {\n        return this.getImports().filter(v => v instanceof classType) as T[];\n    }\n\n    getImportedModuleByClass<T extends InjectorModule>(classType: ClassType<T>): T {\n        const v = this.getImports().find(v => v instanceof classType);\n        if (!v) {\n            throw new Error(`No module ${getClassName(classType)} in ${getClassName(this)}#${this.id} imported.`);\n        }\n        return v as T;\n    }\n\n    getImportedModule<T extends InjectorModule>(module: T): T {\n        const v = this.getImports().find(v => v.id === module.id);\n        if (!v) {\n            throw new Error(`No module ${getClassName(module)}#${module.id} in ${getClassName(this)}#${this.id} imported.`);\n        }\n        return v as T;\n    }\n\n    getExports() {\n        return this.exports;\n    }\n\n    hasImport<T extends InjectorModule>(moduleClass: ClassType<T>): boolean {\n        for (const importModule of this.getImports()) {\n            if (importModule instanceof moduleClass) return true;\n        }\n        return false;\n    }\n\n    /**\n     * Adds a new import at the end.\n     */\n    addImport(...modules: InjectorModule<any>[]): this {\n        this.assertInjectorNotBuilt();\n        for (const module of modules) {\n            module.setParent(this);\n        }\n        return this;\n    }\n\n    /**\n     * Adds a new import at the beginning. Since import order matters, it might be useful to import a module first\n     * so its exported providers can be overwritten by imports following this module.\n     */\n    addImportAtBeginning(...modules: InjectorModule<any>[]): this {\n        this.assertInjectorNotBuilt();\n        for (const module of modules) {\n            module.parent = this;\n            this.imports.unshift(module);\n        }\n        return this;\n    }\n\n    /**\n     * Configures a provider by applying a custom configuration function to its instance.\n     * The passed configure function is executed when instance was created.\n     * If the provider is in a scope and the scope created multiple instances,\n     * the configure function is executed for each instance.\n     *\n     * The purpose of a provider configuration is to configure the instance, for example\n     * call methods on it, set properties, etc.\n     *\n     * The first parameter of the function is always the instance of the provider that was created.\n     * All additional defined parameters will be provided by the dependency injection container.\n     *\n     * if `options.replace` is true, the returned value of `configure` will\n     * replace the instance.\n     * if `options.global` is true, the configuration function is applied to all\n     * providers in the whole module tree.\n     * The `options.order` defines the order of execution of the configuration function.\n     * The lower the number, the earlier it is executed.\n     */\n    configureProvider<T>(configure: (instance: T, ...args: any[]) => any, options: Partial<ConfigureProviderOptions> = {}, type?: ReceiveType<T>): this {\n        const optionsResolved = Object.assign({ order: 0, replace: false, global: false }, options);\n        type = resolveReceiveType(type);\n        const registry = options.global ? this.globalConfigurationProviderRegistry : this.configurationProviderRegistry;\n        registry.add(type, configure, optionsResolved);\n        return this;\n    }\n\n    getOrCreateInjector(buildContext: BuildContext): Injector {\n        if (this.injector) return this.injector;\n\n        //notify everyone we know to prepare providers\n        if (this.parent) this.parent.getPreparedProviders(buildContext);\n        this.getPreparedProviders(buildContext);\n\n        //handle exports, from bottom to up\n        if (this.parent) this.parent.handleExports(buildContext);\n        this.handleExports(buildContext);\n\n        //build the injector context\n        if (this.parent) this.parent.getOrCreateInjector(buildContext);\n        this.injector = new Injector(this, buildContext);\n        for (const child of this.imports) child.getOrCreateInjector(buildContext);\n\n        return this.injector;\n    }\n\n    protected preparedProviders?: PreparedProvider[];\n\n    getPreparedProvider(token: Token, candidate?: PreparedProvider): PreparedProvider | undefined {\n        if (!this.preparedProviders) return;\n        return lookupPreparedProviders(this.preparedProviders, token, dependencyLookupMatcher, candidate);\n    }\n\n    getSetupProvider(token: Token, candidate?: PreparedProvider): PreparedProvider | undefined {\n        if (!this.preparedProviders) return;\n        return lookupPreparedProviders(this.preparedProviders, token, exportLookupMatcher, candidate);\n    }\n\n    resolveToken(token: Token): InjectorModule | undefined {\n        const found = this.getPreparedProvider(token);\n        if (found) return this;\n        if (this.parent) return this.parent.resolveToken(token);\n        return;\n    }\n\n    getBuiltPreparedProviders(): PreparedProvider[] | undefined {\n        return this.preparedProviders;\n    }\n\n    /**\n     * Prepared the module for an injector tree build.\n     *\n     *  - Index providers by token so that last known provider is picked (so they can be overwritten).\n     *  - Register TagProvider in TagRegistry\n     *  - Put TagProvider in providers if not already made.\n     *  - Put exports to parent's module with the reference to this, so the dependencies are fetched from the correct module.\n     */\n    getPreparedProviders(buildContext: BuildContext): PreparedProvider[] {\n        if (this.preparedProviders) return this.preparedProviders;\n\n        for (const m of this.imports) {\n            m.getPreparedProviders(buildContext);\n        }\n\n        this.preparedProviders = [];\n\n        this.globalConfigurationProviderRegistry.mergeInto(buildContext.globalConfigurationProviderRegistry);\n\n        //make sure that providers that declare the same provider token will be filtered out so that the last will be used.\n        for (const provider of this.providers) {\n            if (!provider) continue;\n            if (provider instanceof TagProvider) {\n                buildContext.tagRegistry.register(provider, this);\n\n                if (!lookupPreparedProviders(this.preparedProviders, provider.provider.provide, exportLookupMatcher)) {\n                    //we don't want to overwrite that provider with a tag\n                    registerPreparedProvider(this.preparedProviders, [this], [provider.provider]);\n                }\n            } else if (isClass(provider)) {\n                registerPreparedProvider(this.preparedProviders, [this], [{ provide: provider }]);\n            } else if (isPlainObject(provider)) {\n                registerPreparedProvider(this.preparedProviders, [this], [provider]);\n            }\n        }\n\n        return this.preparedProviders;\n    }\n\n    protected exported: boolean = false;\n\n    protected handleExports(buildContext: BuildContext) {\n        if (this.exported) return;\n        this.exported = true;\n\n        //the import order is important. the last entry is the most important and should be able to overwrite\n        //previous modules. In order to make that work, we call handleExports in reversed order.\n        //this lets providers from the last import register their provider first, and make them available first\n        //in the injector (which equals to be resolved first).\n        for (let i = this.imports.length - 1; i >= 0; i--) {\n            this.imports[i].setParent(this);\n            this.imports[i].handleExports(buildContext);\n        }\n        // for (const m of this.imports) {\n        //     m.setParent(this);\n        //     m.handleExports(buildContext);\n        // }\n\n        if (!this.preparedProviders) return;\n        if (!this.parent) return;\n        if (this.exportsDisabled) return;\n\n        const exportToken = (token: ExportType, to: InjectorModule) => {\n            if (!this.preparedProviders) return;\n\n            const preparedProvider = lookupPreparedProviders(this.preparedProviders, token, exportLookupMatcher);\n            //if it was not in provider, we continue\n            if (!preparedProvider) return;\n\n            //mark this provider as redirect to `exportTo`\n            preparedProvider.resolveFrom = to;\n\n            const parentProviders = to.getPreparedProviders(buildContext);\n            const parentProvider = lookupPreparedProviders(parentProviders, token, exportLookupMatcher);\n            //if the parent has this token already defined, we just switch its module to ours,\n            //so it's able to inject our encapsulated services.\n            if (parentProvider) {\n                //we add our module as additional source for potential dependencies\n                registerPreparedProvider(parentProviders, preparedProvider.modules, preparedProvider.providers, false);\n            } else {\n                // [this, to] is used so that this service resolves dependencies from the target first (so it can overwrite them)\n                // and falls back to the module it was defined in. This includes configureProvider() calls.\n                parentProviders.push({ token: preparedProvider.token, modules: [to, this], providers: preparedProvider.providers.slice() });\n            }\n        };\n\n        if (this.root) {\n            if (this.exports.length !== 0) {\n                throw new Error(`Can not use forRoot and exports at the same time in module ${this.constructor.name}. Either you want to export everything to the root (via forRoot: true), or export a subset to the parent (via exports)`);\n            }\n\n            const root = this.findRoot();\n            if (root !== this) {\n                for (const prepared of this.preparedProviders) {\n                    exportToken(prepared.token, root);\n                }\n            }\n        } else {\n            for (const entry of this.exports) {\n                if ((isClass(entry) && isPrototypeOfBase(entry, InjectorModule)) || entry instanceof InjectorModule) {\n                    const moduleInstance = isClass(entry) ? this.imports.find(v => v instanceof entry) : entry;\n                    if (!moduleInstance) {\n                        throw new Error(`Unknown module ${getClassName(entry)} exported from ${getClassName(this)}. The module was never imported.`);\n                    }\n\n                    //export everything to the parent that we received from that `entry` module\n                    for (const preparedProvider of this.preparedProviders) {\n                        if (preparedProvider.modules.includes(moduleInstance)) {\n                            //this provider was received from `entry`\n\n                            //mark this provider as redirect to `exportTo`\n                            preparedProvider.resolveFrom = this.parent;\n\n                            const parentProviders = this.parent.getPreparedProviders(buildContext);\n                            const parentProvider = lookupPreparedProviders(parentProviders, preparedProvider.token, exportLookupMatcher);\n                            //if the parent has this token already defined, we just switch its module to ours,\n                            //so it's able to inject our encapsulated services.\n                            if (parentProvider) {\n                                //we add our module as additional source for potential dependencies\n                                registerPreparedProvider(parentProviders, preparedProvider.modules, preparedProvider.providers, false);\n                            } else {\n                                parentProviders.push({\n                                    token: preparedProvider.token,\n                                    modules: [this, ...preparedProvider.modules],\n                                    providers: preparedProvider.providers.slice(),\n                                });\n                            }\n                        }\n                    }\n                } else {\n                    //export single token\n                    exportToken(entry, this.parent);\n                }\n            }\n        }\n    }\n\n    findRoot(): InjectorModule {\n        if (this.parent) return this.parent.findRoot();\n        return this;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1118, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1124, "column": 0}, "map": {"version":3,"file":"injector.js","sources":["turbopack://[project]/node_modules/@deepkit/injector/src/injector.ts"],"sourcesContent":["import {\n    isClassProvider,\n    isExistingProvider,\n    isFactoryProvider,\n    isValueProvider,\n    NormalizedProvider,\n    ProviderWithScope,\n    Tag,\n    TagProvider,\n    TagRegistry,\n    Token,\n} from './provider.js';\nimport { AbstractClassType, ClassType, CompilerContext, CustomError, getClassName, getPathValue, isArray, isClass, isFunction, isPrototypeOfBase } from '@deepkit/core';\nimport { ConfigurationProviderRegistry, ConfigureProviderEntry, findModuleForConfig, getScope, InjectorModule, PreparedProvider } from './module.js';\nimport {\n    isOptional,\n    isType,\n    isWithAnnotations,\n    metaAnnotation,\n    ReceiveType,\n    reflect,\n    ReflectionClass,\n    ReflectionFunction,\n    ReflectionKind,\n    resolveReceiveType,\n    stringifyType,\n    Type,\n} from '@deepkit/type';\n\nexport class InjectorError extends CustomError {\n\n}\n\nexport class CircularDependencyError extends InjectorError {\n}\n\nexport class ServiceNotFoundError extends InjectorError {\n}\n\nexport class DependenciesUnmetError extends InjectorError {\n}\n\nexport function tokenLabel(token: Token): string {\n    if (token === null) return 'null';\n    if (token === undefined) return 'undefined';\n    if (token instanceof TagProvider) return 'Tag(' + getClassName(token.provider.provide) + ')';\n    if (typeof token === 'symbol') return token.toString();\n    if (isClass(token)) return getClassName(token);\n    if (isType(token)) return stringifyType(token).replace(/\\n/gm, '');\n    if (isFunction(token.toString)) return token.name;\n\n    return token + '';\n}\n\nfunction functionParameterNotFound(ofName: string, name: string, position: number, token: any) {\n    const argsCheck: string[] = [];\n    for (let i = 0; i < position; i++) argsCheck.push('✓');\n    argsCheck.push('?');\n\n    throw new DependenciesUnmetError(\n        `Unknown function argument '${name}: ${tokenLabel(token)}' of ${ofName}(${argsCheck.join(', ')}). Make sure '${tokenLabel(token)}' is provided.`,\n    );\n}\n\nfunction constructorParameterNotFound(ofName: string, name: string, position: number, token: any) {\n    const argsCheck: string[] = [];\n    for (let i = 0; i < position; i++) argsCheck.push('✓');\n    argsCheck.push('?');\n\n    throw new DependenciesUnmetError(\n        `Unknown constructor argument '${name}: ${tokenLabel(token)}' of ${ofName}(${argsCheck.join(', ')}). Make sure '${tokenLabel(token)}' is provided.`,\n    );\n}\n\nfunction serviceNotfoundError(token: any, moduleName: string) {\n    throw new ServiceNotFoundError(\n        `Service '${tokenLabel(token)}' in ${moduleName} not found. Make sure it is provided.`,\n    );\n}\n\nfunction factoryDependencyNotFound(ofName: string, name: string, position: number, token: any) {\n    const argsCheck: string[] = [];\n    for (let i = 0; i < position; i++) argsCheck.push('✓');\n    argsCheck.push('?');\n\n    for (const reset of CircularDetectorResets) reset();\n    throw new DependenciesUnmetError(\n        `Unknown factory dependency argument '${tokenLabel(token)}' of ${ofName}(${argsCheck.join(', ')}). Make sure '${tokenLabel(token)}' is provided.`,\n    );\n}\n\nfunction propertyParameterNotFound(ofName: string, name: string, position: number, token: any) {\n    for (const reset of CircularDetectorResets) reset();\n    throw new DependenciesUnmetError(\n        `Unknown property parameter ${name} of ${ofName}. Make sure '${tokenLabel(token)}' is provided.`,\n    );\n}\n\nfunction transientInjectionTargetUnavailable(ofName: string, name: string, position: number, token: any) {\n    throw new DependenciesUnmetError(\n        `${TransientInjectionTarget.name} is not available for ${name} of ${ofName}. ${TransientInjectionTarget.name} is only available when injecting into other providers`,\n    );\n}\n\ntype Destination = { token: Token; };\n\nfunction createTransientInjectionTarget(destination: Destination | undefined) {\n    if (!destination) {\n        return undefined;\n    }\n\n    return new TransientInjectionTarget(destination.token);\n}\n\nconst CircularDetector: any[] = [];\nconst CircularDetectorResets: (() => void)[] = [];\n\nfunction throwCircularDependency() {\n    const path = CircularDetector.map(tokenLabel).join(' -> ');\n    CircularDetector.length = 0;\n    for (const reset of CircularDetectorResets) reset();\n    throw new CircularDependencyError(`Circular dependency found ${path}`);\n}\n\ninterface Scope {\n    name: string;\n    instances: { [name: string]: any };\n}\n\nexport type ResolveToken<T> = T extends ClassType<infer R> ? R : T extends AbstractClassType<infer R> ? R : T;\n\nexport function resolveToken(provider: ProviderWithScope): Token {\n    if (isClass(provider)) return provider;\n    if (provider instanceof TagProvider) return resolveToken(provider.provider);\n\n    return provider.provide;\n}\n\nexport type ContainerToken = Exclude<Token, Type | TagProvider<any>>;\n\n/**\n * Returns a value that can be compared with `===` to check if two tokens are actually equal even though\n * they are the result of different type expressions.\n *\n * This is used in the big switch-case statement in the generated code to match DI tokens.\n */\nexport function getContainerToken(type: Token): ContainerToken {\n    if (isClass(type)) return type;\n    if (type instanceof TagProvider) return getContainerToken(type.provider);\n\n    if (isType(type)) {\n        if (type.id) return type.id;\n        if (type.kind === ReflectionKind.literal) return type.literal;\n        if (type.kind === ReflectionKind.class) return type.classType;\n        if (type.kind === ReflectionKind.function && type.function) return type.function;\n    }\n\n    return type;\n}\n\nexport interface InjectorInterface {\n    get<T>(token: T, scope?: Scope): ResolveToken<T>;\n}\n\n/**\n * Returns the injector token type if the given type was decorated with `Inject<T>`.\n */\nexport function getInjectOptions(type: Type): Type | undefined {\n    const annotations = metaAnnotation.getForName(type, 'inject');\n    if (!annotations) return;\n    const t = annotations[0];\n    return t && t.kind !== ReflectionKind.never ? t : type;\n}\n\nfunction getPickArguments(type: Type): Type[] | undefined {\n    if (type.typeName === 'Pick' && type.typeArguments && type.typeArguments.length === 2) {\n        return type.typeArguments;\n    }\n    if (!type.originTypes) return;\n\n    for (const origin of type.originTypes) {\n        if (origin.typeName === 'Pick' && origin.typeArguments && origin.typeArguments.length === 2) {\n            return origin.typeArguments;\n        }\n    }\n\n    return;\n}\n\n/**\n * Class describing where a transient provider will be injected.\n *\n * @reflection never\n */\nexport class TransientInjectionTarget {\n    constructor(\n        public readonly token: Token,\n    ) {\n    }\n}\n\n/**\n * A factory function for some class.\n * All properties that are not provided will be resolved using the injector that was used to create the factory.\n */\nexport type PartialFactory<C> = (args: Partial<{ [K in keyof C]: C[K] }>) => C;\n\n/**\n * This is the actual dependency injection container.\n * Every module has its own injector.\n *\n * @reflection never\n */\nexport class Injector implements InjectorInterface {\n    private resolver?: (token: any, scope?: Scope, destination?: Destination) => any;\n    private setter?: (token: any, value: any, scope?: Scope) => any;\n    private instantiations?: (token: any, scope?: string) => number;\n\n    /**\n     * All unscoped provider instances. Scoped instances are attached to `Scope`.\n     */\n    private instances: { [name: string]: any } = {};\n    private instantiated: { [name: string]: number } = {};\n\n    constructor(\n        public readonly module: InjectorModule,\n        private buildContext: BuildContext,\n    ) {\n        module.injector = this;\n        this.build(buildContext);\n    }\n\n    static from(providers: ProviderWithScope[], parent?: Injector): Injector {\n        return new Injector(new InjectorModule(providers, parent?.module), new BuildContext);\n    }\n\n    static fromModule(module: InjectorModule, parent?: Injector): Injector {\n        return new Injector(module, new BuildContext);\n    }\n\n    get<T>(token?: ReceiveType<T> | Token<T>, scope?: Scope): ResolveToken<T> {\n        if (!this.resolver) throw new Error('Injector was not built');\n        if ('string' === typeof token || 'number' === typeof token || 'bigint' === typeof token ||\n            'boolean' === typeof token || 'symbol' === typeof token || isFunction(token) || isClass(token) || token instanceof RegExp) {\n            return this.resolver(getContainerToken(token), scope) as ResolveToken<T>;\n        } else if (isType(token)) {\n            return this.createResolver(isType(token) ? token as Type : resolveReceiveType(token), scope)(scope);\n        } else if (isArray(token)) {\n            return this.createResolver(resolveReceiveType(token), scope)(scope);\n        }\n        throw new Error(`Invalid get<T> argument given ${token}`);\n    }\n\n    set(token: ContainerToken, value: any, scope?: Scope): void {\n        if (!this.setter) throw new Error('Injector was not built');\n        this.setter(token, value, scope);\n    }\n\n    instantiationCount<T>(token: any, scope?: string): number {\n        if (!this.instantiations) throw new Error('Injector was not built');\n        return this.instantiations(token, scope);\n    }\n\n    clear() {\n        this.instances = {};\n    }\n\n    protected build(buildContext: BuildContext): void {\n        const resolverCompiler = new CompilerContext();\n        resolverCompiler.context.set('CircularDetector', CircularDetector);\n        resolverCompiler.context.set('CircularDetectorResets', CircularDetectorResets);\n        resolverCompiler.context.set('throwCircularDependency', throwCircularDependency);\n        resolverCompiler.context.set('tokenNotfoundError', serviceNotfoundError);\n        resolverCompiler.context.set('constructorParameterNotFound', constructorParameterNotFound);\n        resolverCompiler.context.set('functionParameterNotFound', functionParameterNotFound);\n        resolverCompiler.context.set('propertyParameterNotFound', propertyParameterNotFound);\n        resolverCompiler.context.set('factoryDependencyNotFound', factoryDependencyNotFound);\n        resolverCompiler.context.set('transientInjectionTargetUnavailable', transientInjectionTargetUnavailable);\n        resolverCompiler.context.set('createTransientInjectionTarget', createTransientInjectionTarget);\n        resolverCompiler.context.set('injector', this);\n\n        const lines: string[] = [];\n        const resets: string[] = [];\n        const creating: string[] = [];\n\n        const instantiationCompiler = new CompilerContext();\n        instantiationCompiler.context.set('injector', this);\n        const instantiationLines: string[] = [];\n\n        const setterCompiler = new CompilerContext();\n        setterCompiler.context.set('injector', this);\n        const setterLines: string[] = [];\n\n        for (const prepared of this.module.getPreparedProviders(buildContext)) {\n            //scopes will be created first, so they are returned instead of the unscoped instance\n            prepared.providers.sort((a, b) => {\n                if (a.scope && !b.scope) return -1;\n                if (!a.scope && b.scope) return +1;\n                return 0;\n            });\n\n            for (const provider of prepared.providers) {\n                const scope = getScope(provider);\n                const name = 'i' + this.buildContext.providerIndex.reserve();\n                creating.push(`let creating_${name} = false;`);\n                resets.push(`creating_${name} = false;`);\n                const accessor = scope ? 'scope.instances.' + name : 'injector.instances.' + name;\n                const scopeObjectCheck = scope ? ` && scope && scope.name === ${JSON.stringify(scope)}` : '';\n                const scopeCheck = scope ? ` && scope === ${JSON.stringify(scope)}` : '';\n\n                const diToken = getContainerToken(prepared.token);\n\n                setterLines.push(`case token === ${setterCompiler.reserveVariable('token', diToken)}${scopeObjectCheck}: {\n                    if (${accessor} === undefined) {\n                        injector.instantiated.${name} = injector.instantiated.${name} ? injector.instantiated.${name} + 1 : 1;\n                    }\n                    ${accessor} = value;\n                    break;\n                }`);\n\n\n                if (prepared.resolveFrom) {\n                    //it's a redirect\n                    lines.push(`\n                    case token === ${resolverCompiler.reserveConst(diToken, 'token')}${scopeObjectCheck}: {\n                        return ${resolverCompiler.reserveConst(prepared.resolveFrom, 'resolveFrom')}.injector.resolver(${resolverCompiler.reserveConst(diToken, 'token')}, scope, destination);\n                    }\n                    `);\n\n                    instantiationLines.push(`\n                    case token === ${instantiationCompiler.reserveConst(diToken, 'token')}${scopeCheck}: {\n                        return ${instantiationCompiler.reserveConst(prepared.resolveFrom, 'resolveFrom')}.injector.instantiations(${instantiationCompiler.reserveConst(diToken, 'token')}, scope);\n                    }\n                    `);\n                } else {\n                    //we own and instantiate the service\n                    lines.push(this.buildProvider(buildContext, resolverCompiler, name, accessor, scope, prepared.token, provider, prepared.modules));\n\n                    instantiationLines.push(`\n                    case token === ${instantiationCompiler.reserveConst(diToken, 'token')}${scopeCheck}: {\n                        return injector.instantiated.${name} || 0;\n                    }\n                    `);\n                }\n            }\n        }\n\n        this.instantiations = instantiationCompiler.build(`\n            //for ${getClassName(this.module)}\n            switch (true) {\n                ${instantiationLines.join('\\n')}\n            }\n            return 0;\n        `, 'token', 'scope');\n\n        this.setter = setterCompiler.build(`\n            //for ${getClassName(this.module)}\n            switch (true) {\n                ${setterLines.join('\\n')}\n            }\n        `, 'token', 'value', 'scope');\n\n        this.resolver = resolverCompiler.raw(`\n            //for ${getClassName(this.module)}\n            ${creating.join('\\n')};\n\n            CircularDetectorResets.push(() => {\n                ${resets.join('\\n')};\n            });\n\n            return function(token, scope, destination) {\n                switch (true) {\n                    ${lines.join('\\n')}\n                }\n\n                tokenNotfoundError(token, '${getClassName(this.module)}');\n            }\n        `) as any;\n    }\n\n    protected buildProvider(\n        buildContext: BuildContext,\n        compiler: CompilerContext,\n        name: string,\n        accessor: string,\n        scope: string,\n        token: Token,\n        provider: NormalizedProvider,\n        resolveDependenciesFrom: InjectorModule[],\n    ) {\n        let transient = false;\n        let factory: { code: string, dependencies: number } = { code: '', dependencies: 0 };\n        const tokenVar = compiler.reserveConst(getContainerToken(token));\n\n        if (isValueProvider(provider)) {\n            transient = provider.transient === true;\n            const valueVar = compiler.reserveVariable('useValue', provider.useValue);\n            factory.code = `${accessor} = ${valueVar};`;\n        } else if (isClassProvider(provider)) {\n            transient = provider.transient === true;\n\n            let useClass = provider.useClass;\n            if (!useClass) {\n                if (!isClass(provider.provide)) {\n                    throw new Error(`UseClassProvider needs to set either 'useClass' or 'provide' as a ClassType. Got ${provider.provide as any}`);\n                }\n                useClass = provider.provide as ClassType;\n            }\n            factory = this.createFactory(provider, accessor, compiler, useClass, resolveDependenciesFrom);\n        } else if (isExistingProvider(provider)) {\n            transient = provider.transient === true;\n            factory.code = `${accessor} = injector.resolver(${compiler.reserveConst(getContainerToken(provider.useExisting))}, scope, destination)`;\n        } else if (isFactoryProvider(provider)) {\n            transient = provider.transient === true;\n            const args: string[] = [];\n            const reflection = ReflectionFunction.from(provider.useFactory);\n            const ofName = reflection.name === 'anonymous' ? 'useFactory' : reflection.name;\n\n            for (const parameter of reflection.getParameters()) {\n                factory.dependencies++;\n                const tokenType = getInjectOptions(parameter.getType() as Type);\n                args.push(this.createFactoryProperty({\n                    name: parameter.name,\n                    type: tokenType || parameter.getType() as Type,\n                    optional: !parameter.isValueRequired(),\n                }, provider, compiler, resolveDependenciesFrom, ofName, args.length, 'factoryDependencyNotFound'));\n            }\n\n            factory.code = `${accessor} = ${compiler.reserveVariable('factory', provider.useFactory)}(${args.join(', ')});`;\n        } else {\n            throw new Error('Invalid provider');\n        }\n\n        const configureProvider: string[] = [];\n\n        const configurations: ConfigureProviderEntry[] = [];\n        for (const module of resolveDependenciesFrom) {\n            configurations.push(...module.configurationProviderRegistry.get(token));\n        }\n        configurations.push(...buildContext.globalConfigurationProviderRegistry.get(token));\n\n        if (configurations?.length) {\n            configurations.sort((a, b) => {\n                return a.options.order - b.options.order;\n            });\n\n            for (const configure of configurations) {\n                const args: string[] = [accessor];\n                const reflection = ReflectionFunction.from(configure.call);\n                const ofName = reflection.name === 'anonymous' ? 'configureProvider' : reflection.name;\n\n                for (const parameter of reflection.getParameters().slice(1)) {\n                    const tokenType = getInjectOptions(parameter.getType() as Type);\n                    args.push(this.createFactoryProperty({\n                        name: parameter.name,\n                        type: tokenType || parameter.getType() as Type,\n                        optional: !parameter.isValueRequired(),\n                    }, provider, compiler, resolveDependenciesFrom, ofName, args.length, 'functionParameterNotFound'));\n                }\n\n                const call = `${compiler.reserveVariable('configure', configure.call)}(${args.join(', ')});`;\n                if (configure.options.replace) {\n                    configureProvider.push(`${accessor} = ${call}`);\n                } else {\n                    configureProvider.push(call);\n                }\n\n            }\n        } else {\n            configureProvider.push('//no custom provider setup');\n        }\n\n        const scopeCheck = scope ? ` && scope && scope.name === ${JSON.stringify(scope)}` : '';\n\n        //circular dependencies can happen, when for example a service with InjectorContext injected manually instantiates a service.\n        //if that service references back to the first one, it will be a circular loop. So we track that with `creating` state.\n        const creatingVar = `creating_${name}`;\n        const circularDependencyCheckStart = factory.dependencies ? `if (${creatingVar}) throwCircularDependency();${creatingVar} = true;` : '';\n        const circularDependencyCheckEnd = factory.dependencies ? `${creatingVar} = false;` : '';\n\n        return `\n            //${tokenLabel(token)}, from ${resolveDependenciesFrom.map(getClassName).join(', ')}\n            case token === ${tokenVar}${scopeCheck}: {\n                ${!transient ? `if (${accessor} !== undefined) return ${accessor};` : ''}\n                CircularDetector.push(${tokenVar});\n                ${circularDependencyCheckStart}\n                injector.instantiated.${name} = injector.instantiated.${name} ? injector.instantiated.${name} + 1 : 1;\n                ${factory.code}\n                ${circularDependencyCheckEnd}\n                CircularDetector.pop();\n                ${configureProvider.join('\\n')}\n                return ${accessor};\n            }\n        `;\n    }\n\n    protected createFactory(\n        provider: NormalizedProvider,\n        resolvedName: string,\n        compiler: CompilerContext,\n        classType: ClassType,\n        resolveDependenciesFrom: InjectorModule[],\n    ): { code: string, dependencies: number } {\n        if (!classType) throw new Error('Can not create factory for undefined ClassType');\n        const reflectionClass = ReflectionClass.from(classType);\n        const args: string[] = [];\n        const propertyAssignment: string[] = [];\n        const classTypeVar = compiler.reserveVariable('classType', classType);\n\n        let dependencies: number = 0;\n\n        const constructor = reflectionClass.getMethodOrUndefined('constructor');\n        if (constructor) {\n            for (const parameter of constructor.getParameters()) {\n                dependencies++;\n                const tokenType = getInjectOptions(parameter.getType() as Type);\n                args.push(this.createFactoryProperty({\n                    name: parameter.name,\n                    type: tokenType || parameter.getType() as Type,\n                    optional: !parameter.isValueRequired(),\n                }, provider, compiler, resolveDependenciesFrom, getClassName(classType), args.length, 'constructorParameterNotFound'));\n            }\n        }\n\n        for (const property of reflectionClass.getProperties()) {\n            const tokenType = getInjectOptions(property.type);\n            if (!tokenType) continue;\n\n            dependencies++;\n            try {\n                const resolveProperty = this.createFactoryProperty({\n                    name: property.name,\n                    type: tokenType,\n                    optional: !property.isValueRequired(),\n                }, provider, compiler, resolveDependenciesFrom, getClassName(classType), -1, 'propertyParameterNotFound');\n                propertyAssignment.push(`${resolvedName}.${String(property.getName())} = ${resolveProperty};`);\n            } catch (error: any) {\n                throw new Error(`Could not resolve property injection token ${getClassName(classType)}.${String(property.getName())}: ${error.message}`);\n            }\n        }\n\n        return {\n            code: `${resolvedName} = new ${classTypeVar}(${args.join(',')});\\n${propertyAssignment.join('\\n')}`,\n            dependencies,\n        };\n    }\n\n    protected createFactoryProperty(\n        options: { name: string, type: Type, optional: boolean },\n        fromProvider: NormalizedProvider,\n        compiler: CompilerContext,\n        resolveDependenciesFrom: InjectorModule[],\n        ofName: string,\n        argPosition: number,\n        notFoundFunction: string,\n    ): string {\n        let of = `${ofName}.${options.name}`;\n        const destinationVar = compiler.reserveConst({ token: fromProvider.provide });\n\n        if (options.type.kind === ReflectionKind.class) {\n            const found = findModuleForConfig(options.type.classType, resolveDependenciesFrom);\n            if (found) {\n                return compiler.reserveVariable('fullConfig', getPathValue(found.module.getConfig(), found.path));\n            }\n        }\n\n        if (options.type.kind === ReflectionKind.class && options.type.classType === TransientInjectionTarget) {\n            if (fromProvider.transient === true) {\n                const tokenVar = compiler.reserveVariable('token', options.type.classType);\n                const orThrow = options.optional ? '' : `?? transientInjectionTargetUnavailable(${JSON.stringify(ofName)}, ${JSON.stringify(options.name)}, ${argPosition}, ${tokenVar})`;\n                return `createTransientInjectionTarget(destination) ${orThrow}`;\n            } else {\n                throw new Error(`Cannot inject ${TransientInjectionTarget.name} into ${JSON.stringify(ofName)}.${JSON.stringify(options.name)}, as ${JSON.stringify(ofName)} is not transient`);\n            }\n        }\n\n        if (options.type.kind === ReflectionKind.class && options.type.classType === TagRegistry) {\n            return compiler.reserveVariable('tagRegistry', this.buildContext.tagRegistry);\n        }\n\n        if (options.type.kind === ReflectionKind.class) {\n            for (const module of resolveDependenciesFrom) {\n                if (module instanceof options.type.classType) {\n                    return compiler.reserveConst(module, 'module');\n                }\n            }\n        }\n\n        if (options.type.kind === ReflectionKind.class && isPrototypeOfBase(options.type.classType, Tag)) {\n            const tokenVar = compiler.reserveVariable('token', options.type.classType);\n            const resolvedVar = compiler.reserveVariable('tagResolved');\n            const entries = this.buildContext.tagRegistry.resolve(options.type.classType);\n            const args: string[] = [];\n            for (const entry of entries) {\n                args.push(`${compiler.reserveConst(entry.module)}.injector.resolver(${compiler.reserveConst(getContainerToken(entry.tagProvider.provider.provide))}, scope, ${destinationVar})`);\n            }\n            return `new ${tokenVar}(${resolvedVar} || (${resolvedVar} = [${args.join(', ')}]))`;\n        }\n\n        if (options.type.kind === ReflectionKind.function && options.type.typeName === 'PartialFactory') {\n            const type = options.type.typeArguments?.[0];\n            const factory = partialFactory(type, this);\n            const factoryVar = compiler.reserveConst(factory, 'factory');\n            return `${factoryVar}(scope)`;\n        }\n\n        if (options.type.kind === ReflectionKind.objectLiteral) {\n            const pickArguments = getPickArguments(options.type);\n            if (pickArguments) {\n                if (pickArguments[0].kind === ReflectionKind.class) {\n                    const found = findModuleForConfig(pickArguments[0].classType, resolveDependenciesFrom);\n                    if (found) {\n                        const fullConfig = compiler.reserveVariable('fullConfig', getPathValue(found.module.getConfig(), found.path));\n                        let index = pickArguments[1];\n                        if (index.kind === ReflectionKind.literal) {\n                            index = { kind: ReflectionKind.union, types: [index] };\n                        }\n                        if (index.kind === ReflectionKind.union) {\n                            const members: string[] = [];\n                            for (const t of index.types) {\n                                if (t.kind === ReflectionKind.literal) {\n                                    const index = JSON.stringify(t.literal);\n                                    members.push(`${index}: ${fullConfig}[${index}]`);\n                                }\n                            }\n\n                            return `{${members.join(', ')}}`;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (options.type.indexAccessOrigin) {\n            let current = options.type;\n            let module = undefined as InjectorModule | undefined;\n            const accesses: string[] = [];\n\n            while (current && current.indexAccessOrigin) {\n                let found: { module: InjectorModule, path: string } | undefined = undefined;\n                if (current.indexAccessOrigin.container.kind === ReflectionKind.class) {\n                    found = findModuleForConfig(current.indexAccessOrigin.container.classType, resolveDependenciesFrom);\n                }\n                if (current.indexAccessOrigin.index.kind === ReflectionKind.literal) {\n                    accesses.unshift(`[${JSON.stringify(current.indexAccessOrigin.index.literal)}]`);\n                }\n                current = current.indexAccessOrigin.container;\n                if (found) {\n                    module = found.module;\n                    if (found.path) accesses.unshift(`[${JSON.stringify(found.path)}]`);\n                    break;\n                }\n            }\n            if (module) {\n                const fullConfig = compiler.reserveVariable('fullConfig', module.getConfig());\n                return `${fullConfig}${accesses.join('')}`;\n            }\n        }\n\n        let foundPreparedProvider: PreparedProvider | undefined = undefined;\n        for (const module of resolveDependenciesFrom) {\n            foundPreparedProvider = module.getPreparedProvider(options.type, foundPreparedProvider);\n        }\n\n        if (resolveDependenciesFrom[0] !== this.module) {\n            //the provider was exported from another module, so we need to check if there is a more specific candidate\n            foundPreparedProvider = this.module.getPreparedProvider(options.type, foundPreparedProvider);\n        }\n\n        if (!foundPreparedProvider) {\n            //go up parent hierarchy\n            let current: InjectorModule | undefined = this.module;\n            while (current && !foundPreparedProvider) {\n                foundPreparedProvider = current.getPreparedProvider(options.type, foundPreparedProvider);\n                current = current.parent;\n            }\n        }\n\n        if (!foundPreparedProvider && options.optional) return 'undefined';\n        const fromScope = getScope(fromProvider);\n\n        if (!foundPreparedProvider) {\n            if (argPosition >= 0) {\n                const argsCheck: string[] = [];\n                for (let i = 0; i < argPosition; i++) argsCheck.push('✓');\n                argsCheck.push('?');\n                of = `${ofName}(${argsCheck.join(', ')})`;\n            }\n\n            const type = stringifyType(options.type, { showFullDefinition: false }).replace(/\\n/g, '').replace(/\\s\\s+/g, ' ').replace(' & InjectMeta', '');\n            if (options.optional) return 'undefined';\n            throw new DependenciesUnmetError(\n                `Undefined dependency \"${options.name}: ${type}\" of ${of}. Type has no provider${fromScope ? ' in scope ' + fromScope : ''}.`,\n            );\n        }\n\n        const tokenVar = compiler.reserveVariable('token', getContainerToken(foundPreparedProvider.token));\n        const allPossibleScopes = foundPreparedProvider.providers.map(getScope);\n        const unscoped = allPossibleScopes.includes('') && allPossibleScopes.length === 1;\n        const foundProviderLabel = foundPreparedProvider.providers.map(v => v.provide).map(tokenLabel).join(', ');\n\n        if (!unscoped && !allPossibleScopes.includes(fromScope)) {\n            const t = stringifyType(options.type, { showFullDefinition: false });\n            throw new DependenciesUnmetError(\n                `Dependency '${options.name}: ${t}' of ${of} can not be injected into ${fromScope ? 'scope ' + fromScope : 'no scope'}, ` +\n                `since ${foundProviderLabel} only exists in scope${allPossibleScopes.length === 1 ? '' : 's'} ${allPossibleScopes.join(', ')}.`,\n            );\n        }\n\n        //when the dependency is FactoryProvider it might return undefined.\n        //in this case, if the dependency is not optional, we throw an error.\n        const orThrow = options.optional ? '' : `?? ${notFoundFunction}(${JSON.stringify(ofName)}, ${JSON.stringify(options.name)}, ${argPosition}, ${tokenVar})`;\n\n        const resolveFromModule = foundPreparedProvider.resolveFrom || foundPreparedProvider.modules[0];\n        if (resolveFromModule === this.module) {\n            return `injector.resolver(${tokenVar}, scope, ${destinationVar}) ${orThrow}`;\n        }\n        return `${compiler.reserveConst(resolveFromModule)}.injector.resolver(${tokenVar}, scope, ${destinationVar}) ${orThrow}`;\n    }\n\n    createResolver(type: Type, scope?: Scope, label?: string): Resolver<any> {\n        const resolveDependenciesFrom = [this.module];\n        const optional = isOptional(type);\n        if (type.kind === ReflectionKind.propertySignature || type.kind === ReflectionKind.property) type = type.type;\n        if (type.kind === ReflectionKind.parameter) type = type.type;\n\n        type = getInjectOptions(type) || type;\n\n        // if (type.kind === ReflectionKind.union) {\n        //     type = type.types.some(v => v.kind !== ReflectionKind.undefined);\n        // }\n\n        if (type.kind === ReflectionKind.class) {\n            const found = findModuleForConfig(type.classType, resolveDependenciesFrom);\n            if (found) return () => getPathValue(found.module.getConfig(), found.path);\n        }\n\n        if (type.kind === ReflectionKind.class && type.classType === TagRegistry) return () => this.buildContext.tagRegistry;\n\n        if (type.kind === ReflectionKind.class) {\n            for (const module of resolveDependenciesFrom) {\n                if (module instanceof type.classType) return () => module;\n            }\n        }\n\n        if (type.kind === ReflectionKind.class && isPrototypeOfBase(type.classType, Tag)) {\n            const entries = this.buildContext.tagRegistry.resolve(type.classType);\n            const args: any[] = [];\n            for (const entry of entries) {\n                args.push(entry.module.injector!.resolver!(entry.tagProvider.provider.provide, scope));\n            }\n\n            return new type.classType(args);\n        }\n\n        if (type.kind === ReflectionKind.function && type.typeName === 'PartialFactory') {\n            const factoryType = type.typeArguments?.[0];\n            const factory = partialFactory(factoryType, this);\n            return (scopeIn?: Scope) => factory(scopeIn);\n        }\n\n        if (isWithAnnotations(type)) {\n            if (type.kind === ReflectionKind.objectLiteral) {\n                const pickArguments = getPickArguments(type);\n                if (pickArguments) {\n                    if (pickArguments[0].kind === ReflectionKind.class) {\n                        const found = findModuleForConfig(pickArguments[0].classType, resolveDependenciesFrom);\n                        if (found) {\n                            const fullConfig = getPathValue(found.module.getConfig(), found.path);\n                            let index = pickArguments[1];\n                            if (index.kind === ReflectionKind.literal) {\n                                index = { kind: ReflectionKind.union, types: [index] };\n                            }\n                            if (index.kind === ReflectionKind.union) {\n                                const pickedConfig: { [name: string]: any } = {};\n                                for (const t of index.types) {\n                                    if (t.kind === ReflectionKind.literal) {\n                                        const index = JSON.stringify(t.literal);\n                                        pickedConfig[index] = fullConfig[index];\n                                    }\n                                }\n\n                                return () => pickedConfig;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (type.indexAccessOrigin) {\n                let current = type;\n                let config: { [name: string]: any } | undefined = undefined;\n\n                while (current && current.indexAccessOrigin) {\n                    if (current.indexAccessOrigin.container.kind === ReflectionKind.class) {\n                        const found = findModuleForConfig(current.indexAccessOrigin.container.classType, resolveDependenciesFrom);\n                        // Only because it has indexAccessOrigin as class doesn't mean it must be a config reference.\n                        // We can safely ignore it if it's not a config reference.\n                        if (found) {\n                            config = getPathValue(found.module.getConfig(), found.path);\n                        }\n                    }\n                    if (config !== undefined && current.indexAccessOrigin.index.kind === ReflectionKind.literal) {\n                        const index = current.indexAccessOrigin.index.literal;\n                        config = config[String(index)];\n                    }\n                    current = current.indexAccessOrigin.container;\n                }\n\n                if (config !== undefined) return () => config;\n            }\n        }\n\n        let foundPreparedProvider: PreparedProvider | undefined = undefined;\n        for (const module of resolveDependenciesFrom) {\n            foundPreparedProvider = module.getPreparedProvider(type, foundPreparedProvider);\n        }\n\n        if (resolveDependenciesFrom[0] !== this.module) {\n            //the provider was exported from another module, so we need to check if there is a more specific candidate\n            foundPreparedProvider = this.module.getPreparedProvider(type, foundPreparedProvider);\n        }\n\n        if (!foundPreparedProvider) {\n            //go up parent hierarchy\n            let current: InjectorModule | undefined = this.module;\n            while (current && !foundPreparedProvider) {\n                foundPreparedProvider = current.getPreparedProvider(type, foundPreparedProvider);\n                current = current.parent;\n            }\n        }\n\n        const fromScope = scope ? scope.name : '';\n\n        if (!foundPreparedProvider) {\n            if (optional) return () => undefined;\n            const t = stringifyType(type, { showFullDefinition: false });\n            throw new ServiceNotFoundError(\n                `Undefined service \"${label ? label + ': ' : ''}${t}\". Type has no matching provider in ${fromScope ? 'scope ' + fromScope : 'no scope'}.`,\n            );\n        }\n\n        // const allPossibleScopes = foundPreparedProvider.providers.map(getScope);\n        // const unscoped = allPossibleScopes.includes('') && allPossibleScopes.length === 1;\n        //\n        // if (!unscoped && !allPossibleScopes.includes(fromScope)) {\n        //     const t = stringifyType(type, { showFullDefinition: false });\n        //     throw new ServiceNotFoundError(\n        //         `Service \"${t}\" can not be received from ${fromScope ? 'scope ' + fromScope : 'no scope'}, ` +\n        //         `since it only exists in scope${allPossibleScopes.length === 1 ? '' : 's'} ${allPossibleScopes.join(', ')}.`\n        //     );\n        // }\n\n        const resolveFromModule = foundPreparedProvider.resolveFrom || foundPreparedProvider.modules[0];\n\n        return (scopeIn?: Scope) => resolveFromModule.injector!.resolver!(getContainerToken(foundPreparedProvider!.token), scopeIn || scope);\n    }\n}\n\nclass BuildProviderIndex {\n    protected offset: number = 0;\n\n    reserve(): number {\n        return this.offset++;\n    }\n}\n\nexport class BuildContext {\n    static ids: number = 0;\n    public id: number = BuildContext.ids++;\n    tagRegistry: TagRegistry = new TagRegistry;\n    providerIndex: BuildProviderIndex = new BuildProviderIndex;\n\n    /**\n     * In the process of preparing providers, each module redirects their\n     * global setup calls in this registry.\n     */\n    globalConfigurationProviderRegistry: ConfigurationProviderRegistry = new ConfigurationProviderRegistry;\n}\n\nexport type Resolver<T> = (scope?: Scope) => T;\n\n/**\n * A InjectorContext is responsible for taking a root InjectorModule and build all Injectors.\n *\n * It also can create scopes aka a sub InjectorContext with providers from a particular scope.\n */\nexport class InjectorContext {\n    constructor(\n        public rootModule: InjectorModule,\n        public readonly scope?: Scope,\n        protected buildContext: BuildContext = new BuildContext,\n    ) {\n    }\n\n    resolve<T>(module?: InjectorModule, type?: ReceiveType<T>): Resolver<T> {\n        return this.getInjector(module || this.rootModule).createResolver(resolveReceiveType(type), this.scope);\n    }\n\n    getOrUndefined<T>(token?: ReceiveType<T> | Token<T>, module?: InjectorModule): ResolveToken<T> | undefined {\n        try {\n            return this.get(token, module);\n        } catch (error) {\n            return;\n        }\n    }\n\n    get<T>(token?: ReceiveType<T> | Token<T>, module?: InjectorModule): ResolveToken<T> {\n        const injector = this.getInjector(module || this.rootModule);\n        return injector.get(token, this.scope);\n    }\n\n    instantiationCount(token: Token, module?: InjectorModule, scope?: string): number {\n        return this.getInjector(module || this.rootModule).instantiationCount(token, this.scope ? this.scope.name : scope);\n    }\n\n    set<T>(token: T, value: any, module?: InjectorModule): void {\n        return this.getInjector(module || this.rootModule).set(\n            getContainerToken(token),\n            value,\n            this.scope,\n        );\n    }\n\n    static forProviders(providers: ProviderWithScope[]) {\n        return new InjectorContext(new InjectorModule(providers));\n    }\n\n    /**\n     * Returns the unscoped injector. Use `.get(T, Scope)` for resolving scoped token.\n     */\n    getInjector(module: InjectorModule): Injector {\n        return module.getOrCreateInjector(this.buildContext);\n    }\n\n    getRootInjector(): Injector {\n        return this.getInjector(this.rootModule);\n    }\n\n    public createChildScope(scope: string): InjectorContext {\n        return new InjectorContext(this.rootModule, { name: scope, instances: {} }, this.buildContext);\n    }\n}\n\nexport function injectedFunction<T extends (...args: any) => any>(fn: T, injector: Injector, skipParameters: number = 0, type?: Type, skipTypeParameters?: number): ((scope?: Scope, ...args: any[]) => ReturnType<T>) {\n    type = type || reflect(fn);\n    skipTypeParameters = skipTypeParameters === undefined ? skipParameters : skipTypeParameters;\n    if (type.kind === ReflectionKind.function || type.kind === ReflectionKind.method) {\n        const args: Resolver<any>[] = [];\n        for (let i = skipTypeParameters; i < type.parameters.length; i++) {\n            args.push(injector.createResolver(type.parameters[i], undefined, type.parameters[i].name));\n        }\n\n        if (skipParameters === 0) {\n            return ((scope: Scope | undefined) => {\n                return fn(...(args.map(v => v(scope))));\n            }) as any;\n        } else if (skipParameters === 1) {\n            return ((scope: Scope | undefined, p1: any) => {\n                return fn(p1, ...(args.map(v => v(scope))));\n            }) as any;\n        } else if (skipParameters === 2) {\n            return ((scope: Scope | undefined, p1: any, p2: any) => {\n                return fn(p1, p2, ...(args.map(v => v(scope))));\n            }) as any;\n        } else if (skipParameters === 3) {\n            return ((scope: Scope | undefined, p1: any, p2: any, p3: any) => {\n                return fn(p1, p2, p3, ...(args.map(v => v(scope))));\n            }) as any;\n        } else {\n            return ((scope: Scope | undefined, ...input: any[]) => {\n                while (input.length !== skipParameters) {\n                    input.push(undefined);\n                }\n                return fn(...input.slice(0, skipParameters), ...(args.map(v => v(scope))));\n            }) as any;\n        }\n    }\n    return fn;\n}\n\nexport function partialFactory(\n    type: Type | undefined,\n    injector: Injector,\n) {\n    if (!type) throw new Error('Can not create partial factory for undefined type');\n\n    // must be lazy because creating resolvers for types that are never resolved & unresolvable will throw\n    function createLazyResolver(type: Type, label?: string): Resolver<any> {\n        let resolver: Resolver<any> | undefined = undefined;\n        return (scope?: Scope) => {\n            if (!resolver) {\n                resolver = injector.createResolver(type, scope, label);\n            }\n            return resolver(scope);\n        };\n    }\n\n    if (type.kind === ReflectionKind.class) {\n        const classType = type.classType;\n        const reflectionClass = ReflectionClass.from(classType);\n\n        const args: { name: string; resolve: (scope?: Scope) => ReturnType<Resolver<any>> }[] = [];\n        const constructor = reflectionClass.getMethodOrUndefined('constructor');\n        if (constructor) {\n            for (const parameter of constructor.getParameters()) {\n                args.push({\n                    name: parameter.name,\n                    resolve: createLazyResolver(parameter.getType() as Type, parameter.name),\n                });\n            }\n        }\n\n        const properties = new Map<keyof any, (scope?: Scope) => ReturnType<Resolver<any>>>();\n        for (const property of reflectionClass.getProperties()) {\n            const tokenType = getInjectOptions(property.type);\n            if (!tokenType) continue;\n\n            properties.set(property.getName(), createLazyResolver(tokenType, property.name));\n        }\n\n        return (scope?: Scope) => <T>(partial: Partial<{ [K in keyof T]: T[K] }>) => {\n            const instance = new classType(...(args.map((v) => partial[v.name as keyof T] ?? v.resolve(scope))));\n            for (const [property, resolve] of properties.entries()) {\n                instance[property] ??= partial[property as keyof T] ?? resolve(scope);\n            }\n            return instance as T;\n        };\n    }\n\n    if (type.kind === ReflectionKind.objectLiteral) {\n        const properties = new Map<keyof any, (scope?: Scope) => ReturnType<Resolver<any>>>();\n        for (const property of type.types) {\n            if (property.kind !== ReflectionKind.propertySignature) continue;\n            properties.set(property.name, createLazyResolver(property, String(property.name)));\n        }\n\n        return (scope?: Scope) => <T>(partial: Partial<{ [K in keyof T]: T[K] }>) => {\n            const obj: any = {};\n            for (const [property, resolve] of properties.entries()) {\n                obj[property] = partial[property as keyof T] ?? resolve(scope);\n            }\n            return obj as T;\n        };\n    }\n\n    throw new Error(`Can not create partial factory for ${stringifyType(type, { showFullDefinition: false })}`);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2393, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2399, "column": 0}, "map": {"version":3,"file":"jsx.js","sources":["turbopack://[project]/node_modules/@deepkit/injector/src/jsx.ts"],"sourcesContent":["import { ClassType, isArray, isFunction } from '@deepkit/core';\nimport { reflect, ReflectionKind } from '@deepkit/type';\nimport { InjectorContext, Resolver } from './injector.js';\nimport { ProviderWithScope } from './provider.js';\nimport { InjectorModule } from './module.js';\n\nexport function wrapComponent<T extends Function>(fn: T & { __injected?: any }, container: InjectorContext): any {\n    if (fn.__injected) return fn.__injected;\n\n    const type = reflect(fn);\n    if (type.kind !== ReflectionKind.function) return fn;\n\n    const args: Resolver<any>[] = [];\n    const injector = container.getRootInjector();\n\n    const componentName = fn.name;\n\n    for (let i = 1; i < type.parameters.length; i++) {\n        args.push(injector.createResolver(type.parameters[i], undefined, `${componentName}.${type.parameters[i].name}`));\n    }\n\n    const fnWithInjected = (props: any) => {\n        return fn(props, ...(args.map(v => v())));\n    };\n\n    return fn.__injected = function (props: any) {\n        const children = fnWithInjected(props);\n\n        const propsChildren: any[] = [];\n        let changed = false;\n\n        // console.log('children.props.children', children);\n        if ('object' === typeof children && isFunction(children.type)) {\n            // NextJS server side has different children return type\n            return { ...children, type: wrapComponent(children.type, container) };\n\n        } else if ('object' === typeof children && children.props && isArray(children.props.children)) {\n            //that's React in frontend\n            for (const child of children.props.children) {\n                if ('object' === typeof child && 'function' === typeof child.type) {\n                    propsChildren.push({ ...child, type: wrapComponent(child.type, container) });\n                    changed = false;\n                } else {\n                    propsChildren.push(child);\n                }\n            }\n\n            if (changed) {\n                //React freezes the object, so we have to create a new one\n                return { ...children, props: { ...children.props, children: propsChildren } };\n            }\n        }\n\n        return children;\n    } as any;\n}\n\nexport function provideServices<T extends Function>(fn: T, providers: ProviderWithScope[]): T {\n    const container = InjectorContext.forProviders(providers);\n\n    return wrapComponent(fn, container);\n}\n\n/**\n * Wraps the given component with a new injector context.\n *\n * @example\n * ```typescript\n * export class User {\n *     constructor(public name: string) {\n *     }\n * }\n *\n * const providers: ProviderWithScope[] = [\n *     { provide: User, useValue: new User('Peter') }\n * ];\n *\n * function App(props: {}, user: User) {\n *     console.log('user', user);\n * }\n *\n * ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n *     <React.StrictMode>\n *         <ServiceContainer providers={providers}>\n *             <App/>\n *         </ServiceContainer>\n *     </React.StrictMode>,\n * );\n * ````\n *\n *\n * @param props.providers The providers to use for the new injector context.\n * @param props.module The module to use for the new injector context, instead of providers.\n * @param props.state The state class to use for the new injector context.\n */\nexport function ServiceContainer(props: { providers?: ProviderWithScope[], module?: InjectorModule, state?: ClassType, children?: any }): any {\n    const children = props.children;\n    const cacheContainer: any = props.providers || props.module;\n    if (!cacheContainer) throw new Error('No providers or module given');\n    if (!cacheContainer.__injected) {\n        const module = props.module || new InjectorModule(props.providers || []);\n        if (props.state) module.setConfigDefinition(props.state);\n        const container = new InjectorContext(module);\n        cacheContainer.__injected = wrapComponent(children.type, container);\n    }\n\n    return { ...props.children, type: cacheContainer.__injected };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2522, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2528, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@deepkit/injector/index.ts"],"sourcesContent":["export * from './src/injector.js';\nexport * from './src/provider.js';\nexport * from './src/module.js';\nexport * from './src/types.js';\nexport * from './src/jsx.js';\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2535, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}