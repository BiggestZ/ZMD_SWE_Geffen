{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"core.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/core.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport { Buffer } from 'buffer';\nimport { ClassType } from '@deepkit/core';\n\n//on unpopulated properties access\nexport enum UnpopulatedCheck {\n    None, //returns undefined\n    Throw, //throws regular error\n    ReturnSymbol, //returns `unpopulatedSymbol`\n}\n\nexport const unpopulatedSymbol = Symbol('unpopulated');\n\nexport interface TypeSettings {\n    registeredEntities: { [name: string]: ClassType };\n    unpopulatedCheck: UnpopulatedCheck;\n}\n\nexport const typeSettings: TypeSettings = { registeredEntities: {}, unpopulatedCheck: UnpopulatedCheck.Throw };\n\nexport interface TypedArrayClassType<T> {\n    new(...args: any[]): T;\n\n    readonly BYTES_PER_ELEMENT: number;\n}\n\nexport interface TypedArray {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n}\n\nexport function nodeBufferToTypedArray<K>(buf: Buffer, type: TypedArrayClassType<K>): K {\n    return new type(buf.buffer, buf.byteOffset, buf.length / type.BYTES_PER_ELEMENT);\n}\n\n/**\n * This function is only used in browser context, where atob is actually faster than\n * using `Buffer.from` by the `buffer.js` library.\n */\nfunction base64ToUint8ArrayAtoB(base64: string): Uint8Array {\n    const raw = atob(base64);\n    const rawLength = raw.length;\n    const array = new Uint8Array(new ArrayBuffer(rawLength));\n\n    for (let i = 0; i < rawLength; i++) {\n        array[i] = raw.charCodeAt(i);\n    }\n    return array;\n}\n\n/**\n * When using Buffer.from() node is using a buffer from the buffer pool.\n * This makes it necessary to create the given TypedArray using byteOffset and byteLength accordingly.\n *\n * Note: The created TypedArray.buffer is pointing probably to a larger Buffer. Make sure\n * to use byteLength/byeOffset correctly or use typedArrayToArrayBuffer() if you want to use\n * a raw ArrayBuffer that represents the actual data correctly.\n */\nexport function base64ToTypedArray<K>(base64: string, type: TypedArrayClassType<K>): K {\n    if ('function' === typeof atob) {\n        return new type(base64ToUint8ArrayAtoB(base64).buffer);\n    }\n\n    return nodeBufferToTypedArray(Buffer.from(base64, 'base64'), type);\n}\n\n/**\n * Creates a new fresh ArrayBuffer with given data.\n * Note: Regular Buffer.from(base64, 'base64) creates in Node a shared buffer, this function makes\n * sure a copy happens and the ArrayBuffer is not shared.\n */\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n    if ('function' === typeof atob) {\n        return base64ToUint8ArrayAtoB(base64).buffer;\n    }\n\n    return nodeBufferToArrayBuffer(Buffer.from(base64, 'base64'));\n}\n\n/**\n * When using Buffer.from() node is using a buffer from the buffer pool.\n * This makes it necessary to create the a new ArrayType using slice to make a copy.\n *\n * This makes a copy.\n */\nexport function nodeBufferToArrayBuffer<K>(buf: Uint8Array | ArrayBuffer): ArrayBuffer {\n    if (ArrayBuffer.isView(buf)) return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n    return buf;\n}\n\n/**\n * In node environment the TypedArray.buffer is probably a larger buffer from the buffer pool.\n * This makes it necessary to create a Buffer with offset & length so that it accurately represents\n * the given TypedArray.\n */\nexport function typedArrayToBuffer<K>(typedArray: TypedArray): Buffer {\n    if (typedArray instanceof Buffer) return typedArray;\n    return Buffer.from(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n}\n\nexport function arrayBufferToBase64(arrayBuffer: ArrayBuffer): string {\n    return Buffer.from(arrayBuffer).toString('base64');\n}\n\nexport function typedArrayToBase64(typedArray: TypedArray): string {\n    return typedArrayToBuffer(typedArray).toString('base64');\n}\n\n/**\n * Same as Buffer.from() but creates a ArrayBuffer that is not shared.\n */\nexport function arrayBufferFrom(data: string, encoding?: string): ArrayBuffer {\n    return nodeBufferToArrayBuffer(Buffer.from(data, encoding as any));\n}\n\n\n/**\n * Same as Buffer.from(arrayBuffer).toString(encoding), but more in line with the current API.\n */\nexport function arrayBufferTo(arrayBuffer: ArrayBuffer, encoding?: string | 'utf8' | 'base64' | 'ascii') {\n    return Buffer.from(arrayBuffer).toString(encoding as any);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"file":"changes.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/changes.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport { empty } from '@deepkit/core';\n\nexport type NumberFields<T> = { [K in keyof T]: T[K] extends number | bigint ? K : never }[keyof T]\nexport type Expression<T> = { [P in keyof T & string]?: string; }\nexport type Partial<T> = { [P in keyof T & string]?: T[P] }\n\nexport type DeepPartial<T> = {\n    [P in keyof T]?: T[P]\n} & { [deepPath: string]: any };\n\nexport interface ChangesInterface<T> {\n    $set?: DeepPartial<T> | T;\n    $unset?: { [path: string]: number };\n    $inc?: Partial<Pick<T, NumberFields<T>>>;\n}\n\nexport class Changes<T extends object> {\n    $set?: DeepPartial<T> | T;\n    $unset?: { [path: string]: number };\n    $inc?: Partial<Pick<T, NumberFields<T>>>;\n    empty = true;\n\n    fieldNames: string[] = [];\n\n    constructor(\n        changes?: ChangesInterface<T>\n    ) {\n        if (changes) {\n            this.$set = empty(changes.$set) ? undefined : changes.$set;\n            this.$unset = empty(changes.$unset) ? undefined : changes.$unset;\n            this.$inc = empty(changes.$inc) ? undefined : changes.$inc;\n            this.detectEmpty();\n        }\n    }\n\n    clear(): void {\n        this.empty = true;\n        this.$set = undefined;\n        this.$unset = undefined;\n        this.$inc = undefined;\n    }\n\n    getReturning(): string[] {\n        const names: string[] = [];\n\n        if (this.$inc) {\n            for (const i in this.$inc) if (this.$inc.hasOwnProperty(i)) names.push(i);\n        }\n\n        return names;\n    }\n\n    protected detectEmpty() {\n        this.empty = this.$set === undefined && this.$unset === undefined && this.$inc === undefined;\n    }\n\n    replaceSet($set: DeepPartial<T> | T) {\n        this.$set = empty($set) ? undefined : $set;\n        for (const i in $set as any) {\n            if (!this.fieldNames.includes(i)) this.fieldNames.push(i);\n        }\n        this.detectEmpty();\n    }\n\n    mergeSet($set: Partial<T> | T) {\n        if (empty($set)) return;\n\n        if (!this.$set) this.$set = {};\n        for (const i in $set as any) {\n            if (!this.fieldNames.includes(i)) this.fieldNames.push(i);\n            (this.$set as any)[i] = ($set as any)[i];\n        }\n        this.detectEmpty();\n    }\n\n    increase(property: NumberFields<T>, increase: number = 1) {\n        if (!this.$inc) this.$inc = {};\n        (this.$inc as any)[property] = increase;\n        if ('string' === typeof property && !this.fieldNames.includes(property)) this.fieldNames.push(property);\n        this.empty = false;\n    }\n\n    set(property: keyof T & string, value: any) {\n        if (!this.$set) this.$set = {};\n        (this.$set as any)[property] = value;\n        if ('string' === typeof property && !this.fieldNames.includes(property)) this.fieldNames.push(property);\n        this.empty = false;\n    }\n\n    unset(property: keyof T & string, unset = true) {\n        if (!this.$unset) this.$unset = {};\n        (this.$unset as any)[property] = unset;\n        if ('string' === typeof property && !this.fieldNames.includes(property)) this.fieldNames.push(property);\n        this.empty = false;\n    }\n\n    has(name: keyof T & string): boolean {\n        return Boolean((this.$set && name in this.$set) || (this.$unset && name in this.$unset) || (this.$inc && name in this.$inc));\n    }\n}\n\nexport class ItemChanges<T extends object> extends Changes<T> {\n    constructor(\n        changes: ChangesInterface<T> = {},\n        protected item: T\n    ) {\n        super(changes);\n    }\n\n    increase(property: NumberFields<T>, increase: number = 1) {\n        super.increase(property, increase);\n        (this.item as any)[property] += increase;\n    }\n\n    set(property: keyof T & string, value: any) {\n        super.set(property, value);\n        (this.item as any)[property] = value;\n    }\n\n    unset(property: keyof T & string, unset: boolean = true) {\n        super.unset(property, unset);\n        (this.item as any)[property] = undefined;\n    }\n}\n\nexport const changeSetSymbol = Symbol('changeSet');\n\nexport class AtomicChangeInstance<T extends object> {\n    public readonly changeSet: Changes<T> = new Changes<T>();\n\n    constructor(protected object: any) {\n        this.changeSet.$inc = {};\n        (object as any)[changeSetSymbol] = this.changeSet;\n    }\n\n    increase(property: NumberFields<T>, increase: number = 1) {\n        this.object[property] += increase;\n        this.changeSet.increase(property, increase);\n    }\n}\n\nexport function atomicChange<T extends object>(object: T) {\n    return new AtomicChangeInstance<T>(object);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 466, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 472, "column": 0}, "map": {"version":3,"file":"extends.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/reflection/extends.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport {\n    addType,\n    emptyObject,\n    flatten,\n    getTypeJitContainer,\n    indexAccess,\n    isMember,\n    isOptional,\n    isPrimitive,\n    isType,\n    isTypeIncluded,\n    ReflectionKind,\n    resolveTypeMembers,\n    stringifyType,\n    Type,\n    TypeAny,\n    TypeCallSignature,\n    TypeFunction,\n    TypeInfer,\n    TypeLiteral,\n    TypeMethod,\n    TypeMethodSignature,\n    TypeNumber,\n    TypeObjectLiteral,\n    TypeParameter,\n    TypePromise,\n    TypeString,\n    TypeTemplateLiteral,\n    TypeTuple,\n    TypeUnion,\n} from './type.js';\nimport { isPrototypeOfBase } from '@deepkit/core';\nimport { typeInfer } from './processor.js';\n\ntype AssignableType = Type | string | boolean | number | symbol | bigint | undefined | null;\n\ntype StackEntry = {\n    left: Type,\n    right: Type,\n}\n\nfunction hasStack(extendStack: StackEntry[], left: Type, right: Type): boolean {\n    for (const entry of extendStack) {\n        if (entry.left === left && entry.right === right) return true;\n    }\n    return false;\n}\n\n/**\n * The check of `extends` in Typescript. This function can be read as `left extends right`.\n *\n * See https://www.typescriptlang.org/docs/handbook/type-compatibility.html#any-unknown-object-void-undefined-null-and-never-assignability\n * This algo follows strict mode.\n *\n * Warning: If you do not pass Type objects, typeInfer() is used which does not use cache (it is designed to be called withing type processor)\n */\nexport function isExtendable(leftValue: AssignableType, rightValue: AssignableType, extendStack: StackEntry[] = []): boolean {\n    const start = Date.now();\n    const right: Type = isType(rightValue) ? rightValue : typeInfer(rightValue);\n    const left: Type = isType(leftValue) ? leftValue : typeInfer(leftValue);\n\n    const valid = _isExtendable(left, right, extendStack);\n    const took = Date.now() - start;\n\n    if (took > 100) {\n        console.warn('isExtendable took very long', Date.now() - start, 'ms comparing', stringifyType(left), 'and', stringifyType(right));\n    }\n\n    return valid;\n}\n\nfunction isFunctionLike(type: Type) {\n    return type.kind === ReflectionKind.function || type.kind === ReflectionKind.method || type.kind === ReflectionKind.callSignature\n        || type.kind === ReflectionKind.methodSignature || type.kind === ReflectionKind.objectLiteral\n        || ((type.kind === ReflectionKind.property || type.kind === ReflectionKind.propertySignature) && type.type.kind === ReflectionKind.function);\n}\n\nfunction getFunctionLikeType(type: Type): TypeMethod | TypeMethodSignature | TypeFunction | TypeCallSignature | undefined {\n    if (type.kind === ReflectionKind.function || type.kind === ReflectionKind.method || type.kind === ReflectionKind.methodSignature) return type;\n    if (type.kind === ReflectionKind.objectLiteral) {\n        for (const member of resolveTypeMembers(type)) {\n            if (member.kind === ReflectionKind.callSignature) return member;\n        }\n    }\n    if (type.kind === ReflectionKind.property || type.kind === ReflectionKind.propertySignature) {\n        return type.type.kind === ReflectionKind.function ? getFunctionLikeType(type.type) : undefined;\n    }\n    return;\n}\n\nexport function _isExtendable(left: Type, right: Type, extendStack: StackEntry[] = []): boolean {\n    if (hasStack(extendStack, left, right)) return true;\n\n    try {\n        extendStack.push({ left, right });\n\n        if (right === left) return true;\n\n        if (left.kind === ReflectionKind.infer) {\n            left.set(right as Type);\n            return true;\n        }\n\n        if (right.kind === ReflectionKind.infer) {\n            right.set(left as Type);\n            return true;\n        }\n\n        if (right.kind === ReflectionKind.any || right.kind === ReflectionKind.unknown) return true;\n        if (left.kind === ReflectionKind.promise && right.kind === ReflectionKind.promise) return _isExtendable(left.type, right.type);\n\n        if (left.kind === ReflectionKind.promise && right.kind === ReflectionKind.object) return true;\n\n        if (left.kind === ReflectionKind.promise) {\n            return _isExtendable(createPromiseObjectLiteral(left), right);\n        }\n        if (right.kind === ReflectionKind.promise) {\n            return _isExtendable(left, createPromiseObjectLiteral(right));\n        }\n\n        if (right.kind !== ReflectionKind.union) {\n            if (left.kind === ReflectionKind.null) {\n                return right.kind === ReflectionKind.null;\n            }\n\n            if (left.kind === ReflectionKind.undefined) {\n                return right.kind === ReflectionKind.void || right.kind === ReflectionKind.undefined;\n            }\n\n            if (left.kind === ReflectionKind.void) {\n                return right.kind === ReflectionKind.void;\n            }\n\n            if (left.kind === ReflectionKind.any) {\n                return right.kind !== ReflectionKind.never;\n            }\n\n            if (left.kind === ReflectionKind.object) {\n                return right.kind === ReflectionKind.object\n                    || (right.kind === ReflectionKind.objectLiteral && right.types.length === 0)\n                    || (right.kind === ReflectionKind.class && right.types.length === 0);\n            }\n\n            if (left.kind === ReflectionKind.objectLiteral && left.types.length === 0) {\n                return right.kind === ReflectionKind.object\n                    || (right.kind === ReflectionKind.objectLiteral && right.types.length === 0)\n                    || (right.kind === ReflectionKind.class && right.types.length === 0);\n            }\n        }\n\n        if (left.kind === ReflectionKind.never) return true;\n        if (right.kind === ReflectionKind.never) return false;\n\n        if (left.kind === ReflectionKind.literal && right.kind === ReflectionKind.literal) return left.literal === right.literal;\n        if (left.kind === ReflectionKind.string && right.kind === ReflectionKind.string) return true;\n        if (left.kind === ReflectionKind.number && right.kind === ReflectionKind.number) return true;\n        if (left.kind === ReflectionKind.boolean && right.kind === ReflectionKind.boolean) return true;\n        if (left.kind === ReflectionKind.bigint && right.kind === ReflectionKind.bigint) return true;\n        if (left.kind === ReflectionKind.symbol && right.kind === ReflectionKind.symbol) return true;\n        if (left.kind === ReflectionKind.regexp && right.kind === ReflectionKind.regexp) return true;\n\n        if (right.kind === ReflectionKind.objectLiteral) {\n            if (left.kind === ReflectionKind.null || left.kind === ReflectionKind.undefined) return false;\n            if (right.types.length === 0) {\n                //string extends {}, number extends {} are all valid\n                return left.kind === ReflectionKind.templateLiteral || left.kind === ReflectionKind.function || isPrimitive(left);\n            }\n        }\n\n        if (left.kind === ReflectionKind.enum) {\n            if (right.kind === ReflectionKind.enum) {\n                if (left.values.length !== right.values.length) return false;\n                for (let i = 0; i < right.values.length; i++) {\n                    if (left.values[i] !== right.values[i]) return false;\n                }\n                return true;\n            }\n\n            return false;\n        }\n\n        if (left.kind === ReflectionKind.literal) {\n            if ('string' === typeof left.literal && right.kind === ReflectionKind.string) return true;\n            if ('number' === typeof left.literal && right.kind === ReflectionKind.number) return true;\n            if ('boolean' === typeof left.literal && right.kind === ReflectionKind.boolean) return true;\n            if ('bigint' === typeof left.literal && right.kind === ReflectionKind.bigint) return true;\n            if ('symbol' === typeof left.literal && right.kind === ReflectionKind.symbol) return true;\n\n            if ('string' === typeof left.literal && right.kind === ReflectionKind.templateLiteral) {\n                return extendTemplateLiteral(left, right);\n            }\n            if (right.kind === ReflectionKind.union) return right.types.some(v => _isExtendable(left, v, extendStack));\n            return false;\n        }\n\n        if (left.kind === ReflectionKind.templateLiteral) {\n            if (emptyObject(right)) return true;\n            if (right.kind === ReflectionKind.string) return true;\n\n            if (right.kind === ReflectionKind.literal) {\n                if (right.literal === '') return false;\n\n                return extendTemplateLiteral(left, { kind: ReflectionKind.templateLiteral, types: [right] });\n            }\n            if (right.kind === ReflectionKind.templateLiteral) {\n                return extendTemplateLiteral(left, right);\n            }\n        }\n\n        if (isFunctionLike(left) && isFunctionLike(right)) {\n            const leftType = getFunctionLikeType(left);\n            const rightType = getFunctionLikeType(right);\n            if (leftType && rightType) {\n                if (rightType.kind === ReflectionKind.function && rightType.function === Function) return true;\n                if (leftType.kind === ReflectionKind.function && rightType.kind === ReflectionKind.function && leftType.function && leftType.function === rightType.function) return true;\n\n                const returnValid = _isExtendable(leftType.return, rightType.return, extendStack);\n                if (!returnValid) return false;\n\n                return isFunctionParameterExtendable(leftType, rightType, extendStack);\n            }\n        }\n\n        if ((left.kind === ReflectionKind.propertySignature || left.kind === ReflectionKind.property) && (right.kind === ReflectionKind.propertySignature || right.kind === ReflectionKind.property)) {\n            return _isExtendable(left.type, right.type, extendStack);\n        }\n\n        if ((left.kind === ReflectionKind.class || left.kind === ReflectionKind.objectLiteral) && right.kind === ReflectionKind.function && right.name === 'new') {\n            const leftConstructor = (left.types as Type[]).find(v => (v.kind === ReflectionKind.method && v.name === 'constructor') || (v.kind === ReflectionKind.methodSignature && v.name === 'new'));\n            const valid = _isExtendable(right, leftConstructor || { kind: ReflectionKind.function, parameters: [], return: { kind: ReflectionKind.any } }, extendStack);\n            return valid;\n        }\n\n        if ((left.kind === ReflectionKind.class || left.kind === ReflectionKind.objectLiteral) && (right.kind === ReflectionKind.object || (right.kind === ReflectionKind.objectLiteral && right.types.length === 0))) {\n            return true;\n        }\n\n        if ((left.kind === ReflectionKind.class || left.kind === ReflectionKind.objectLiteral) && (right.kind === ReflectionKind.class && right.classType === Date)) {\n            if (left.kind === ReflectionKind.objectLiteral && left.types.length === 0) return true;\n            if (left.kind === ReflectionKind.class && left.classType === Date) return true;\n            return false;\n        }\n\n        if ((left.kind === ReflectionKind.class || left.kind === ReflectionKind.objectLiteral) && (right.kind === ReflectionKind.objectLiteral || right.kind === ReflectionKind.class)) {\n            const rightConstructor = (right.types as Type[]).find(v => (v.kind === ReflectionKind.methodSignature && v.name === 'new')) as TypeMethodSignature | undefined;\n\n            if (left.kind === ReflectionKind.class && rightConstructor) {\n                //if rightConstructor is set then its maybe something like:\n                // `class {} extends {new (...args: []) => infer T} ? T : never`\n                //check if parameters are compatible\n                const leftConstructor = left.types.find(v => (v.kind === ReflectionKind.method && v.name === 'constructor')) as TypeMethod | undefined;\n                if (leftConstructor) {\n                    if (!isFunctionParameterExtendable(leftConstructor, rightConstructor, extendStack)) {\n                        return false;\n                    }\n                }\n\n                return _isExtendable(left, rightConstructor.return, extendStack);\n            }\n\n            for (const member of right.types) {\n                //todo: call signature\n                //todo: index signatures\n\n                if (isMember(member)) {\n                    if (member.name === 'constructor') continue;\n                    const leftMember = (left.types as Type[]).find(v => isMember(v) && v.name === member.name);\n                    if (!leftMember) return false;\n                    if (!_isExtendable(leftMember, member, extendStack)) {\n                        return false;\n                    }\n                }\n            }\n\n            if (left.kind === ReflectionKind.class && right.kind === ReflectionKind.class && left.types.length === 0 && right.types.length === 0) {\n                //class User extends Base {}\n                //User extends Base = true\n                if (left.classType === right.classType) return true;\n                return isPrototypeOfBase(left.classType, right.classType);\n            }\n\n            return true;\n        }\n\n\n        if (left.kind === ReflectionKind.array && right.kind === ReflectionKind.array) {\n            return _isExtendable(left.type, right.type, extendStack);\n        }\n\n        if (left.kind === ReflectionKind.tuple && right.kind === ReflectionKind.array) {\n            const tupleUnion: TypeUnion = { kind: ReflectionKind.union, types: [] };\n            for (const member of left.types) {\n                if (member.optional && isTypeIncluded(tupleUnion.types, { kind: ReflectionKind.undefined })) tupleUnion.types.push({ kind: ReflectionKind.undefined });\n                const type = member.type.kind === ReflectionKind.rest ? member.type.type : member.type;\n                if (isTypeIncluded(tupleUnion.types, type)) tupleUnion.types.push(type);\n            }\n            return _isExtendable(tupleUnion, right, extendStack);\n        }\n\n        if (left.kind === ReflectionKind.array && right.kind === ReflectionKind.tuple) {\n            const hasRest = right.types.some(v => v.type.kind === ReflectionKind.rest);\n            if (!hasRest && (left.type.kind !== ReflectionKind.union || !isOptional(left.type))) return false;\n            for (const member of right.types) {\n                let type = member.type.kind === ReflectionKind.rest ? member.type.type : member.type;\n                if (member.optional) type = flatten({ kind: ReflectionKind.union, types: [{ kind: ReflectionKind.undefined }, type] });\n                if (!_isExtendable(left.type, type, extendStack)) return false;\n            }\n            return true;\n        }\n\n        if (left.kind === ReflectionKind.tuple && right.kind === ReflectionKind.tuple) {\n            for (let i = 0; i < right.types.length; i++) {\n                const rightType = indexAccess(right, { kind: ReflectionKind.literal, literal: i });\n                const leftType = indexAccess(left, { kind: ReflectionKind.literal, literal: i });\n                if (rightType.kind === ReflectionKind.infer || leftType.kind === ReflectionKind.infer) continue;\n                const valid = _isExtendable(leftType, rightType, extendStack);\n                if (!valid) return false;\n            }\n            inferFromTuple(left, right);\n\n            return true;\n        }\n\n        if (left && left.kind === ReflectionKind.union) return left.types.every(v => _isExtendable(v, right, extendStack));\n\n        if (right.kind === ReflectionKind.union) return right.types.some(v => _isExtendable(left, v, extendStack));\n\n        return false;\n    } finally {\n        // extendStack.pop();\n    }\n}\n\n/**\n * We don't want to embed in each and every file the type definition of Promise<t>,\n * so we do it ondemand at runtime instead. This saves bundle size.\n */\nexport function createPromiseObjectLiteral(type: TypePromise): TypeObjectLiteral {\n    const jit = getTypeJitContainer(type);\n    if (jit.__promiseObjectLiteral) return jit.__promiseObjectLiteral;\n\n    const promise: TypeObjectLiteral = {} as any;\n    jit.__promiseObjectLiteral = promise;\n    Object.assign(promise, {\n        kind: ReflectionKind.objectLiteral,\n        types: [\n            {\n                kind: ReflectionKind.methodSignature, parent: promise, name: 'then',\n                parameters: [\n                    {\n                        kind: ReflectionKind.parameter, parent: {} as any, name: 'onfulfilled',\n                        optional: true,\n                        type: {\n                            kind: ReflectionKind.union, types: [{\n                                kind: ReflectionKind.function, parameters: [\n                                    { kind: ReflectionKind.parameter, name: 'value', type: type.type },\n                                ], return: { kind: ReflectionKind.union, types: [type.type, promise] }\n                            }, { kind: ReflectionKind.null }, { kind: ReflectionKind.undefined }]\n                        }\n                    },\n                    {\n                        kind: ReflectionKind.parameter, parent: {} as any, name: 'onrejected',\n                        optional: true,\n                        type: {\n                            kind: ReflectionKind.function, parameters: [\n                                { kind: ReflectionKind.parameter, name: 'reason', type: { kind: ReflectionKind.any } },\n                            ], return: { kind: ReflectionKind.any }\n                        }\n                    },\n                ], return: { kind: ReflectionKind.any },\n            },\n            {\n                kind: ReflectionKind.methodSignature, parent: promise, name: 'catch',\n                parameters: [\n                    {\n                        kind: ReflectionKind.parameter, parent: {} as any, name: 'onrejected',\n                        optional: true,\n                        type: {\n                            kind: ReflectionKind.function, parameters: [\n                                { kind: ReflectionKind.parameter, name: 'reason', type: { kind: ReflectionKind.any } }\n                            ], return: { kind: ReflectionKind.any }\n                        }\n                    },\n                ], return: { kind: ReflectionKind.any },\n            },\n        ]\n    });\n    return promise;\n}\n\nexport function parametersToTuple(parameters: TypeParameter[]): TypeTuple {\n    const tuple = {\n        kind: ReflectionKind.tuple,\n        types: []\n    } as TypeTuple;\n\n    for (const v of parameters) {\n        tuple.types.push({ kind: ReflectionKind.tupleMember, parent: tuple, name: v.name, optional: (v.optional || v.default !== undefined) ? true : undefined, type: v.type });\n    }\n    return tuple;\n}\n\nfunction isFunctionParameterExtendable(left: { parameters: TypeParameter[] }, right: { parameters: TypeParameter[] }, extendStack: StackEntry[]): boolean {\n    //convert parameters to tuple and just compare that, as it's the same algorithm\n    const leftTuple: TypeTuple = parametersToTuple(left.parameters);\n    const rightTuple: TypeTuple = parametersToTuple(right.parameters);\n\n    //we have to change the position here since its type assignability is inversed to tuples rules\n    // true for tuple:     [a: string] extends [a: string, b: string]\n    // false for function: (a: string) extends (a: string, b: string)\n    const valid = _isExtendable(rightTuple, leftTuple, extendStack);\n    if (valid) {\n        inferFromTuple(leftTuple, rightTuple);\n    }\n    return valid;\n}\n\nexport function extendTemplateLiteral(left: TypeLiteral | TypeTemplateLiteral, right: TypeTemplateLiteral): boolean {\n    interface ReadQueueItem {\n        type: TypeString | TypeNumber | TypeLiteral | TypeAny;\n        position: number;\n        next?: ReadQueueItem;\n    }\n\n    let matchQueue: (TypeInfer | TypeNumber | TypeString | TypeAny)[] = [];\n\n    let current = (left.kind === ReflectionKind.literal ? { type: left as (TypeLiteral & { literal: string }), position: 0 } : {\n        type: left.types[0],\n        position: 0\n    }) as ReadQueueItem | undefined;\n\n    if (current && left.kind === ReflectionKind.templateLiteral) {\n        for (let i = 1; i < left.types.length; i++) {\n            const t = left.types[i];\n            if (t.kind === ReflectionKind.infer) continue;\n            current.next = { type: t, position: 0 };\n        }\n    }\n\n    function search(delimiter: string): ReadQueueItem | undefined {\n        let result = current;\n        while (result) {\n            if (result.type.kind === ReflectionKind.literal) {\n                const value = result.type.literal as string;\n                if (value !== '') {\n                    const position = value.indexOf(delimiter, result.position);\n                    if (position !== -1) {\n                        return { ...result, position: position };\n                    }\n                }\n                //go next\n            }\n\n            result = result.next;\n        }\n\n        //not found\n        return;\n    }\n\n    function handleQueue(end?: ReadQueueItem): boolean {\n        if (matchQueue.length === 0) return true;\n\n        const last = matchQueue[matchQueue.length - 1];\n        for (const item of matchQueue) {\n            const isLast = item === last;\n\n            if (!isLast) {\n                //pick only one character\n                while (current) {\n                    if (current.type.kind === ReflectionKind.literal) {\n                        const value = current.type.literal as string;\n                        if (current.position === value.length) {\n                            //end, go next\n                            current = current.next;\n                            continue;\n                        }\n                        const char = value[current.position++];\n                        if (item.kind === ReflectionKind.number) {\n                            if (value === '' || isNaN(+char)) return false;\n                        } else if (item.kind === ReflectionKind.infer) {\n                            item.set({ kind: ReflectionKind.literal, literal: char });\n                        }\n                    } else if (current.type.kind === ReflectionKind.string) {\n                        if (item.kind === ReflectionKind.number) {\n                            return false;\n                        } else if (item.kind === ReflectionKind.infer) {\n                            item.set(current.type);\n                        }\n                    } else if (current.type.kind === ReflectionKind.any) {\n                        if (item.kind === ReflectionKind.infer) {\n                            item.set(current.type);\n                        }\n                    } else if (current.type.kind === ReflectionKind.number) {\n                        if (item.kind === ReflectionKind.infer) {\n                            item.set(current.type);\n                        }\n                    }\n                    break;\n                }\n            } else {\n                if (item.kind === ReflectionKind.any || item.kind === ReflectionKind.string || item.kind === ReflectionKind.infer) {\n                    const result: TypeTemplateLiteral = { kind: ReflectionKind.templateLiteral, types: [] };\n                    while (current) {\n                        if (current.type.kind === ReflectionKind.literal) {\n                            const value = current.type.literal as string;\n                            if (current.position === value.length) {\n                                //end, go next\n                                current = current.next;\n                                continue;\n                            }\n\n                            const v = value.slice(current.position, end ? end.position : undefined);\n                            result.types.push({ kind: ReflectionKind.literal, literal: v });\n                        } else {\n                            result.types.push(current.type);\n                            //     if (item.kind === ReflectionKind.infer) {\n                            //         item.set(current.type);\n                            //     }\n                        }\n                        if (end && current.type === end.type) break;\n                        current = current.next;\n                    }\n\n                    if (item.kind === ReflectionKind.infer) {\n                        if (result.types.length === 1) {\n                            item.set(result.types[0]);\n                        } else {\n                            item.set(result);\n                        }\n                    }\n                } else if (item.kind === ReflectionKind.number) {\n                    //read until no number\n                    let value = '';\n                    while (current) {\n                        if (current.type.kind === ReflectionKind.literal) {\n                            const v = (current.type.literal as string).slice(current.position, end ? end.position : undefined);\n                            value += v;\n                        } else if (current.type.kind === ReflectionKind.number || current.type.kind === ReflectionKind.any) {\n                            //number is fine\n                        } else {\n                            //string is not fine as it can contain characters not compatible to number\n                            return false;\n                        }\n                        current = current.next;\n                    }\n                    if (value === '' || isNaN(+value)) return false;\n                }\n            }\n        }\n        matchQueue = [];\n        return true;\n    }\n\n    for (const span of right.types) {\n        if (span.kind === ReflectionKind.literal) {\n            const position = search(span.literal as string);\n            if (!position) return false;\n            if (!handleQueue(position)) return false;\n            current = { ...position, position: position.position + (span.literal as string).length };\n        } else if (span.kind === ReflectionKind.infer) {\n            matchQueue.push(span);\n        } else if (span.kind === ReflectionKind.string) {\n            matchQueue.push(span);\n        } else if (span.kind === ReflectionKind.number) {\n            matchQueue.push(span);\n        }\n    }\n    if (!handleQueue()) return false;\n\n    return true;\n}\n\nfunction inferFromTuple(left: TypeTuple, right: TypeTuple) {\n    //when all types match, we find `infer`\n    for (let i = 0; i < right.types.length; i++) {\n        const rightType = right.types[i];\n        if (rightType.type.kind === ReflectionKind.infer || (rightType.type.kind === ReflectionKind.rest && rightType.type.type.kind === ReflectionKind.infer)) {\n            const inferred: TypeTuple = { kind: ReflectionKind.tuple, types: [] };\n            let restAdded = false;\n            for (let j = 0; j < left.types.length; j++) {\n                const leftType = left.types[j];\n                if (leftType.type.kind === ReflectionKind.rest) {\n                    addType(inferred, leftType);\n                    restAdded = true; //when a rest element is added, all subsequent types will be added as well\n                } else if (restAdded || j >= i) {\n                    addType(inferred, leftType);\n                }\n            }\n\n            //[foo: string, ...args: infer P] P keeps being tuple\n            //[foo: string, args: infer P] P no tuple\n            //[args: infer P] P no tuple\n            let inferredType: Type = inferred.types.length === 0 ? { kind: ReflectionKind.never } : inferred;\n\n            //simplify [...r: number[]] to number[]\n            if (inferred.types.length === 1 && inferred.types[0].type.kind === ReflectionKind.rest) {\n                inferredType = { kind: ReflectionKind.array, type: inferred.types[0].type.type };\n            }\n\n            //when `[1, 2] extends [infer K]` result is `1`, not a tuple\n            if (rightType.type.kind !== ReflectionKind.rest) {\n                inferredType = inferred.types[0].type;\n            }\n\n            if (rightType.type.kind === ReflectionKind.infer) {\n                rightType.type.set(inferredType);\n            } else if (rightType.type.kind === ReflectionKind.rest && rightType.type.type.kind === ReflectionKind.infer) {\n                rightType.type.type.set(inferredType);\n            }\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1257, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1263, "column": 0}, "map": {"version":3,"file":"state.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/reflection/state.ts"],"sourcesContent":["export const state: {nominalId: number} = {\n    nominalId: 1,\n};\n"],"names":[],"mappings":";;;AAAO,MAAM,KAAK,GAAwB;IACtC,SAAS,EAAE,CAAC;CACf,CAAC"}},
    {"offset": {"line": 1269, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1275, "column": 0}, "map": {"version":3,"file":"type.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/reflection/type.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport {\n    AbstractClassType,\n    arrayRemoveItem,\n    ClassType,\n    getClassName,\n    getInheritanceChain,\n    getParentClass,\n    indent,\n    isArray,\n    isClass,\n    isGlobalClass,\n} from '@deepkit/core';\nimport { TypeNumberBrand } from '@deepkit/type-spec';\nimport { getProperty, ReceiveType, reflect, ReflectionClass, resolveReceiveType, toSignature } from './reflection.js';\nimport { isExtendable } from './extends.js';\nimport { state } from './state.js';\nimport { resolveRuntimeType } from './processor.js';\n\nexport enum ReflectionVisibility {\n    public,\n    protected,\n    private,\n}\n\nexport enum ReflectionKind {\n    never,\n    any,\n    unknown,\n    void,\n    object,\n    string,\n    number,\n    boolean,\n    symbol,\n    bigint,\n    null,\n    undefined,\n    regexp,\n\n    literal,\n    templateLiteral,\n    property,\n    method,\n    function,\n    parameter,\n\n    promise,\n\n    /**\n     * Uint8Array, Date, custom classes, Set, Map, etc\n     */\n    class,\n\n    typeParameter,\n    enum,\n    union,\n    intersection,\n\n    array,\n    tuple,\n    tupleMember,\n    enumMember,\n\n    rest,\n\n    objectLiteral,\n    indexSignature,\n    propertySignature,\n    methodSignature,\n\n    infer,\n\n    callSignature,\n}\n\nexport type TypeDecorator = (annotations: Annotations, decorator: TypeObjectLiteral) => boolean;\n\nexport type Annotations = any; //actual { [name: symbol]: any[] };, but not support in older TS\n\n/**\n * @reflection never\n */\nexport interface TypeAnnotations {\n    // if defined, it is a nominal type. the number is unique for each nominal type.\n    id?: number;\n\n    origin?: Type;\n\n    /**\n     * True when this type comes from an inline type, e.g.\n     *\n     * `type A = T;`. Type of `T` is inlined.\n     * `type A = {}`. Type of `{}` is not inlined.\n     *\n     * If the type is not inlined and the result of a type function, then we assign parents of members accordingly. This is not the caee when a type was inlined.\n     */\n    inlined?: true;\n\n    /**\n     * If the type was created by a type function, this contains the alias name.\n     */\n    typeName?: string;\n\n    /**\n     * If the type was created by a type function, this contains the arguments passed the function.\n     */\n    typeArguments?: Type[];\n\n    /**\n     * Set for index access expressions, e.g. Config['property'].\n     */\n    indexAccessOrigin?: { container: TypeClass | TypeObjectLiteral, index: Type };\n\n    /**\n     * type User = {id: number, user: string};\n     * type UserCreate = Pick<User, 'user'>;\n     * typeOf<UserCreate>().originTypes[0].typeName = 'Pick'\n     * typeOf<UserCreate>().originTypes[0].typeArguments = [User, 'user']\n     */\n    originTypes?: { typeName: string, typeArguments?: Type[] }[];\n\n    annotations?: Annotations; //parsed decorator types as annotations\n    decorators?: Type[]; //original decorator type\n\n    scheduleDecorators?: TypeObjectLiteral[];\n\n    /**\n     * A place where arbitrary jit functions and its cache data is stored.\n     */\n    jit?: JitContainer;\n}\n\nexport function applyScheduledAnnotations(type: Type) {\n    if (isWithAnnotations(type) && type.scheduleDecorators) {\n        type.annotations = type.annotations ? { ...type.annotations } : {};\n        type.decorators = type.decorators ? type.decorators.slice() : [];\n        type.decorators.push(...type.scheduleDecorators);\n\n        for (const scheduledDecorator of type.scheduleDecorators) {\n            for (const decorator of typeDecorators) {\n                decorator(type.annotations, scheduledDecorator);\n            }\n        }\n        type.scheduleDecorators = undefined;\n    }\n}\n\nexport function hasTypeInformation(object: ClassType | Function): boolean {\n    return '__type' in object && isArray((object as any).__type);\n}\n\n/**\n * Object to hold runtime jit data.\n */\nexport type JitContainer = any; //actual { [name: string | symbol]: any }; but not supported in older TS\n\nexport function getTypeJitContainer(type: Type): JitContainer {\n    if (!type.jit) type.jit = {};\n    return type.jit;\n}\n\nexport function clearTypeJitContainer(type: Type): void {\n    type.jit = {};\n}\n\nexport interface TypeNever extends TypeAnnotations {\n    kind: ReflectionKind.never,\n    parent?: Type;\n}\n\nexport interface TypeAny extends TypeAnnotations {\n    kind: ReflectionKind.any,\n    parent?: Type;\n}\n\nexport interface TypeUnknown extends TypeAnnotations {\n    kind: ReflectionKind.unknown,\n    parent?: Type;\n}\n\nexport interface TypeVoid extends TypeAnnotations {\n    kind: ReflectionKind.void,\n    parent?: Type;\n}\n\nexport interface TypeObject extends TypeAnnotations {\n    kind: ReflectionKind.object,\n    parent?: Type;\n}\n\nexport interface TypeString extends TypeAnnotations {\n    kind: ReflectionKind.string,\n    parent?: Type;\n}\n\nexport function isIntegerType(type: Type): type is TypeNumber {\n    return type.kind === ReflectionKind.number && type.brand !== undefined && type.brand >= TypeNumberBrand.integer && type.brand <= TypeNumberBrand.uint32;\n}\n\nexport interface TypeNumber extends TypeAnnotations {\n    kind: ReflectionKind.number,\n    brand?: TypeNumberBrand; //built in brand\n    parent?: Type;\n}\n\nexport interface TypeBoolean extends TypeAnnotations {\n    kind: ReflectionKind.boolean,\n    parent?: Type;\n}\n\nexport interface TypeBigInt extends TypeAnnotations {\n    kind: ReflectionKind.bigint,\n    parent?: Type;\n}\n\nexport interface TypeSymbol extends TypeAnnotations {\n    kind: ReflectionKind.symbol,\n    parent?: Type;\n}\n\nexport interface TypeNull extends TypeAnnotations {\n    kind: ReflectionKind.null,\n    parent?: Type;\n}\n\nexport interface TypeUndefined extends TypeAnnotations {\n    kind: ReflectionKind.undefined,\n    parent?: Type;\n}\n\nexport interface TypeLiteral extends TypeAnnotations {\n    kind: ReflectionKind.literal,\n    literal: symbol | string | number | boolean | bigint | RegExp;\n    parent?: Type;\n}\n\nexport interface TypeTemplateLiteral extends TypeAnnotations {\n    kind: ReflectionKind.templateLiteral,\n    types: (TypeString | TypeAny | TypeNumber | TypeLiteral | TypeInfer)[]\n    parent?: Type;\n}\n\nexport interface TypeRegexp extends TypeAnnotations {\n    kind: ReflectionKind.regexp;\n    parent?: Type;\n}\n\nclass User {\n    username!: string;\n\n    getUserName(): this['username'] {\n        return '';\n    }\n}\n\ntype a = User & { username: boolean };\ntype b = ReturnType<a['getUserName']>;\n\nexport interface TypeBaseMember extends TypeAnnotations {\n    visibility: ReflectionVisibility,\n    abstract?: true;\n    static?: true;\n    optional?: true,\n    readonly?: true;\n}\n\nexport interface TypeParameter extends TypeAnnotations {\n    kind: ReflectionKind.parameter,\n    name: string;\n    type: Type;\n    parent: TypeFunction | TypeMethod | TypeMethodSignature | TypeCallSignature;\n\n    //parameter could be a property as well if visibility is set\n    visibility?: ReflectionVisibility,\n    readonly?: true;\n    optional?: true,\n    description?: string;\n\n    /**\n     * Set when the parameter has a default value aka initializer.\n     */\n    default?: () => any\n}\n\nexport interface TypeMethod extends TypeBaseMember {\n    kind: ReflectionKind.method,\n    parent: TypeClass;\n    name: number | string | symbol;\n    description?: string;\n    parameters: TypeParameter[];\n    return: Type;\n}\n\nexport interface TypeProperty extends TypeBaseMember {\n    kind: ReflectionKind.property,\n    parent: TypeClass;\n    visibility: ReflectionVisibility,\n    name: number | string | symbol;\n    description?: string;\n    type: Type;\n\n    /**\n     * Set when the property has a default value aka initializer.\n     */\n    default?: () => any\n}\n\nexport interface TypeFunction extends TypeAnnotations {\n    kind: ReflectionKind.function,\n    parent?: Type;\n    name?: number | string | symbol,\n    description?: string;\n    function?: Function; //reference to the real function if available\n    parameters: TypeParameter[];\n    return: Type;\n}\n\nexport interface TypeCallSignature extends TypeAnnotations {\n    kind: ReflectionKind.callSignature,\n    parent?: Type;\n    parameters: TypeParameter[];\n    return: Type;\n}\n\nexport interface TypePromise extends TypeAnnotations {\n    kind: ReflectionKind.promise,\n    parent?: Type;\n    type: Type;\n}\n\nexport interface TypeClass extends TypeAnnotations {\n    kind: ReflectionKind.class,\n    parent?: Type;\n    classType: ClassType;\n    description?: string;\n\n    /**\n     * When the class extends another class and uses on it generic type arguments, then those arguments\n     * are in this array.\n     * For example `class A extends B<string, boolean> {}` then extendsArguments = [string, boolean].\n     * The reference to `B` is not part of TypeClass since this information is available in JavaScript runtime\n     * by using `Object.getPrototypeOf(type.classType)`.\n     */\n    extendsArguments?: Type[];\n\n    /**\n     * When the class implements another interface/type, then those types are in this array.\n     *\n     * For example `class A implements B<string, boolean> {}` then implements = [B<string, boolean>].\n     */\n    implements?: Type[];\n\n    /**\n     * When class has generic type arguments, e.g. MyClass<string>, it contains\n     * all type arguments. If no type arguments are given, it's undefined.\n     */\n    arguments?: Type[];\n\n    /**\n     * properties/methods.\n     */\n    types: (TypeIndexSignature | TypeProperty | TypeMethod)[];\n}\n\nexport interface TypeEnum extends TypeAnnotations {\n    kind: ReflectionKind.enum,\n    parent?: Type;\n    enum: { [name: string]: string | number | undefined | null };\n    values: (string | number | undefined | null)[];\n    indexType: Type;\n    description?: string;\n}\n\nexport interface TypeEnumMember extends TypeAnnotations {\n    kind: ReflectionKind.enumMember,\n    parent: TypeEnum;\n    name: string;\n    default?: () => string | number;\n}\n\nexport interface TypeTypeParameter extends TypeAnnotations {\n    kind: ReflectionKind.typeParameter,\n    parent?: Type;\n    name: string,\n}\n\nexport interface TypeUnion extends TypeAnnotations {\n    kind: ReflectionKind.union,\n    parent?: Type;\n    types: Type[];\n}\n\nexport interface TypeIntersection extends TypeAnnotations {\n    kind: ReflectionKind.intersection,\n    parent?: Type;\n    types: Type[];\n}\n\nexport interface TypeArray extends TypeAnnotations {\n    kind: ReflectionKind.array,\n    parent?: Type;\n    type: Type;\n}\n\nexport interface TypePropertySignature extends TypeAnnotations {\n    kind: ReflectionKind.propertySignature,\n    parent: TypeObjectLiteral;\n    name: number | string | symbol;\n    optional?: true;\n    readonly?: true;\n    description?: string;\n    type: Type;\n}\n\nexport interface TypeMethodSignature extends TypeAnnotations {\n    kind: ReflectionKind.methodSignature,\n    parent: TypeObjectLiteral;\n    name: number | string | symbol;\n    optional?: true;\n    description?: string;\n    parameters: TypeParameter[];\n    return: Type;\n}\n\n/**\n * Object literals or interfaces.\n */\nexport interface TypeObjectLiteral extends TypeAnnotations {\n    kind: ReflectionKind.objectLiteral,\n\n    parent?: Type;\n    description?: string;\n    types: (TypeIndexSignature | TypePropertySignature | TypeMethodSignature | TypeCallSignature)[];\n\n    /**\n     * When the interface extends another interface/type, then those types are in this array.\n     *\n     * For example `interface A extends B<string, boolean> {}` then implements = [B<string, boolean>].\n     */\n    implements?: Type[];\n}\n\nexport interface TypeIndexSignature extends TypeAnnotations {\n    kind: ReflectionKind.indexSignature,\n    parent: TypeClass | TypeObjectLiteral;\n    index: Type;\n    type: Type;\n}\n\nexport interface TypeInfer extends TypeAnnotations {\n    kind: ReflectionKind.infer,\n    parent?: Type;\n\n    set(type: Type): void;\n}\n\nexport interface TypeTupleMember extends TypeAnnotations {\n    kind: ReflectionKind.tupleMember,\n    parent: TypeTuple;\n    type: Type;\n    optional?: true;\n    name?: string;\n}\n\nexport interface TypeTuple extends TypeAnnotations {\n    kind: ReflectionKind.tuple,\n    parent?: Type;\n    types: TypeTupleMember[]\n}\n\nexport interface TypeRest extends TypeAnnotations {\n    kind: ReflectionKind.rest,\n    parent: TypeTypeParameter | TypeTupleMember;\n    type: Type\n}\n\n/**\n * @reflection never\n */\nexport type Type =\n    TypeNever\n    | TypeAny\n    | TypeUnknown\n    | TypeVoid\n    | TypeObject\n    | TypeString\n    | TypeNumber\n    | TypeBoolean\n    | TypeBigInt\n    | TypeSymbol\n    | TypeNull\n    | TypeUndefined\n    | TypeLiteral\n    | TypeTemplateLiteral\n    | TypeParameter\n    | TypeFunction\n    | TypeMethod\n    | TypeProperty\n    | TypePromise\n    | TypeClass\n    | TypeEnum\n    | TypeEnumMember\n    | TypeUnion\n    | TypeIntersection\n    | TypeArray\n    | TypeObjectLiteral\n    | TypeIndexSignature\n    | TypePropertySignature\n    | TypeMethodSignature\n    | TypeTypeParameter\n    | TypeInfer\n    | TypeTuple\n    | TypeTupleMember\n    | TypeRest\n    | TypeRegexp\n    | TypeCallSignature\n    ;\n\nexport type Widen<T> =\n    T extends string ? string\n        : T extends number ? number\n            : T extends bigint ? bigint\n                : T extends boolean ? boolean\n                    : T extends symbol ? symbol : T;\n\nexport type FindType<T extends Type, LOOKUP extends ReflectionKind> = T extends { kind: infer K } ? K extends LOOKUP ? T : never : never;\n\n/**\n * Merge dynamic runtime types with static types. In the type-system resolves as any, in runtime as the correct type.\n *\n * ```typescript\n * const stringType = {kind: ReflectionKind.string};\n * type t = {a: InlineRuntimeType<typeof stringType>}\n *\n * const value = 34;\n * type t = {a: InlineRuntimeType<typeof value>}\n * ```\n */\nexport type InlineRuntimeType<T extends ReflectionClass<any> | Type | number | string | boolean | bigint> = T extends ReflectionClass<infer K> ? K : any;\n\nexport function isType(entry: any): entry is Type {\n    return 'object' === typeof entry && entry.constructor === Object && 'kind' in entry && 'number' === typeof entry.kind;\n}\n\nexport function isBinary(type: Type): boolean {\n    return type.kind === ReflectionKind.class && binaryTypes.includes(type.classType);\n}\n\nexport function isPrimitive<T extends Type>(type: T): boolean {\n    return type.kind === ReflectionKind.string || type.kind === ReflectionKind.number || type.kind === ReflectionKind.bigint || type.kind === ReflectionKind.boolean\n        || type.kind === ReflectionKind.literal || type.kind === ReflectionKind.null || type.kind === ReflectionKind.undefined;\n}\n\nexport function isPropertyType(type: Type): type is TypePropertySignature | TypeProperty {\n    return type.kind === ReflectionKind.property || type.kind === ReflectionKind.propertySignature;\n}\n\n/**\n * Returns true if the type is TypePropertySignature | TypeProperty and not a static member.\n */\nexport function isPropertyMemberType(type: Type): type is TypePropertySignature | TypeProperty {\n    if (type.kind === ReflectionKind.property) return !type.static;\n    return type.kind === ReflectionKind.propertySignature;\n}\n\n/**\n * Return all properties created in the constructor (via `constructor(public title: string)`)\n *\n * If a non-property parameter is in the constructor, the type is given instead, e.g. `constructor(public title: string, anotherOne:number)` => [TypeProperty, TypeNumber]\n */\nexport function getConstructorProperties(type: TypeClass | TypeObjectLiteral): { parameters: (TypeProperty | Type)[], properties: TypeProperty[] } {\n    const result: { parameters: (TypeProperty | Type)[], properties: TypeProperty[] } = { parameters: [], properties: [] };\n    if (type.kind === ReflectionKind.objectLiteral) return result;\n    const constructor = findMember('constructor', resolveTypeMembers(type)) as TypeMethod | undefined;\n    if (!constructor) return result;\n\n    for (const parameter of constructor.parameters) {\n        const property = findMember(parameter.name, resolveTypeMembers(type));\n        if (property && property.kind === ReflectionKind.property) {\n            result.properties.push(property);\n            result.parameters.push(property);\n        } else {\n            result.parameters.push(parameter.type as Type);\n        }\n    }\n    return result;\n}\n\nexport type WithAnnotations =\n    TypeAny\n    | TypeUnknown\n    | TypeString\n    | TypeNumber\n    | TypeBigInt\n    | TypeBoolean\n    | TypeArray\n    | TypeTuple\n    | TypeLiteral\n    | TypeNull\n    | TypeUndefined\n    | TypeClass\n    | TypeObjectLiteral\n    | TypeObject\n    | TypeTemplateLiteral\n    | TypeRegexp\n    | TypeSymbol;\n\nexport function isWithAnnotations(type: ParentLessType): type is WithAnnotations {\n    return type.kind === ReflectionKind.any || type.kind === ReflectionKind.unknown || type.kind === ReflectionKind.string || type.kind === ReflectionKind.number || type.kind === ReflectionKind.bigint || type.kind === ReflectionKind.boolean\n        || type.kind === ReflectionKind.union || type.kind === ReflectionKind.array || type.kind === ReflectionKind.tuple || type.kind === ReflectionKind.literal || type.kind === ReflectionKind.null || type.kind === ReflectionKind.undefined\n        || type.kind === ReflectionKind.class || type.kind === ReflectionKind.objectLiteral || type.kind === ReflectionKind.object || type.kind === ReflectionKind.templateLiteral\n        || type.kind === ReflectionKind.regexp || type.kind === ReflectionKind.symbol;\n}\n\nexport function getAnnotations(type: WithAnnotations): Annotations {\n    return type.annotations ||= {};\n}\n\ntype StackEntry = {\n    left: Type,\n    right: Type,\n}\n\nfunction hasStack(stack: StackEntry[], left: Type, right: Type): boolean {\n    for (const entry of stack) {\n        if (entry.left === left && entry.right === right) return true;\n    }\n    return false;\n}\n\n\n/**\n * Checks if the structure of a and b are identical.\n */\nexport function isSameType(a: Type, b: Type, stack: StackEntry[] = []): boolean {\n    if (a === b) return true;\n\n    if (hasStack(stack, a, b)) return true;\n\n    stack.push({ left: a, right: b });\n\n    try {\n        if (a.kind !== b.kind) return false;\n        if (a.typeName && b.typeName && a.typeName !== b.typeName) return false;\n        if (a.kind === ReflectionKind.infer || b.kind === ReflectionKind.infer) return false;\n        if (a.kind === ReflectionKind.promise && b.kind === ReflectionKind.promise) return isSameType(a.type, b.type, stack);\n\n        if (a.kind === ReflectionKind.literal) return a.literal === (b as TypeLiteral).literal;\n\n        if (a.kind === ReflectionKind.templateLiteral && b.kind === ReflectionKind.templateLiteral) {\n            if (a.types.length !== b.types.length) return false;\n\n            for (let i = 0; a.types.length; i++) {\n                if (!isSameType(a.types[i], b.types[i], stack)) return false;\n            }\n            return true;\n        }\n\n        if (a.kind === ReflectionKind.class && b.kind === ReflectionKind.class) {\n            return a.classType === b.classType;\n            // if (a.classType !== b.classType) return false;\n            // if (!a.arguments && !b.arguments) return true;\n            // if (!a.arguments || !b.arguments) return false;\n            //\n            // if (a.arguments && !b.arguments) return false;\n            // if (!a.arguments && b.arguments) return false;\n            //\n            // for (let i = 0; a.arguments.length; i++) {\n            //     if (!a.arguments[i] || !b.arguments[i]) return false;\n            //     const aMember = a.arguments[i];\n            //     const bMember = b.arguments[i];\n            //     if (aMember === bMember) continue;\n            //\n            //     if (aMember.kind === ReflectionKind.property) {\n            //         if (bMember.kind === ReflectionKind.property) {\n            //             if (aMember.name !== bMember.name) return false;\n            //             if (aMember.readonly !== bMember.readonly) return false;\n            //             if (aMember.optional !== bMember.optional) return false;\n            //             if (aMember.abstract !== bMember.abstract) return false;\n            //             if (aMember.visibility !== bMember.visibility) return false;\n            //             if (!isSameType(aMember.type, bMember.type, stack)) return false;\n            //         } else {\n            //             return false;\n            //         }\n            //     } else {\n            //         if (!isSameType(aMember, bMember)) return false;\n            //     }\n            // }\n            // return true;\n        }\n\n        if (a.kind === ReflectionKind.objectLiteral && b.kind === ReflectionKind.objectLiteral) {\n            if (a.types.length !== b.types.length) return false;\n\n            for (const aMember of a.types) {\n                //todo: call signature\n                if (aMember.kind === ReflectionKind.indexSignature) {\n                    const valid = b.types.some(v => {\n                        if (v.kind !== ReflectionKind.indexSignature) return false;\n                        const sameIndex = isSameType(aMember.index, v.index, stack);\n                        const sameType = isSameType(aMember.type, v.type, stack);\n                        return sameIndex && sameType;\n                    });\n                    if (!valid) return false;\n                } else if (aMember.kind === ReflectionKind.propertySignature || aMember.kind === ReflectionKind.methodSignature) {\n                    const bMember = findMember(aMember.name, b.types);\n                    if (!bMember) return false;\n                    if (aMember === bMember) continue;\n\n                    if (aMember.kind === ReflectionKind.propertySignature) {\n                        if (bMember.kind === ReflectionKind.propertySignature) {\n                            if (aMember.name !== bMember.name) return false;\n                            if (aMember.readonly !== bMember.readonly) return false;\n                            if (aMember.optional !== bMember.optional) return false;\n                            if (aMember.type === bMember.type) continue;\n                            if (!isSameType(aMember.type, bMember.type, stack)) return false;\n                        } else {\n                            return false;\n                        }\n                    } else {\n                        if (!isSameType(aMember, bMember, stack)) return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        if (a.kind === ReflectionKind.tupleMember) {\n            if (b.kind !== ReflectionKind.tupleMember) return false;\n\n            return a.optional === b.optional && a.name === b.name && isSameType(a.type, b.type, stack);\n        }\n\n        if (a.kind === ReflectionKind.array) {\n            if (b.kind !== ReflectionKind.array) return false;\n\n            return isSameType(a.type, b.type, stack);\n        }\n\n        if (a.kind === ReflectionKind.tuple) {\n            if (b.kind !== ReflectionKind.tuple) return false;\n            if (a.types.length !== b.types.length) return false;\n\n            for (let i = 0; i < a.types.length; i++) {\n                if (!isSameType(a.types[i], b.types[i], stack)) return false;\n            }\n            return true;\n        }\n\n        if (a.kind === ReflectionKind.parameter) {\n            if (b.kind !== ReflectionKind.parameter) return false;\n            return a.name === b.name && a.optional === b.optional && isSameType(a.type, b.type, stack);\n        }\n\n        if (a.kind === ReflectionKind.function || a.kind === ReflectionKind.method || a.kind === ReflectionKind.methodSignature) {\n            if (b.kind !== ReflectionKind.function && b.kind !== ReflectionKind.method && b.kind !== ReflectionKind.methodSignature) return false;\n            if (a.parameters.length !== b.parameters.length) return false;\n            if (a.kind === ReflectionKind.function && b.kind === ReflectionKind.function && a.function !== b.function) return false;\n\n            if (a.kind === ReflectionKind.method && b.kind === ReflectionKind.method) {\n                if (a.visibility !== b.visibility) return false;\n            }\n\n            if (a.name !== b.name) return false;\n\n            for (let i = 0; i < a.parameters.length; i++) {\n                if (!isSameType(a.parameters[i], b.parameters[i], stack)) return false;\n            }\n\n            return isSameType(a.return, b.return, stack);\n        }\n\n        if (a.kind === ReflectionKind.enum) {\n            if (b.kind !== ReflectionKind.enum) return false;\n            if (a.values.length !== b.values.length) return false;\n\n            for (let i = 0; i < a.values.length; i++) {\n                if (a.values[i] !== b.values[i]) return false;\n            }\n\n            return true;\n        }\n\n        if (a.kind === ReflectionKind.union) {\n            if (b.kind !== ReflectionKind.union) return false;\n            if (a.types.length !== b.types.length) return false;\n            for (let i = 0; i < a.types.length; i++) {\n                const left = a.types[i];\n                const right = b.types[i];\n                if (!left || !right) return false;\n                if (left === right) continue;\n\n                const same = isSameType(left, right, stack);\n                if (!same) return false;\n            }\n        }\n\n        return a.kind === b.kind;\n    } finally {\n        // stack.pop();\n    }\n}\n\nexport function addType<T extends Type>(container: T, type: Type): T {\n    if (container.kind === ReflectionKind.tuple) {\n        if (type.kind === ReflectionKind.tupleMember) {\n            container.types.push({ ...type, parent: container });\n        } else {\n            container.types.push({ kind: ReflectionKind.tupleMember, parent: container, type: type as Type });\n        }\n    } else if (container.kind === ReflectionKind.union) {\n        if (type.kind === ReflectionKind.union) {\n            for (const t of flatten(type).types) {\n                addType(container, t);\n            }\n        } else if (type.kind === ReflectionKind.tupleMember) {\n            if (type.optional && !isTypeIncluded(container.types, { kind: ReflectionKind.undefined })) {\n                container.types.push({ kind: ReflectionKind.undefined, parent: container });\n            }\n            addType(container, type.type);\n        } else if (type.kind === ReflectionKind.rest) {\n            addType(container, type.type);\n        } else {\n            if (!isTypeIncluded(container.types, type)) {\n                container.types.push({ ...type as any, parent: container });\n            }\n        }\n    }\n\n    return container;\n}\n\nexport function isTypeIncluded(types: Type[], type: Type, stack: StackEntry[] = []): boolean {\n    for (const t of types) {\n        if (isSameType(t, type, stack)) return true;\n    }\n\n    return false;\n}\n\n/**\n * `true | (string | number)` => `true | string | number`\n */\nexport function flatten<T extends Type>(type: T): T {\n    if (type.kind === ReflectionKind.union) {\n        type.types = flattenUnionTypes(type.types);\n    }\n    return type;\n}\n\n/**\n * Flatten nested union types.\n */\nexport function flattenUnionTypes(types: Type[]): Type[] {\n    const result: Type[] = [];\n    for (const type of types) {\n        if (type.kind === ReflectionKind.union) {\n            for (const s of flattenUnionTypes(type.types)) {\n                if (!isTypeIncluded(result, s)) result.push(s);\n            }\n        } else {\n            if (!isTypeIncluded(result, type)) result.push(type);\n        }\n    }\n\n    return result;\n}\n\n/**\n * empty union => never\n * union with one member => member\n * otherwise the union is returned\n */\nexport function unboxUnion(union: TypeUnion): Type {\n    if (union.types.length === 0) return { kind: ReflectionKind.never };\n    if (union.types.length === 1) return union.types[0] as Type;\n\n    // //convert union of {a: string} | {b: number} | {c: any} to {a?: string, b?: number, c?: any};\n    // //this does work: {a?: string, b?: string} | {b2?: number} | {c: any} to {a?: string, b?: number, c?: any};\n    // //this does not work: {a?: string, b?: string} | {b?: number} | {c: any} to {a?: string, b?: number, c?: any};\n    // if (union.types.length > 1) {\n    //     //if a property is known already, don't merge it\n    //     const known: string[] = [];\n    //\n    //     for (const member of union.types) {\n    //         if (member.kind !== ReflectionKind.objectLiteral) return union;\n    //         if (member.decorators) return union; //if one member has a decorators, we do not merge\n    //         const needsOptional = member.types.length > 1;\n    //         for (const t of member.types) {\n    //             if (t.kind === ReflectionKind.indexSignature) return union;\n    //             const name = memberNameToString(t.name);\n    //             if (known.includes(name)) return union;\n    //             known.push(name);\n    //             if (needsOptional && !isOptional(t)) return union;\n    //         }\n    //     }\n    //     const bl: {[index: string]: boolean} = {};\n    //\n    //     const big: TypeObjectLiteral = { kind: ReflectionKind.objectLiteral, types: [] };\n    //     for (const member of union.types) {\n    //         if (member.kind !== ReflectionKind.objectLiteral) continue;\n    //         for (const t of member.types) {\n    //             if (t.kind === ReflectionKind.indexSignature) return union;\n    //             big.types.push(t);\n    //             t.parent = big;\n    //             t.optional = true;\n    //         }\n    //     }\n    //     big.parent = union.parent;\n    //     return big;\n    // }\n\n    return union;\n}\n\nexport function findMember(\n    index: string | number | symbol | TypeTemplateLiteral, types: Type[]\n): TypePropertySignature | TypeMethodSignature | TypeMethod | TypeProperty | TypeIndexSignature | undefined {\n    const indexType = typeof index;\n\n    for (const member of types) {\n        if (member.kind === ReflectionKind.propertySignature && member.name === index) return member;\n        if (member.kind === ReflectionKind.methodSignature && member.name === index) return member;\n        if (member.kind === ReflectionKind.property && member.name === index) return member;\n        if (member.kind === ReflectionKind.method && member.name === index) return member;\n\n        if (member.kind === ReflectionKind.indexSignature) {\n            if (member.index.kind === ReflectionKind.string && 'string' === indexType) return member;\n            if (member.index.kind === ReflectionKind.number && 'number' === indexType) return member;\n            if (member.index.kind === ReflectionKind.symbol && 'symbol' === indexType) return member;\n            //todo: union needs to match depending on union and indexType\n        }\n    }\n\n    return;\n}\n\nfunction resolveObjectIndexType(type: TypeObjectLiteral | TypeClass, index: Type): Type {\n    if (index.kind === ReflectionKind.literal && ('string' === typeof index.literal || 'number' === typeof index.literal || 'symbol' === typeof index.literal)) {\n        const member = findMember(index.literal, resolveTypeMembers(type));\n        if (member) {\n            if (member.kind === ReflectionKind.indexSignature) {\n                //todo: check if index type matches literal type\n                return member.type;\n            } else if (member.kind === ReflectionKind.method || member.kind === ReflectionKind.methodSignature) {\n                return member;\n            } else if (member.kind === ReflectionKind.property || member.kind === ReflectionKind.propertySignature) {\n                return member.type;\n            } else {\n                return { kind: ReflectionKind.never };\n            }\n        } else {\n            return { kind: ReflectionKind.never };\n        }\n    } else if (index.kind === ReflectionKind.string || index.kind === ReflectionKind.number || index.kind === ReflectionKind.symbol) {\n        //check if index signature match\n        for (const member of resolveTypeMembers(type)) {\n            if (member.kind === ReflectionKind.indexSignature) {\n                if (isExtendable(index, member.index)) return member.type;\n            }\n        }\n    }\n    return { kind: ReflectionKind.never };\n}\n\ninterface CStack {\n    iterator: Type[];\n    i: number;\n    round: number;\n}\n\nexport function emptyObject(type: Type): boolean {\n    return (type.kind === ReflectionKind.objectLiteral || type.kind === ReflectionKind.class) && type.types.length === 0;\n}\n\nexport class CartesianProduct {\n    protected stack: CStack[] = [];\n\n    private current(s: CStack): Type {\n        return s.iterator[s.i];\n    }\n\n    private next(s: CStack): boolean {\n        return (++s.i === s.iterator.length) ? (s.i = 0, false) : true;\n    }\n\n    toGroup(type: Type): Type[] {\n        if (type.kind === ReflectionKind.boolean) {\n            return [{ kind: ReflectionKind.literal, literal: 'false' }, { kind: ReflectionKind.literal, literal: 'true' }];\n        } else if (type.kind === ReflectionKind.null) {\n            return [{ kind: ReflectionKind.literal, literal: 'null' }];\n        } else if (type.kind === ReflectionKind.undefined) {\n            return [{ kind: ReflectionKind.literal, literal: 'undefined' }];\n            // } else if (type.kind === ReflectionKind.templateLiteral) {\n            // //     //todo: this is wrong\n            // //     return type.types;\n            //     const result: Type[] = [];\n            //     for (const s of type.types) {\n            //         const g = this.toGroup(s);\n            //         result.push(...g);\n            //     }\n            //\n            //     return result;\n        } else if (type.kind === ReflectionKind.union) {\n            const result: Type[] = [];\n            for (const s of type.types) {\n                const g = this.toGroup(s);\n                result.push(...g);\n            }\n\n            return result;\n        } else {\n            return [type];\n        }\n    }\n\n    add(item: Type) {\n        this.stack.push({ iterator: this.toGroup(item), i: 0, round: 0 });\n    }\n\n    calculate(): Type[][] {\n        const result: Type[][] = [];\n        outer:\n            while (true) {\n                const row: Type[] = [];\n                for (const s of this.stack) {\n                    const item = this.current(s);\n                    if (item.kind === ReflectionKind.templateLiteral) {\n                        row.push(...item.types);\n                    } else {\n                        row.push(item);\n                    }\n                }\n                result.push(row);\n\n                for (let i = this.stack.length - 1; i >= 0; i--) {\n                    const active = this.next(this.stack[i]);\n                    //when that i stack is active, continue in main loop\n                    if (active) continue outer;\n\n                    //i stack was rewinded. If its the first, it means we are done\n                    if (i === 0) break outer;\n                }\n                break;\n            }\n\n        return result;\n    }\n}\n\n/**\n * Query a container type and return the result.\n *\n * container[index]\n *\n * e.g. {a: string}['a'] => string\n * e.g. {a: string, b: number}[keyof T] => string | number\n * e.g. [string, number][0] => string\n * e.g. [string, number][number] => string | number\n */\nexport function indexAccess(container: Type, index: Type): Type {\n    if (container.kind === ReflectionKind.array) {\n        if ((index.kind === ReflectionKind.literal && 'number' === typeof index.literal) || index.kind === ReflectionKind.number) return container.type;\n        if (index.kind === ReflectionKind.literal && index.literal === 'length') return { kind: ReflectionKind.number };\n    } else if (container.kind === ReflectionKind.tuple) {\n        if (index.kind === ReflectionKind.literal && index.literal === 'length') {\n            return { kind: ReflectionKind.literal, literal: container.types.length };\n        }\n        if (index.kind === ReflectionKind.literal && 'number' === typeof index.literal && index.literal < 0) {\n            index = { kind: ReflectionKind.number };\n        }\n\n        if (index.kind === ReflectionKind.literal && 'number' === typeof index.literal) {\n            type b0 = [string, boolean?][0]; //string\n            type b1 = [string, boolean?][1]; //boolean|undefined\n            type a0 = [string, ...number[], boolean][0]; //string\n            type a1 = [string, ...number[], boolean][1]; //number|boolean\n            type a2 = [string, ...number[], boolean][2]; //number|boolean\n            type a22 = [string, ...number[], boolean][3]; //number|boolean\n            // type a23 = [string, number, boolean][4]; //number|boolean\n            type a3 = [string, number, ...number[], boolean][1]; //number\n            type a4 = [string, number, ...number[], boolean][-2]; //string|number|boolean, minus means all\n            type a5 = [string, number, ...number[], boolean][number]; //string|number|boolean\n\n            let restPosition = -1;\n            for (let i = 0; i < container.types.length; i++) {\n                if (container.types[i].type.kind === ReflectionKind.rest) {\n                    restPosition = i;\n                    break;\n                }\n            }\n\n            if (restPosition === -1 || index.literal < restPosition) {\n                const sub = container.types[index.literal];\n                if (!sub) return { kind: ReflectionKind.undefined };\n                if (sub.optional) return { kind: ReflectionKind.union, types: [sub.type, { kind: ReflectionKind.undefined }] };\n                return sub.type;\n            }\n\n            //index beyond a rest, return all beginning from there as big enum\n\n            const result: TypeUnion = { kind: ReflectionKind.union, types: [] };\n            for (let i = restPosition; i < container.types.length; i++) {\n                const member = container.types[i];\n                const type = member.type.kind === ReflectionKind.rest ? member.type.type : member.type;\n                if (!isTypeIncluded(result.types, type)) result.types.push(type);\n                if (member.optional && !isTypeIncluded(result.types, { kind: ReflectionKind.undefined })) result.types.push({ kind: ReflectionKind.undefined });\n            }\n\n            return unboxUnion(result);\n        } else if (index.kind === ReflectionKind.number) {\n            const union: TypeUnion = { kind: ReflectionKind.union, types: [] };\n            for (const sub of container.types) {\n                if (sub.type.kind === ReflectionKind.rest) {\n                    if (isTypeIncluded(union.types, sub.type.type)) continue;\n                    union.types.push(sub.type.type);\n                } else {\n                    if (isTypeIncluded(union.types, sub.type)) continue;\n                    union.types.push(sub.type);\n                }\n            }\n            return unboxUnion(union);\n        } else {\n            return { kind: ReflectionKind.never };\n        }\n    } else if (container.kind === ReflectionKind.objectLiteral || container.kind === ReflectionKind.class) {\n        if (index.kind === ReflectionKind.literal) {\n            return resolveObjectIndexType(container, index);\n        } else if (index.kind === ReflectionKind.union) {\n            const union: TypeUnion = { kind: ReflectionKind.union, types: [] };\n            for (const t of index.types) {\n                const result = resolveObjectIndexType(container, t);\n                if (result.kind === ReflectionKind.never) continue;\n\n                if (result.kind === ReflectionKind.union) {\n                    for (const resultT of result.types) {\n                        if (isTypeIncluded(union.types, resultT)) continue;\n                        union.types.push(resultT);\n                    }\n                } else {\n                    if (isTypeIncluded(union.types, result)) continue;\n                    union.types.push(result);\n                }\n            }\n            return unboxUnion(union);\n        } else {\n            return { kind: ReflectionKind.never };\n        }\n    } else if (container.kind === ReflectionKind.any) {\n        return { kind: ReflectionKind.any };\n    } else if (container.kind === ReflectionKind.union) {\n        if (index.kind === ReflectionKind.literal) {\n            // Deals with indexing a union with a literal.\n            // For example, if you have a union of {foo: 'bar'} | {foo: 'baz'}\n            // and you index it with 'foo', you get 'bar' | 'baz'. This should\n            // accordingly print ['bar', 'baz'] when valueOf<...>() is called\n            // on the union.\n            if (['string', 'number', 'symbol'].includes(typeof index.literal)) {\n                const union: TypeUnion = { kind: ReflectionKind.union, types: [] };\n\n                // For each type in the union, t, resolve the type at index.\n                for (const t of container.types) {\n                    const resolvedType = indexAccess(t, index);\n                    if (isTypeIncluded(union.types, resolvedType)) continue;\n                    union.types.push(resolvedType);\n                }\n\n                return unboxUnion(union);\n            }\n        } else if (index.kind === ReflectionKind.union) {\n            // Further, it is possible to index a union with a union of\n            // literals. So this deals with that case. For example, if you\n            // have a union of {foo: 'bar', a: 'b'} | {foo: 'baz', a: 'c'} and\n            // you index it with 'foo' | 'a', you get 'bar' | 'baz' | 'b' | 'c'\n            // and valueOf<...>() should return ['bar', 'baz', 'b', 'c'].\n\n            const types: Type[] = [];\n\n            // Pre-compute a list of indices to avoid having to re-do this for\n            // each entry in the union.\n            const indices: TypeLiteral[] = [];\n\n            const unboxedIndex = unboxUnion(index);\n            if (unboxedIndex.kind === ReflectionKind.union) {\n                for (const indexEntry of unboxedIndex.types) {\n                    // (At least for now) accept only literals as indices.\n                    if (indexEntry.kind !== ReflectionKind.literal) continue;\n                    // Don't add duplicate indices.\n                    if (indices.includes(indexEntry)) continue;\n                    // Push the index to the list of indices.\n                    indices.push(indexEntry);\n                }\n            }\n\n            // Each type in the type union (where that type union is indexable)\n            // is assumed to be an object literal or class, so we loop over\n            // each of those types.\n            for (const t of container.types) {\n                // This approach does not produce identical results to\n                // TypeScript - as this reduces all duplicates from the result\n                // (i.e., it produces the 'set' of all types that would be\n                // returned by TypeScript), whereas TypeScript will not reduce\n                // string literals to a single entry, but will reduce numeric\n                // literals. Unless this absolute fidelity is required, this\n                // approach is simpler and probably makes more sense too.\n                for (const index of indices) {\n                    const resolvedType = indexAccess(t, index);\n                    if (isTypeIncluded(types, resolvedType)) continue;\n                    types.push(resolvedType);\n                }\n            }\n\n            return unboxUnion({ kind: ReflectionKind.union, types });\n        }\n    }\n    return { kind: ReflectionKind.never };\n}\n\nexport function merge(types: (TypeObjectLiteral | TypeClass)[]): TypeObjectLiteral {\n    const type: TypeObjectLiteral = { kind: ReflectionKind.objectLiteral, id: state.nominalId++, types: [] };\n\n    for (const subType of types) {\n        for (const member of subType.types) {\n            if (member.kind === ReflectionKind.indexSignature) {\n                member.parent = type;\n                type.types.push(member);\n            } else if (!isMember(member)) {\n                continue;\n            } else {\n                const t = toSignature(member);\n                t.parent = type;\n                const existing = getMember(type, member.name);\n                if (existing) {\n                    arrayRemoveItem(type.types, existing as Type);\n                }\n                type.types.push(t);\n            }\n        }\n    }\n    return type;\n}\n\nexport function narrowOriginalLiteral(type: Type): Type {\n    if ((type.kind === ReflectionKind.string || type.kind === ReflectionKind.number || type.kind === ReflectionKind.boolean || type.kind === ReflectionKind.bigint) && type.origin) {\n        return type.origin;\n    }\n    return type;\n}\n\ntype GetArrayElement<T extends any[]> = [T] extends [Array<infer K>] ? K : never;\ntype RemoveParent<T, K extends keyof T> = { [P in K]: T[P] extends Type[] ? RemoveParentHomomorphic<GetArrayElement<T[P]>>[] : T[P] extends Type ? RemoveParentHomomorphic<T[P]> : T[P] };\ntype RemoveParentHomomorphic<T> = RemoveParent<T, Exclude<keyof T, 'parent'>>;\ntype RemoveDeepParent<T extends Type> = T extends infer K ? RemoveParentHomomorphic<K> : never;\nexport type ParentLessType = RemoveDeepParent<Type>;\n\n/**\n * This function does not do a deep copy, only shallow. A deep copy makes it way to inefficient, so much that router.spec.ts takes up to 20-30seconds\n * to complete instead of barely 30ms.\n */\nexport function copyAndSetParent<T extends ParentLessType>(inc: T, parent?: Type): FindType<Type, T['kind']> {\n    const type = parent ? { ...inc, parent: parent } as Type : { ...inc } as Type;\n\n    if (isWithAnnotations(type) && isWithAnnotations(inc)) {\n        if (inc.annotations) {\n            type.annotations = {};\n            //we have to make copies of each annotation since they get modified when intersected\n            for (const prop of Object.getOwnPropertySymbols(inc.annotations)) {\n                if (inc.annotations[prop]) type.annotations[prop] = inc.annotations[prop].slice();\n            }\n        }\n        if (inc.decorators) type.decorators = inc.decorators.slice();\n        if (inc.indexAccessOrigin) type.indexAccessOrigin = { ...inc.indexAccessOrigin };\n        if (inc.typeArguments) type.typeArguments = inc.typeArguments.slice();\n        type.jit = {};\n    }\n\n    switch (type.kind) {\n        case ReflectionKind.objectLiteral:\n        case ReflectionKind.tuple:\n        case ReflectionKind.union:\n        case ReflectionKind.class:\n        case ReflectionKind.intersection:\n        case ReflectionKind.templateLiteral:\n            type.types = type.types.slice();\n            break;\n        case ReflectionKind.string:\n        case ReflectionKind.number:\n        case ReflectionKind.bigint:\n        case ReflectionKind.symbol:\n        case ReflectionKind.regexp:\n        case ReflectionKind.boolean:\n            // if (type.origin) type.origin = copyAndSetParent(type.origin, type, stack);\n            break;\n        case ReflectionKind.function:\n        case ReflectionKind.method:\n        case ReflectionKind.methodSignature:\n            // type.return = copyAndSetParent(type.return, type, stack);\n            // type.parameters = type.parameters.map(member => copyAndSetParent(member, type, stack));\n            break;\n        case ReflectionKind.propertySignature:\n        case ReflectionKind.property:\n        case ReflectionKind.array:\n        case ReflectionKind.promise:\n        case ReflectionKind.parameter:\n        case ReflectionKind.tupleMember:\n        case ReflectionKind.rest:\n            // type.type = copyAndSetParent(type.type, type, stack);\n            break;\n        case ReflectionKind.indexSignature:\n            // type.index = copyAndSetParent(type.index, type, stack);\n            // type.type = copyAndSetParent(type.type, type, stack);\n            break;\n    }\n\n    return type as any;\n}\n\nexport function widenLiteral(type: Type): Type {\n    if (type.kind === ReflectionKind.literal) {\n        if ('number' === typeof type.literal) return copyAndSetParent({ kind: ReflectionKind.number, origin: type });\n        if ('boolean' === typeof type.literal) return copyAndSetParent({ kind: ReflectionKind.boolean, origin: type });\n        if ('bigint' === typeof type.literal) return copyAndSetParent({ kind: ReflectionKind.bigint, origin: type });\n        if ('symbol' === typeof type.literal) return copyAndSetParent({ kind: ReflectionKind.symbol, origin: type });\n        if ('string' === typeof type.literal) return copyAndSetParent({ kind: ReflectionKind.string, origin: type });\n        if (type.literal instanceof RegExp) return copyAndSetParent({ kind: ReflectionKind.regexp, origin: type });\n    }\n\n    return type;\n}\n\nexport function assertType<K extends ReflectionKind, T>(t: Type | undefined, kind: K): asserts t is FindType<Type, K> {\n    if (!t || t.kind !== kind) throw new Error(`Invalid type ${t ? ReflectionKind[t.kind] : undefined}, expected ${ReflectionKind[kind]}`);\n}\n\nexport function getClassType(type: Type): ClassType {\n    if (type.kind !== ReflectionKind.class) throw new Error(`Type needs to be TypeClass, but ${ReflectionKind[type.kind]} given.`);\n    return type.classType;\n}\n\nexport function isMember(type: Type): type is TypePropertySignature | TypeProperty | TypeMethodSignature | TypeMethod {\n    return type.kind === ReflectionKind.propertySignature || type.kind === ReflectionKind.property\n        || type.kind === ReflectionKind.methodSignature || type.kind === ReflectionKind.method;\n}\n\nexport function hasMember(type: TypeObjectLiteral | TypeClass, memberName: number | string | symbol, memberType?: Type): boolean {\n    return type.types.some(v => isMember(v) && v.name === memberName && (!memberType || isExtendable(v.kind === ReflectionKind.propertySignature || v.kind === ReflectionKind.property ? v.type : v, memberType)));\n}\n\nexport function getMember(type: TypeObjectLiteral | TypeClass, memberName: number | string | symbol): TypeMethodSignature | TypeMethod | TypePropertySignature | TypeProperty | void {\n    return (type.types as (TypeIndexSignature | TypeMethodSignature | TypeMethod | TypePropertySignature | TypeProperty)[]).find(v => isMember(v) && v.name === memberName) as TypeMethodSignature | TypeMethod | TypePropertySignature | TypeProperty | void;\n}\n\nexport function getTypeObjectLiteralFromTypeClass<T extends Type>(type: T): T extends TypeClass ? TypeObjectLiteral : T {\n    if (type.kind === ReflectionKind.class) {\n        const objectLiteral: TypeObjectLiteral = { kind: ReflectionKind.objectLiteral, id: state.nominalId++, types: [] };\n        for (const member of type.types) {\n            if (member.kind === ReflectionKind.indexSignature) {\n                objectLiteral.types.push(member);\n                member.parent = objectLiteral;\n            } else if (member.kind === ReflectionKind.property) {\n                const m = { ...member, kind: ReflectionKind.propertySignature } as any as TypePropertySignature;\n                m.parent = objectLiteral;\n                objectLiteral.types.push(m);\n            } else if (member.kind === ReflectionKind.method) {\n                const m = { ...member, kind: ReflectionKind.methodSignature } as any as TypeMethodSignature;\n                m.parent = objectLiteral;\n                objectLiteral.types.push(m);\n            }\n        }\n        return objectLiteral as any;\n    }\n\n    return type as any;\n}\n\n/**\n * Checks whether `undefined` is allowed as type.\n */\nexport function isOptional(type: Type): boolean {\n    if (isMember(type) && type.optional === true) return true;\n    if (type.kind === ReflectionKind.parameter) return type.optional || isOptional(type.type);\n    if (type.kind === ReflectionKind.tupleMember) return type.optional || isOptional(type.type);\n    if (type.kind === ReflectionKind.property || type.kind === ReflectionKind.propertySignature || type.kind === ReflectionKind.indexSignature) return isOptional(type.type);\n    return type.kind === ReflectionKind.any || type.kind === ReflectionKind.undefined || (type.kind === ReflectionKind.union && type.types.some(isOptional));\n}\n\n/**\n * Whether a property has an initializer/default value.\n */\nexport function hasDefaultValue(type: Type): boolean {\n    return (type.kind === ReflectionKind.property || type.kind === ReflectionKind.parameter) && type.default !== undefined;\n}\n\n/**\n * Checks whether `null` is allowed as type.\n */\nexport function isNullable(type: Type): boolean {\n    if (type.kind === ReflectionKind.property || type.kind === ReflectionKind.propertySignature || type.kind === ReflectionKind.indexSignature) return isNullable(type.type);\n    return type.kind === ReflectionKind.null || (type.kind === ReflectionKind.union && type.types.some(isNullable));\n}\n\n/**\n * Integer\n */\nexport type integer = number;\n\n/**\n * Integer 8 bit.\n * Min value -127, max value 128\n */\nexport type int8 = number;\n\n/**\n * Unsigned integer 8 bit.\n * Min value 0, max value 255\n */\nexport type uint8 = number;\n\n/**\n * Integer 16 bit.\n * Min value -32768, max value 32767\n */\nexport type int16 = number;\n\n/**\n * Unsigned integer 16 bit.\n * Min value 0, max value 65535\n */\nexport type uint16 = number;\n\n/**\n * Integer 8 bit.\n * Min value -2147483648, max value 2147483647\n */\nexport type int32 = number;\n\n/**\n * Unsigned integer 32 bit.\n * Min value 0, max value 4294967295\n */\nexport type uint32 = number;\n\n/**\n * Float (same as number, but different semantic for databases).\n */\nexport type float = number;\n\n/**\n * Float 32 bit.\n */\nexport type float32 = number;\n\n/**\n * Float 64 bit.\n */\nexport type float64 = number;\n\nexport class AnnotationDefinition<T = true> {\n    public symbol: symbol;\n\n    constructor(public readonly id: string) {\n        this.symbol = Symbol(id);\n    }\n\n    register(annotations: Annotations, data: T) {\n        annotations[this.symbol] ||= [];\n        annotations[this.symbol].push(data);\n    }\n\n    reset(annotations: Annotations) {\n        //not `delete` so that Object.assign works\n        annotations[this.symbol] = undefined;\n    }\n\n    registerType<TType extends Type>(type: TType, data: T): TType {\n        type.annotations ||= {};\n        this.register(type.annotations, data);\n        return type;\n    }\n\n    replace(annotations: Annotations, annotation: T[]) {\n        annotations[this.symbol] = annotation;\n    }\n\n    replaceType(type: Type, annotation: T[]) {\n        type.annotations ||= {};\n        type.annotations[this.symbol] = annotation;\n    }\n\n    getAnnotations(type: Type): T[] {\n        if (type.annotations) return type.annotations[this.symbol] || [];\n        return [];\n    }\n\n    getFirst(type: Type): T | undefined {\n        return this.getAnnotations(type)[0];\n    }\n\n    hasAnnotations(type: Type): boolean {\n        return this.getAnnotations(type).length > 0;\n    }\n}\n\nexport type AnnotationType<T extends AnnotationDefinition<any>> = T extends AnnotationDefinition<infer K> ? K : never;\n\nexport type ReferenceActions = 'RESTRICT' | 'NO ACTION' | 'CASCADE' | 'SET NULL' | 'SET DEFAULT';\n\nexport interface ReferenceOptions {\n    /**\n     * Default is CASCADE.\n     */\n    onDelete?: ReferenceActions,\n\n    /**\n     * Default is CASCADE.\n     */\n    onUpdate?: ReferenceActions\n}\n\n/**\n * note: if this is adjusted, make sure to adjust ReflectionClass, entityAnnotation, and type serializer accordingly.\n */\nexport interface EntityOptions {\n    name?: string;\n    description?: string;\n    collection?: string;\n    database?: string;\n    singleTableInheritance?: boolean;\n    indexes?: { names: string[], options: IndexOptions }[];\n}\n\n/**\n * Type to use for custom type annotations.\n *\n *\n * ```typescript\n * type MyType<T extends string> = TypeAnnotation<'myType', T>;\n *\n * interface User {\n *    id: number & MyType<'yes'>;\n * }\n *\n * const reflection = ReflectionClass.from<User>();\n * const id = reflection.getProperty('id');\n *\n * // data is set when `id` used `MyType` and contains the type of 'yes' as type object\n * // which can be converted to JS with `typeToObject`\n * const data = metaAnnotation.getForName(id.type, 'myType');\n * const param1 = typeToObject(data[0]); //yes\n * ```\n */\nexport type TypeAnnotation<T extends string, Options = never> = { __meta?: never & [T, Options] };\n\n/**\n * Type to decorate an interface/object literal with entity information.\n *\n * ```typescript\n * interface User extends Entity<{name: 'user'}> {\n *     id: number & PrimaryKey & AutoIncrement;\n *     username: string & Unique;\n * }\n * ```\n */\nexport type Entity<T extends EntityOptions> = TypeAnnotation<'entity', T>\n\n/**\n * Marks a property as primary key.\n * ```typescript\n * class Entity {\n *     id: number & Primary = 0;\n * }\n * ```\n */\nexport type PrimaryKey = TypeAnnotation<'primaryKey'>;\n\ntype TypeKeyOf<T> = T[keyof T];\nexport type PrimaryKeyFields<T> = any extends T ? any : { [P in keyof T]: Required<T[P]> extends Required<PrimaryKey> ? T[P] : never };\nexport type PrimaryKeyType<T> = any extends T ? any : TypeKeyOf<PrimaryKeyFields<T>>;\n\nexport type ReferenceFields<T> = { [P in keyof T]: Required<T[P]> extends Required<Reference> | Required<BackReference> ? T[P] : never };\n\n/**\n * Marks a primary property key as auto-increment.\n *\n * ```typescript\n * class Entity {\n *     id: number & Primary & AutoIncrement = 0;\n * }\n * ```\n */\nexport type AutoIncrement = TypeAnnotation<'autoIncrement'>;\n\n/**\n * UUID v4, as string, serialized as string in JSON, and binary in database.\n * Use `uuid()` as handy initializer.\n *\n * ```typescript\n * class Entity {\n *     id: UUID = uuid();\n * }\n * ```\n */\nexport type UUID = string & TypeAnnotation<'UUIDv4'>;\n\n/**\n * MongoDB's ObjectID type. serialized as string in JSON, ObjectID in database.\n */\nexport type MongoId = string & TypeAnnotation<'mongoId'>;\n\n/**\n * Same as `bigint` but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases).\n * Negative values will be converted to positive (abs(x)).\n *\n * ```typescript\n * class Entity {\n *     id: BinaryBigInt = 0n;\n * }\n * ```\n */\nexport type BinaryBigInt = bigint & TypeAnnotation<'binaryBigInt'>;\n\n/**\n * Same as `bigint` but serializes to signed binary with unlimited size (instead of 8 bytes in most databases).\n * The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.\n *\n * ```typescript\n * class Entity {\n *     id: SignedBinaryBigInt = 0n;\n * }\n * ```\n */\nexport type SignedBinaryBigInt = bigint & TypeAnnotation<'signedBinaryBigInt'>;\n\nexport interface BackReferenceOptions {\n    /**\n     * Necessary for normalised many-to-many relations. This defines the class of the pivot table/collection.\n     */\n    via?: ClassType | {};\n\n    /**\n     * A reference/backReference can define which reference on the other side\n     * reference back. This is necessary when there are multiple outgoing references\n     * to the same entity.\n     */\n    mappedBy?: string,\n}\n\nexport type Reference<Options extends ReferenceOptions = {}> = TypeAnnotation<'reference', Options>;\nexport type BackReference<Options extends BackReferenceOptions = {}> = TypeAnnotation<'backReference', Options>;\nexport type EmbeddedMeta<Options> = TypeAnnotation<'embedded', Options>;\nexport type Embedded<T, Options extends { prefix?: string } = {}> = T & EmbeddedMeta<Options>;\n\nexport type MapName<Alias extends string, ForSerializer extends string = ''> = { __meta?: never & ['mapName', Alias, ForSerializer] };\n\nexport const referenceAnnotation = new AnnotationDefinition<ReferenceOptions>('reference');\nexport const entityAnnotation = new class extends AnnotationDefinition<EntityOptions> {\n    set<K extends keyof EntityOptions>(type: Type, name: K, value: EntityOptions[K]) {\n        const data = this.getFirst(type) || {};\n        data[name] = value;\n        this.replaceType(type, [data]);\n    }\n\n    get(type: Type): EntityOptions {\n        let data = this.getFirst(type);\n        if (data) return data;\n        data = {};\n        this.replaceType(type, [data]);\n        return data;\n    }\n}('entity');\nexport const mapNameAnnotation = new AnnotationDefinition<{ name: string, serializer?: string }>('entity');\n\nexport const autoIncrementAnnotation = new AnnotationDefinition('autoIncrement');\nexport const primaryKeyAnnotation = new class extends AnnotationDefinition {\n    isPrimaryKey(type: Type): boolean {\n        return this.getAnnotations(type).length > 0;\n    }\n}('primaryKey');\n\nexport interface BackReferenceOptionsResolved {\n    /**\n     * Necessary for normalised many-to-many relations. This defines the class of the pivot table/collection.\n     */\n    via?: TypeClass | TypeObjectLiteral;\n\n    /**\n     * A reference/backReference can define which reference on the other side\n     * reference back. This is necessary when there are multiple outgoing references\n     * to the same entity.\n     */\n    mappedBy?: string,\n}\n\nexport const backReferenceAnnotation = new AnnotationDefinition<BackReferenceOptionsResolved>('backReference');\nexport const validationAnnotation = new AnnotationDefinition<{ name: string, args: Type[] }>('validation');\nexport const UUIDAnnotation = new AnnotationDefinition('UUID');\nexport const mongoIdAnnotation = new AnnotationDefinition('mongoID');\nexport const uuidAnnotation = new AnnotationDefinition('uuid');\nexport const defaultAnnotation = new AnnotationDefinition<Type>('default');\n\nexport function isUUIDType(type: Type): boolean {\n    return uuidAnnotation.getFirst(type) !== undefined;\n}\n\nexport function isPrimaryKeyType(type: Type): boolean {\n    return primaryKeyAnnotation.isPrimaryKey(type);\n}\n\nexport function isAutoIncrementType(type: Type): boolean {\n    return autoIncrementAnnotation.getFirst(type) !== undefined;\n}\n\nexport function isMongoIdType(type: Type): boolean {\n    return mongoIdAnnotation.getFirst(type) !== undefined;\n}\n\nexport function isBinaryBigIntType(type: Type): boolean {\n    return binaryBigIntAnnotation.getFirst(type) !== undefined;\n}\n\nexport function isReferenceType(type: Type): boolean {\n    return referenceAnnotation.getFirst(resolveProperty(type)) !== undefined;\n}\n\nexport function getReferenceType(type: Type): ReferenceOptions | undefined {\n    return referenceAnnotation.getFirst(resolveProperty(type));\n}\n\nexport function isBackReferenceType(type: Type): boolean {\n    return backReferenceAnnotation.getFirst(resolveProperty(type)) !== undefined;\n}\n\nexport function resolveProperty(type: Type): Type {\n    if (type.kind === ReflectionKind.propertySignature || type.kind === ReflectionKind.property) {\n        type = type.type;\n    }\n    return type;\n}\n\nexport function getBackReferenceType(type: Type): BackReferenceOptionsResolved {\n    const options = backReferenceAnnotation.getFirst(type);\n    if (!options) throw new Error('No back reference');\n    return options;\n}\n\nexport function isDateType(type: Type): boolean {\n    return type.kind === ReflectionKind.class && type.classType === Date;\n}\n\nexport function isSetType(type: Type): boolean {\n    return type.kind === ReflectionKind.class && type.classType === Set;\n}\n\nexport function isMapType(type: Type): boolean {\n    return type.kind === ReflectionKind.class && type.classType === Map;\n}\n\n/**\n * Get the key type of a Map or object literal with index signatures.\n */\nexport function getKeyType(type: Type): Type {\n    if (type.kind === ReflectionKind.class && type.classType === Map && type.typeArguments) return type.typeArguments[0] || { kind: ReflectionKind.any };\n    if (type.kind === ReflectionKind.objectLiteral) {\n        const type: TypeUnion = { kind: ReflectionKind.union, types: [] };\n        for (const t of type.types) {\n            if (t.kind === ReflectionKind.indexSignature) type.types.push(t.index);\n        }\n        if (type.types.length === 1) return type.types[0];\n        if (type.types.length === 0) return { kind: ReflectionKind.any };\n        return type;\n    }\n    return { kind: ReflectionKind.any };\n}\n\n/**\n * Get the value type of a Map or object literal with index signatures.\n */\nexport function getValueType(type: Type): Type {\n    if (type.kind === ReflectionKind.class && type.classType === Map && type.typeArguments) return type.typeArguments[1] || { kind: ReflectionKind.any };\n    if (type.kind === ReflectionKind.objectLiteral) {\n        const type: TypeUnion = { kind: ReflectionKind.union, types: [] };\n        for (const t of type.types) {\n            if (t.kind === ReflectionKind.indexSignature) type.types.push(t.type);\n        }\n        if (type.types.length === 1) return type.types[0];\n        if (type.types.length === 0) return { kind: ReflectionKind.any };\n        return type;\n    }\n    return { kind: ReflectionKind.any };\n}\n\n\nexport interface EmbeddedOptions {\n    prefix?: string;\n}\n\nexport const embeddedAnnotation = new AnnotationDefinition<EmbeddedOptions>('embedded');\n\nexport function hasEmbedded(type: Type): boolean {\n    if (type.kind === ReflectionKind.propertySignature || type.kind === ReflectionKind.property) return hasEmbedded(type.type);\n    if (type.kind === ReflectionKind.union) return type.types.some(hasEmbedded);\n    return embeddedAnnotation.getFirst(type) !== undefined;\n}\n\n//`never` is here to allow using a decorator multiple times on the same type without letting the TS complaining about incompatible types.\n\n/**\n * Assigns one or multiple groups to a type.\n *\n * @example\n * ```typescript\n * interface User {\n *     username: string;\n *     password: string & Group<'credentials'>;\n * }\n * ```\n */\nexport type Group<Name extends string> = TypeAnnotation<'group', Name>;\n\n/**\n * Excludes the type from serialization of all kind.\n *\n * @example\n * ```typescript\n * interface User {\n *    username: string;\n *    password: string & Excluded;\n *  }\n *  ```\n */\nexport type Excluded<Name extends string = '*'> = TypeAnnotation<'excluded', Name>;\n\n/**\n * Assigns arbitrary data to a type that can be read in runtime.\n *\n * @example\n * ```typescript\n * interface User {\n *   username: string;\n *   password: string & Data<'role', 'admin'>;\n * }\n * ```\n */\nexport type Data<Name extends string, Value> = { __meta?: never & ['data', Name, Value] };\n\n/**\n * Resets an already set decorator to undefined.\n *\n * The required Name is the name of the type decorator (its first tuple entry).\n *\n * ```typescript\n * type Password = string & MinLength<6> & Excluded;\n *\n * interface UserCreationPayload {\n *     password: Password & ResetAnnotation<'excluded'>\n * }\n * ```\n */\nexport type ResetAnnotation<Name extends string> = TypeAnnotation<'reset', Name>;\n\nexport type IndexOptions = {\n    name?: string;\n    //index size. Necessary for blob/longtext, etc.\n    size?: number,\n\n    unique?: boolean,\n    spatial?: boolean,\n    sparse?: boolean,\n\n    //only in mongodb\n    fulltext?: boolean,\n    where?: string,\n\n    expireAfterSeconds?: number,\n};\n\nexport type Unique<Options extends IndexOptions = {}> = TypeAnnotation<'index', Options & { unique: true }>;\nexport type Index<Options extends IndexOptions = {}> = TypeAnnotation<'index', Options>;\n\nexport interface DatabaseFieldOptions {\n    /**\n     * The name of the column in the database.\n     * e.g. `userName: string & DatabaseField<{name: 'user_name'}>`\n     *\n     * Can alternatively also be configured by using a different NamingStrategy.\n     */\n    name?: string;\n\n    /**\n     *\n     * e.g. `field: string & MySQL<{type: 'VARCHAR(255)'}>`\n     */\n    type?: string;\n\n    /**\n     * If the property is on a class, its initializer/default value is per default used.\n     * This can be overridden using this option.\n     * e.g. `field: string & MySQL<{default: 'abc'}>`\n     */\n    default?: any;\n\n    /**\n     * e.g. `field: string & MySQL<{defaultExpr: 'NOW()'}>`\n     */\n    defaultExpr?: any;\n\n    /**\n     * If true no default column value is inferred from the property initializer/default value.\n     * e.g. `field: string & MySQL<{noDefault: true}> = ''`\n     */\n    noDefault?: true;\n\n    /**\n     * Skip this property in all queries and database migration files.\n     */\n    skip?: true;\n\n    /**\n     * Skip this property in database migration files. This excludes the property from the database, but\n     * keeps it in the queries.\n     */\n    skipMigration?: true;\n}\n\nexport interface MySQLOptions extends DatabaseFieldOptions {\n}\n\nexport interface PostgresOptions extends DatabaseFieldOptions {\n}\n\nexport interface SqliteOptions extends DatabaseFieldOptions {\n}\n\ntype Database<Name extends string, Options extends { [name: string]: any }> = { __meta?: never & ['database', Name, Options] };\nexport type MySQL<Options extends MySQLOptions> = Database<'mysql', Options>;\nexport type Postgres<Options extends PostgresOptions> = Database<'postgres', Options>;\nexport type SQLite<Options extends SqliteOptions> = Database<'sqlite', Options>;\nexport type DatabaseField<Options extends DatabaseFieldOptions, Name extends string = '*'> = Database<Name, Options>;\n\nexport const enum BinaryBigIntType {\n    unsigned,\n    signed\n}\n\nexport const binaryBigIntAnnotation = new AnnotationDefinition<BinaryBigIntType>('binaryBigInt');\nexport const groupAnnotation = new AnnotationDefinition<string>('group');\nexport const excludedAnnotation = new class extends AnnotationDefinition<string> {\n    isExcluded(type: Type, name: string): boolean {\n        const excluded = this.getAnnotations(type);\n        return excluded.includes('*') || excluded.includes(name);\n    }\n}('excluded');\nexport const dataAnnotation = new class extends AnnotationDefinition<{ [name: string]: any }> {\n    set<T extends Type>(type: T, key: string, value: any): T {\n        const data = this.getFirst(type) || {};\n        data[key] = value;\n        this.replaceType(type, [data]);\n        return type;\n    }\n\n    get(type: Type, key: string): any {\n        const data = this.getFirst(type) || {};\n        return data[key];\n    }\n}('data');\nexport const metaAnnotation = new class extends AnnotationDefinition<{ name: string, options: Type[] }> {\n    getForName(type: Type, metaName: string): Type[] | undefined {\n        for (const v of this.getAnnotations(type)) {\n            if (v.name === metaName) return v.options;\n        }\n        return;\n    }\n}('meta');\nexport const indexAnnotation = new AnnotationDefinition<IndexOptions>('index');\nexport const databaseAnnotation = new class extends AnnotationDefinition<{ name: string, options: { [name: string]: any } }> {\n    getDatabase<T extends DatabaseFieldOptions>(type: Type, name: string): T | undefined {\n        let options: T | undefined = undefined;\n        for (const annotation of this.getAnnotations(type)) {\n            if (annotation.name === '*' || annotation.name === name) {\n                if (!options) options = {} as T;\n                Object.assign(options, annotation.options as T);\n            }\n        }\n        return options as any;\n    };\n}('database');\n\nexport function registerTypeDecorator(decorator: TypeDecorator) {\n    typeDecorators.push(decorator);\n}\n\n/**\n * Type annotations are object literals with a single optional __meta in it\n * that has as type a tuple with the name of the annotation as first entry.\n * The tuple is intersected with the `never` type to make sure it does not\n * interfere with type checking.\n *\n * The processor has currently implemented to not resolve `never & x` to `never`,\n * so we still have the intersection type in runtime to resolve __meta correctly.\n *\n * ```typescript\n * type MyAnnotation1 = TypeAnnotation<'myAnnotation'>\n * type MyAnnotation1<T> = TypeAnnotation<'myAnnotation', T>\n *\n * //under the hood it is:\n * type lowLevel1 = { __meta?: never & ['myAnnotation'] }\n * type lowLevel2<T> = { __meta?: never & ['myAnnotation', T] }\n * ```\n */\nexport function getAnnotationMeta(type: TypeObjectLiteral): { id: string, params: Type[] } | undefined {\n    const meta = getProperty(type, '__meta');\n    if (!meta || !meta.optional) return;\n    let tuple: TypeTuple | undefined = undefined;\n\n    if (meta.type.kind === ReflectionKind.intersection) {\n        if (meta.type.types.length === 1 && meta.type.types[0].kind === ReflectionKind.tuple) {\n            tuple = meta.type.types[0] as TypeTuple;\n        }\n        if (!tuple && meta.type.types.length === 2) {\n            tuple = meta.type.types.find(v => v.kind === ReflectionKind.tuple) as TypeTuple | undefined;\n            if (tuple && !meta.type.types.find(v => v.kind === ReflectionKind.never)) {\n                tuple = undefined;\n            }\n        }\n    } else if (meta.type.kind === ReflectionKind.tuple) {\n        tuple = meta.type;\n    }\n\n    if (!tuple) return;\n\n    const id = tuple.types[0];\n    if (!id || id.type.kind !== ReflectionKind.literal || 'string' !== typeof id.type.literal) return;\n    const params = tuple.types.slice(1).map(v => v.type);\n\n    return { id: id.type.literal, params };\n}\n\nexport const typeDecorators: TypeDecorator[] = [\n    (annotations: Annotations, decorator: TypeObjectLiteral) => {\n        const meta = getAnnotationMeta(decorator);\n        if (!meta) return false;\n\n        switch (meta.id) {\n            case 'reference': {\n                const optionsType = meta.params[0];\n                if (!optionsType || optionsType.kind !== ReflectionKind.objectLiteral) return false;\n                const options = typeToObject(optionsType);\n                referenceAnnotation.replace(annotations, [options]);\n                return true;\n            }\n            case 'entity': {\n                const optionsType = meta.params[0];\n                if (!optionsType || optionsType.kind !== ReflectionKind.objectLiteral) return false;\n                const options = typeToObject(optionsType);\n                entityAnnotation.replace(annotations, [options]);\n                return true;\n            }\n            case 'mapName': {\n                if (!meta.params[0]) return false;\n                const name = typeToObject(meta.params[0]);\n                const serializer = meta.params[1] ? typeToObject(meta.params[1]) : undefined;\n\n                if ('string' === typeof name && (!serializer || 'string' === typeof serializer)) {\n                    mapNameAnnotation.replace(annotations, [{ name, serializer }]);\n                }\n                return true;\n            }\n            case 'autoIncrement':\n                autoIncrementAnnotation.register(annotations, true);\n                return true;\n            case 'binaryBigInt':\n                binaryBigIntAnnotation.replace(annotations, [BinaryBigIntType.unsigned]);\n                return true;\n            case 'signedBinaryBigInt':\n                binaryBigIntAnnotation.replace(annotations, [BinaryBigIntType.signed]);\n                return true;\n            case 'primaryKey':\n                primaryKeyAnnotation.register(annotations, true);\n                return true;\n            case 'mongoId':\n                mongoIdAnnotation.register(annotations, true);\n                return true;\n            case 'UUIDv4':\n                uuidAnnotation.register(annotations, true);\n                return true;\n            case 'embedded': {\n                const optionsType = meta.params[0];\n                if (!optionsType || optionsType.kind !== ReflectionKind.objectLiteral) return false;\n                const options = typeToObject(optionsType);\n                embeddedAnnotation.replace(annotations, [options]);\n                return true;\n            }\n            case 'group': {\n                const nameType = meta.params[0];\n                if (!nameType || nameType.kind !== ReflectionKind.literal || 'string' !== typeof nameType.literal) return false;\n                groupAnnotation.register(annotations, nameType.literal);\n                return true;\n            }\n            case 'index': {\n                const optionsType = meta.params[0];\n                if (!optionsType || optionsType.kind !== ReflectionKind.objectLiteral) return false;\n                const options = typeToObject(optionsType);\n                indexAnnotation.replace(annotations, [options]);\n                return true;\n            }\n            case 'database': {\n                const nameType = meta.params[0];\n                if (!nameType || nameType.kind !== ReflectionKind.literal || 'string' !== typeof nameType.literal) return false;\n                const optionsType = meta.params[1];\n                if (!optionsType || optionsType.kind !== ReflectionKind.objectLiteral) return false;\n                const options = typeToObject(optionsType);\n                databaseAnnotation.register(annotations, { name: nameType.literal, options });\n                return true;\n            }\n            case 'excluded': {\n                const nameType = meta.params[0];\n                if (!nameType || nameType.kind !== ReflectionKind.literal || 'string' !== typeof nameType.literal) return false;\n                excludedAnnotation.register(annotations, nameType.literal);\n                return true;\n            }\n            case 'reset': {\n                const name = typeToObject(meta.params[0]);\n                if ('string' !== typeof name) return false;\n                const map: { [name: string]: AnnotationDefinition<any> } = {\n                    primaryKey: primaryKeyAnnotation,\n                    autoIncrement: autoIncrementAnnotation,\n                    excluded: excludedAnnotation,\n                    database: databaseAnnotation,\n                    index: indexAnnotation,\n                    data: dataAnnotation,\n                    group: groupAnnotation,\n                    embedded: excludedAnnotation,\n                    mapName: mapNameAnnotation,\n                    reference: referenceAnnotation,\n                    backReference: backReferenceAnnotation,\n                    validator: validationAnnotation,\n                };\n                const annotation = map[name] || metaAnnotation;\n                annotation.reset(annotations);\n                return true;\n            }\n            case 'data': {\n                const nameType = meta.params[0];\n                if (!nameType || nameType.kind !== ReflectionKind.literal || 'string' !== typeof nameType.literal) return false;\n                const dataType = meta.params[1];\n                if (!dataType) return false;\n\n                annotations[dataAnnotation.symbol] ||= [];\n                let data: { [name: string]: any } = {};\n                if (annotations[dataAnnotation.symbol].length) {\n                    data = annotations[dataAnnotation.symbol][0];\n                } else {\n                    annotations[dataAnnotation.symbol].push(data);\n                }\n\n                data[nameType.literal] = dataType.kind === ReflectionKind.literal ? dataType.literal : dataType;\n\n                return true;\n            }\n            case 'backReference': {\n                const optionsType = meta.params[0];\n                if (!optionsType || optionsType.kind !== ReflectionKind.objectLiteral) return false;\n\n                const options = typeToObject(optionsType);\n                const member = findMember('via', resolveTypeMembers(optionsType));\n                backReferenceAnnotation.register(annotations, {\n                    mappedBy: options.mappedBy,\n                    via: member && member.kind === ReflectionKind.propertySignature && (member.type.kind === ReflectionKind.objectLiteral || member.type.kind === ReflectionKind.class) ? member.type : undefined,\n                });\n                return true;\n            }\n            case 'validator': {\n                const nameType = meta.params[0];\n                if (!nameType || nameType.kind !== ReflectionKind.literal || 'string' !== typeof nameType.literal) return false;\n                const name = nameType.literal;\n\n                const argsType = meta.params[1];\n                if (!argsType || argsType.kind !== ReflectionKind.tuple) return false;\n                const args: Type[] = argsType.types.map(v => v.type);\n\n                const options: AnnotationType<typeof validationAnnotation> = { name, args };\n                validationAnnotation.register(annotations, options);\n                return true;\n            }\n            default: {\n                metaAnnotation.register(annotations, { name: meta.id, options: meta.params });\n                return true;\n            }\n        }\n    }\n];\n\nexport function typeToObject(type?: Type, state: { stack: Type[] } = { stack: [] }): any {\n    if (!type) return;\n\n    if (state.stack.includes(type)) return undefined;\n    state.stack.push(type);\n\n    try {\n        switch (type.kind) {\n            case ReflectionKind.any:\n            case ReflectionKind.void:\n            case ReflectionKind.never:\n            case ReflectionKind.undefined:\n                return undefined;\n            case ReflectionKind.null:\n                return null;\n            case ReflectionKind.string:\n                return '';\n            case ReflectionKind.number:\n                return 0;\n            case ReflectionKind.bigint:\n                return BigInt(0);\n            case ReflectionKind.regexp:\n                return; //;\n            case ReflectionKind.boolean:\n                return true;\n            case ReflectionKind.literal:\n                return type.literal;\n            case ReflectionKind.promise:\n                return typeToObject(type.type);\n            case ReflectionKind.templateLiteral:\n                return '';\n            case ReflectionKind.class: {\n                return type.classType;\n            }\n            case ReflectionKind.objectLiteral: {\n                const res: { [name: string | number | symbol]: any } = {};\n                for (const t of type.types) {\n                    if (t.kind === ReflectionKind.propertySignature) {\n                        res[String(t.name)] = typeToObject(t.type);\n                    } else if (t.kind === ReflectionKind.methodSignature) {\n                    }\n                }\n                return res;\n            }\n            case ReflectionKind.union:\n            case ReflectionKind.intersection:\n                return typeToObject(type.types[0]);\n            case ReflectionKind.function:\n                return type.function;\n            case ReflectionKind.array:\n                return [typeToObject(type.type)];\n            case ReflectionKind.tuple:\n                return type.types.map(v => typeToObject(v.type, state));\n        }\n\n        return undefined;\n    } finally {\n        state.stack.pop();\n    }\n}\n\nexport function memberNameToString(name: number | string | symbol): string {\n    if (isType(name)) {\n        return stringifyResolvedType(name);\n    }\n    return String(name);\n}\n\nexport const binaryTypes: ClassType[] = [\n    Int8Array,\n    Uint8Array,\n    Uint8ClampedArray,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array,\n    ArrayBuffer,\n];\n\n/**\n * Returns true if the given type is Date, ArrayBuffer, Uint8Array, etc.\n */\nexport function isGlobalTypeClass(type: Type): type is TypeClass {\n    if (type.kind !== ReflectionKind.class) return false;\n    return isGlobalClass(type.classType);\n}\n\n/**\n * Returns true if the given type is TypeClass and references a custom (non-global) class.\n */\nexport function isCustomTypeClass(type: Type): type is TypeClass {\n    return type.kind === ReflectionKind.class && !isGlobalTypeClass(type);\n}\n\n/**\n * Returns a type predicate that checks if the given type is a class and is of the given classType.\n * If withInheritance is true, it also checks if the type is a subclass of the given classType.\n */\nexport function isTypeClassOf(classType: ClassType, withInheritance: boolean = true): (type: Type) => boolean {\n    if (!withInheritance) return (type: Type) => type.kind === ReflectionKind.class && type.classType === classType;\n\n    return (type: Type) => {\n        if (type.kind !== ReflectionKind.class) return false;\n        const chain = getInheritanceChain(type.classType);\n        return chain.includes(classType);\n    };\n}\n\n/**\n * Returns the members of a class or object literal.\n */\nexport function resolveTypeMembers(type: TypeClass | TypeObjectLiteral): (TypeProperty | TypePropertySignature | TypeMethodSignature | TypeMethod | TypeIndexSignature | TypeCallSignature)[] {\n    return type.types;\n}\n\nexport function stringifyResolvedType(type: Type): string {\n    return stringifyType(type, { showNames: false, showFullDefinition: true });\n}\n\nexport function stringifyShortResolvedType(type: Type, stateIn: Partial<StringifyTypeOptions> = {}): string {\n    return stringifyType(type, { ...stateIn, showNames: false, showFullDefinition: false, });\n}\n\n/**\n * Returns all (including inherited) constructor properties of a class.\n */\nexport function getDeepConstructorProperties(type: TypeClass): TypeParameter[] {\n    const chain = getInheritanceChain(type.classType);\n    const res: TypeParameter[] = [];\n    for (const classType of chain) {\n        const type = resolveReceiveType(classType) as TypeClass;\n        if (type.kind !== ReflectionKind.class) continue;\n        const constructor = findMember('constructor', type.types);\n        if (!constructor || constructor.kind !== ReflectionKind.method) continue;\n        for (const param of constructor.parameters) {\n            if (param.kind !== ReflectionKind.parameter) continue;\n            if (param.readonly === true || param.visibility !== undefined) {\n                res.push(param);\n            }\n        }\n    }\n    return res;\n}\n\n/**\n * Returns the index to `type.values` if the given value is part of the enum, exactly or case-insensitive.\n * Returns -1 if not found.\n */\nexport function getEnumValueIndexMatcher(type: TypeEnum): (value: string | number | undefined | null) => number {\n    const lowerCaseValues = Object.keys(type.enum).map(v => String(v).toLowerCase());\n    return (value): number => {\n        const exactMatch = type.values.indexOf(value);\n        if (exactMatch !== -1) return exactMatch;\n        const lowerCaseMatch = lowerCaseValues.indexOf(String(value).toLowerCase());\n        if (lowerCaseMatch !== -1) return lowerCaseMatch;\n\n        return -1;\n    };\n}\n\ninterface StringifyTypeOptions {\n    //show type alias names\n    showNames: boolean;\n    showFullDefinition: boolean;\n    showDescription: boolean;\n    defaultIsOptional: boolean;\n    showHeritage: boolean;\n    showDefaults: boolean;\n    defaultValues: any;\n    stringify?: (type: Type) => string | undefined;\n}\n\nlet stringifyTypeId: number = 1;\n\nexport function stringifyType(type: Type, stateIn: Partial<StringifyTypeOptions> = {}): string {\n    const state: StringifyTypeOptions = {\n        showNames: true,\n        defaultIsOptional: false,\n        showDefaults: false,\n        defaultValues: undefined,\n        showDescription: false,\n        showHeritage: false,\n        showFullDefinition: false,\n        ...stateIn\n    };\n    const stack: { type?: Type, defaultValue?: any, before?: string, after?: string, depth?: number }[] = [];\n    stack.push({ type, defaultValue: state.defaultValues, depth: 1 });\n    const stackId: number = stringifyTypeId++;\n    const result: string[] = [];\n\n    while (stack.length) {\n        const entry = stack.pop();\n        if (!entry) break;\n        const type = entry.type;\n\n        const depth = entry.depth || 1;\n        if (type && stateIn.stringify) {\n            const manual = stateIn.stringify(type);\n            if ('string' === typeof manual) {\n                if (manual !== '') {\n                    if (entry.before) {\n                        result.push(entry.before);\n                    }\n                    result.push(manual);\n                    if (entry.after) {\n                        result.push(entry.after);\n                    }\n                }\n                continue;\n            }\n        }\n\n        if (entry.before) {\n            result.push(entry.before);\n        }\n\n        if (type) {\n            const jit = getTypeJitContainer(type);\n            if (entry.depth !== undefined && jit.visitStack && jit.visitStack.id === stackId && jit.visitStack.depth < entry.depth) {\n                result.push((type.typeName ? type.typeName : '* Recursion *'));\n                continue;\n            }\n\n            // objectLiteral and class types usually get their own reference, but their types are shared.\n            // thus we have to check for their member types identity to check for recursions.\n            if (type.kind === ReflectionKind.objectLiteral || type.kind === ReflectionKind.class) {\n                const first = type.types[0];\n                const jit = first ? getTypeJitContainer(first) : undefined;\n                if (jit && entry.depth !== undefined && jit.visitStack && jit.visitStack.id === stackId && jit.visitStack.depth < entry.depth + 1) {\n                    result.push((type.typeName ? type.typeName : '* Recursion *'));\n                    continue;\n                }\n            }\n\n            jit.visitStack = { id: stackId, depth };\n\n            const manual = stateIn.stringify ? stateIn.stringify(type) : undefined;\n            if ('string' === typeof manual) {\n                result.push(jit.stringifyTypeResult = manual);\n                continue;\n            }\n\n            if (state.showNames && type.typeName && !state.showFullDefinition) {\n                if (type.typeArguments && type.typeArguments.length) {\n                    stack.push({ before: '>' });\n                    for (let i = type.typeArguments.length - 1; i >= 0; i--) {\n                        stack.push({ type: type.typeArguments[i], before: i === 0 ? undefined : ', ', depth });\n                    }\n                    stack.push({ before: '<' });\n                }\n                result.push(type.typeName);\n                continue;\n            }\n\n            switch (type.kind) {\n                case ReflectionKind.never:\n                    result.push(`never`);\n                    break;\n                case ReflectionKind.any:\n                    result.push(`any`);\n                    break;\n                case ReflectionKind.unknown:\n                    result.push(`unknown`);\n                    break;\n                case ReflectionKind.void:\n                    result.push(`void`);\n                    break;\n                case ReflectionKind.undefined:\n                    result.push(`undefined`);\n                    break;\n                case ReflectionKind.null:\n                    result.push(`null`);\n                    break;\n                case ReflectionKind.object:\n                    result.push(`object`);\n                    break;\n                case ReflectionKind.string:\n                    result.push('string');\n                    break;\n                case ReflectionKind.infer:\n                    result.push('infer');\n                    break;\n                case ReflectionKind.number:\n                    result.push('number');\n                    break;\n                case ReflectionKind.bigint:\n                    result.push('bigint');\n                    break;\n                case ReflectionKind.regexp:\n                    result.push('RegExp');\n                    break;\n                case ReflectionKind.boolean:\n                    result.push('boolean');\n                    break;\n                case ReflectionKind.symbol:\n                    result.push('symbol');\n                    break;\n                case ReflectionKind.literal:\n                    if ('number' === typeof type.literal) {\n                        result.push(type.literal + '');\n                    } else if ('boolean' === typeof type.literal) {\n                        result.push(type.literal + '');\n                    } else {\n                        result.push(`'${String(type.literal).replace(/'/g, '\\\\\\'')}'`);\n                    }\n                    break;\n                case ReflectionKind.promise:\n                    result.push('Promise<');\n                    stack.push({ before: '>' });\n                    stack.push({ type: type.type, depth: depth + 1 });\n                    break;\n                case ReflectionKind.templateLiteral:\n                    stack.push({ before: '`' });\n                    for (let i = type.types.length - 1; i >= 0; i--) {\n                        const sub = type.types[i];\n                        if (sub.kind === ReflectionKind.literal) {\n                            stack.push({ before: String(sub.literal) });\n                        } else {\n                            stack.push({ type: sub, before: '${', after: '}', depth: depth + 1 });\n                        }\n                    }\n                    stack.push({ before: '`' });\n                    break;\n                case ReflectionKind.class: {\n                    if (type.classType === Date) {\n                        result.push(`Date`);\n                        break;\n                    }\n                    if (type.classType === Set) {\n                        result.push('Set<');\n                        stack.push({ before: '>' });\n                        stack.push({ type: type.arguments![0], depth: depth + 1 });\n                        break;\n                    }\n                    if (type.classType === Map) {\n                        result.push('Map<');\n                        stack.push({ before: '>' });\n                        stack.push({ type: type.arguments![1], depth: depth + 1 });\n                        stack.push({ before: ', ' });\n                        stack.push({ type: type.arguments![0], depth: depth + 1 });\n                        break;\n                    }\n                    if (binaryTypes.includes(type.classType)) {\n                        result.push(getClassName(type.classType));\n                        break;\n                    }\n\n                    const typeName = type.typeName || getClassName(type.classType);\n                    const superClass = getParentClass(type.classType);\n\n                    if (state.showFullDefinition) {\n                        const types = state.showHeritage ? type.types : resolveTypeMembers(type);\n                        stack.push({ before: '}' });\n                        for (let i = types.length - 1; i >= 0; i--) {\n                            const sub = types[i];\n                            const showDescription = stateIn.showDescription && sub.kind === ReflectionKind.property && sub.description;\n                            const withIndentation = types.length > 1 || showDescription;\n\n                            if (withIndentation && i === types.length - 1) {\n                                stack.push({ before: '\\n' + (' '.repeat((depth - 1) * 2)) });\n                            }\n                            if (state.stringify) {\n                                const manual = state.stringify(sub);\n                                if ('string' === typeof manual) {\n                                    if (manual !== '') {\n                                        stack.push({ before: manual });\n                                    }\n                                    continue;\n                                }\n                            }\n                            if (showDescription || (types.length > 1 && (withIndentation || i !== types.length - 1))) {\n                                stack.push({ before: withIndentation ? ';' : '; ' });\n                            }\n                            const defaultValue = entry.defaultValue && (sub.kind === ReflectionKind.property) ? entry.defaultValue[sub.name] : undefined;\n                            const showDefault = sub.kind === ReflectionKind.property && sub.type.kind !== ReflectionKind.class && sub.type.kind !== ReflectionKind.objectLiteral;\n                            if (state.showDefaults && showDefault) {\n                                if (defaultValue !== undefined) {\n                                    stack.push({ before: ' = ' + JSON.stringify(defaultValue) });\n                                } else if (sub.kind === ReflectionKind.property && sub.default) {\n                                    try {\n                                        stack.push({ before: ' = ' + JSON.stringify(sub.default()) });\n                                    } catch {\n                                    }\n                                }\n                            }\n                            stack.push({ type: sub, defaultValue, depth: depth + 1 });\n                            if (withIndentation) {\n                                stack.push({ before: '\\n' + (' '.repeat(depth * 2)) });\n                            }\n                            if (showDescription) {\n                                const indentation = indent(depth * 2, ' * ');\n                                stack.push({ before: '\\n' + indentation('/* ' + sub.description + ' */') });\n                            }\n                        }\n\n                        stack.push({ before: ' {' });\n                    }\n\n                    if (superClass && state.showHeritage) {\n                        try {\n                            const superClassType = reflect(superClass);\n                            if (superClassType.kind === ReflectionKind.class) {\n\n                                if (type.extendsArguments && type.extendsArguments.length) {\n                                    stack.push({ before: '>' });\n                                    for (let i = type.extendsArguments.length - 1; i >= 0; i--) {\n                                        stack.push({ type: type.extendsArguments[i], before: i === 0 ? undefined : ', ', depth: depth + 1 });\n                                    }\n                                    stack.push({ before: '<' });\n                                }\n\n                                stack.push({ before: ' extends ' + (superClassType.typeName || superClass.name) });\n                            }\n                        } catch {\n                            stack.push({ before: ' extends ' + (superClass.name) });\n                        }\n                    }\n\n                    const typeArguments = type.arguments || type.typeArguments;\n                    if ((!state.showFullDefinition || type.types.length === 0) && typeArguments && typeArguments.length) {\n                        stack.push({ before: '>' });\n                        for (let i = typeArguments.length - 1; i >= 0; i--) {\n                            stack.push({ type: typeArguments[i], before: i === 0 ? undefined : ', ', depth: depth + 1 });\n                        }\n                        stack.push({ before: '<' });\n                    }\n\n                    stack.push({ before: typeName });\n                    break;\n                }\n                case ReflectionKind.objectLiteral: {\n                    const typeName = type.typeName || '';\n                    result.push(typeName);\n\n                    if (!typeName || state.showFullDefinition) {\n                        result.push(typeName ? ' {' : '{');\n\n                        stack.push({ before: '}' });\n                        for (let i = type.types.length - 1; i >= 0; i--) {\n                            const sub = type.types[i];\n                            const showDescription = stateIn.showDescription && sub.kind === ReflectionKind.propertySignature && sub.description;\n                            const withIndentation = type.types.length > 1 || showDescription;\n\n                            if (state.stringify) {\n                                const manual = state.stringify(sub);\n                                if ('string' === typeof manual) {\n                                    if (manual !== '') {\n                                        stack.push({ before: manual });\n                                    }\n                                    continue;\n                                }\n                            }\n\n                            if (withIndentation && i === type.types.length - 1) {\n                                stack.push({ before: '\\n' + (' '.repeat((depth - 1) * 2)) });\n                            }\n                            if (state.stringify) {\n                                const manual = state.stringify(sub);\n                                if ('string' === typeof manual) {\n                                    if (manual !== '') {\n                                        stack.push({ before: manual });\n                                    }\n                                    continue;\n                                }\n                            }\n                            if (showDescription || (type.types.length > 1 && (withIndentation || i !== type.types.length - 1))) {\n                                stack.push({ before: withIndentation ? ';' : '; ' });\n                            }\n\n                            const defaultValue = entry.defaultValue && (sub.kind === ReflectionKind.propertySignature) ? entry.defaultValue[sub.name] : undefined;\n                            const showDefault = sub.kind === ReflectionKind.propertySignature && sub.type.kind !== ReflectionKind.class && sub.type.kind !== ReflectionKind.objectLiteral;\n                            if (state.showDefaults && showDefault) {\n                                if (defaultValue !== undefined) {\n                                    stack.push({ before: ' = ' + JSON.stringify(defaultValue) });\n                                }\n                            }\n                            stack.push({ type: sub, defaultValue, depth: depth + 1 });\n\n                            if (withIndentation) {\n                                stack.push({ before: '\\n' + (' '.repeat(depth * 2)) });\n                            }\n                            if (showDescription) {\n                                const indentation = indent(depth * 2, ' * ');\n                                stack.push({ before: '\\n' + indentation('/* ' + sub.description + ' */') });\n                            }\n                        }\n                    }\n                    break;\n                }\n                case ReflectionKind.union:\n                    for (let i = type.types.length - 1; i >= 0; i--) {\n                        stack.push({ type: type.types[i], before: i === 0 ? undefined : ' | ', depth: depth + 1 });\n                    }\n                    break;\n                case ReflectionKind.intersection:\n                    for (let i = type.types.length - 1; i >= 0; i--) {\n                        stack.push({ type: type.types[i], before: i === 0 ? undefined : ' & ', depth: depth + 1 });\n                    }\n                    break;\n                case ReflectionKind.parameter: {\n                    const visibility = type.visibility ? ReflectionVisibility[type.visibility] + ' ' : '';\n                    const dotdotdot = type.type.kind === ReflectionKind.rest ? '...' : '';\n                    result.push(`${type.readonly ? 'readonly ' : ''}${visibility}${dotdotdot}${type.name}${type.optional ? '?' : ''}: `);\n                    stack.push({ type: type.type, depth: depth + 1 });\n                    break;\n                }\n                case ReflectionKind.callSignature:\n                case ReflectionKind.function:\n                    stack.push({ type: type.return, depth: depth + 1 });\n                    stack.push({ before: ') => ' });\n                    for (let i = type.parameters.length - 1; i >= 0; i--) {\n                        stack.push({ type: type.parameters[i], before: i === 0 ? undefined : ', ', depth: depth + 1 });\n                    }\n                    stack.push({ before: '(' });\n                    break;\n                case ReflectionKind.enum:\n                    const members = Object.entries(type.enum).map(([label, value]) => `${label}: ${value}`).join(', ');\n                    stack.push({ before: `${type.typeName ? type.typeName : 'Enum'} {` + (members) + '}' });\n                    break;\n                case ReflectionKind.array:\n                    stack.push({ before: '>' });\n                    stack.push({ type: type.type, before: 'Array<', depth: depth + 1 });\n                    break;\n                case ReflectionKind.typeParameter:\n                    stack.push({ before: type.name });\n                    break;\n                case ReflectionKind.rest:\n                    stack.push({ before: '[]' });\n                    stack.push({ type: type.type, depth: depth + 1 });\n                    if (type.parent && type.parent.kind === ReflectionKind.tupleMember && !type.parent.name) {\n                        stack.push({ before: '...' });\n                    }\n                    break;\n                case ReflectionKind.tupleMember:\n                    if (type.name) {\n                        const dotdotdot = type.type.kind === ReflectionKind.rest ? '...' : '';\n                        result.push(`${dotdotdot}${type.name}${type.optional ? '?' : ''}: `);\n                        stack.push({ type: type.type, depth: depth + 1 });\n                        break;\n                    }\n                    if (type.optional) {\n                        stack.push({ before: '?' });\n                    }\n                    stack.push({ type: type.type, depth: depth + 1 });\n                    break;\n                case ReflectionKind.tuple:\n                    stack.push({ before: ']' });\n                    for (let i = type.types.length - 1; i >= 0; i--) {\n                        stack.push({ type: type.types[i], before: i === 0 ? undefined : ', ', depth: depth + 1 });\n                    }\n                    stack.push({ before: '[' });\n                    break;\n                case ReflectionKind.indexSignature:\n                    stack.push({ type: type.type, depth: depth + 1 });\n                    stack.push({ before: ']: ' });\n                    stack.push({ type: type.index, depth: depth + 1 });\n                    stack.push({ before: '[index: ' });\n                    // name = `{[index: ${stringifyType(type.index, state)}]: ${stringifyType(type.type, state)}`;\n                    break;\n                case ReflectionKind.propertySignature:\n                    result.push(`${type.readonly ? 'readonly ' : ''}${memberNameToString(type.name)}${type.optional ? '?' : ''}: `);\n                    stack.push({ type: type.type, defaultValue: entry.defaultValue, depth });\n                    break;\n                case ReflectionKind.property: {\n                    const visibility = type.visibility ? ReflectionVisibility[type.visibility] + ' ' : '';\n                    const optional = type.optional || (stateIn.defaultIsOptional && type.default !== undefined);\n                    result.push(`${type.static ? 'static ' : ''}${type.readonly ? 'readonly ' : ''}${visibility}${memberNameToString(type.name)}${optional ? '?' : ''}: `);\n                    stack.push({ type: type.type, defaultValue: entry.defaultValue, depth });\n                    break;\n                }\n                case ReflectionKind.methodSignature:\n                    stack.push({ type: type.return, depth });\n                    stack.push({ before: '): ' });\n                    for (let i = type.parameters.length - 1; i >= 0; i--) {\n                        stack.push({ type: type.parameters[i], before: i === 0 ? undefined : ', ', depth });\n                    }\n                    stack.push({ before: `${memberNameToString(type.name)}${type.optional ? '?' : ''}(` });\n                    break;\n                case ReflectionKind.method: {\n                    const visibility = type.visibility ? ReflectionVisibility[type.visibility] + ' ' : '';\n                    const abstract = type.abstract ? 'abstract ' : '';\n                    const staticPrefix = type.static ? 'static ' : '';\n                    if (type.name === 'constructor') {\n                        stack.push({ before: ')' });\n                    } else {\n                        stack.push({ type: type.return, depth });\n                        stack.push({ before: '): ' });\n                    }\n                    for (let i = type.parameters.length - 1; i >= 0; i--) {\n                        stack.push({ type: type.parameters[i], before: i === 0 ? undefined : ', ', depth });\n                    }\n                    stack.push({ before: `${staticPrefix}${abstract}${visibility}${memberNameToString(type.name)}${type.optional ? '?' : ''}(` });\n                    break;\n                }\n            }\n        }\n\n        if (entry.after) {\n            result.push(entry.after);\n        }\n    }\n\n    return result.join('');\n}\n\nexport function annotateClass<T>(clazz: ClassType | AbstractClassType, type?: ReceiveType<T>) {\n    (clazz as any).__type = isClass(type) ? (type as any).__type || [] : [];\n    type = resolveRuntimeType(type);\n    (clazz as any).__type.__type = type;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5380, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5386, "column": 0}, "map": {"version":3,"file":"debug.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/debug.ts"],"sourcesContent":["export function isDebug(level: number = 1) {\n    const expected = 'deepkit' + (level > 1 ? '+'.repeat(level - 1) : '');\n    return 'undefined' !== typeof process && 'string' === typeof process.env.DEBUG && process.env.DEBUG.includes(expected);\n}\n\n/**\n * First level debugging with DEBUG=deepkit\n */\nexport function debug(...message: any[]): void {\n    if (isDebug(1)) {\n        console.debug(...message);\n    }\n}\n\n/**\n * Second level debugging with DEBUG=deepkit+\n */\nexport function debug2(...message: any[]): void {\n    if (isDebug(2)) {\n        console.debug(...message);\n    }\n}\n"],"names":[],"mappings":";;;;;AAAM,SAAU,OAAO,CAAC,QAAgB,CAAC;IACrC,MAAM,QAAQ,GAAG,SAAS,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IACtE,OAAO,WAAW,KAAK,OAAO,OAAO,IAAI,QAAQ,KAAK,OAAO,OAAO,CAAC,GAAG,CAAC,KAAK,IAAI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AAC3H,CAAC;;;;;;;AAKK,SAAU,KAAK,CAAC,GAAG,OAAc;IACnC,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;QACb,OAAO,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC,CAAC;IAC9B,CAAC;AACL,CAAC;;;;;;AAKK,SAAU,MAAM,CAAC,GAAG,OAAc;IACpC,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;QACb,OAAO,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC,CAAC;IAC9B,CAAC;AACL,CAAC"}},
    {"offset": {"line": 5421, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5427, "column": 0}, "map": {"version":3,"file":"processor.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/reflection/processor.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport {\n    Annotations,\n    applyScheduledAnnotations,\n    CartesianProduct,\n    copyAndSetParent,\n    defaultAnnotation,\n    flattenUnionTypes,\n    getAnnotations,\n    getMember,\n    indexAccess,\n    isMember,\n    isPrimitive,\n    isSameType,\n    isType,\n    isTypeIncluded,\n    isWithAnnotations,\n    merge,\n    narrowOriginalLiteral,\n    ReflectionKind,\n    ReflectionVisibility,\n    stringifyType,\n    Type,\n    TypeBaseMember,\n    TypeCallSignature,\n    TypeClass,\n    typeDecorators,\n    TypeEnumMember,\n    TypeFunction,\n    TypeIndexSignature,\n    TypeInfer,\n    TypeLiteral,\n    TypeMethod,\n    TypeMethodSignature,\n    TypeObjectLiteral,\n    TypeParameter,\n    TypePromise,\n    TypeProperty,\n    TypePropertySignature,\n    TypeTemplateLiteral,\n    TypeTupleMember,\n    TypeUnion,\n    unboxUnion,\n    validationAnnotation,\n    widenLiteral,\n} from './type.js';\nimport { MappedModifier, ReflectionOp } from '@deepkit/type-spec';\nimport { isExtendable } from './extends.js';\nimport { ClassType, isArray, isClass, isFunction, stringifyValueWithType } from '@deepkit/core';\nimport { isWithDeferredDecorators } from '../decorator.js';\nimport { ReflectionClass, TData } from './reflection.js';\nimport { state } from './state.js';\nimport { debug } from '../debug.js';\n\nexport type RuntimeStackEntry = Type | Object | (() => ClassType | Object) | string | number | boolean | bigint;\n\nexport type Packed = (RuntimeStackEntry | string)[] & { __is?: (data: any) => boolean } & { __type?: Type } & { __unpack?: PackStruct };\n\nexport class PackStruct {\n    constructor(\n        public ops: ReflectionOp[] = [],\n        public stack: RuntimeStackEntry[] = [],\n    ) {\n    }\n}\n\nfunction unpackOps(decodedOps: ReflectionOp[], encodedOPs: string): void {\n    for (let i = 0; i < encodedOPs.length; i++) {\n        decodedOps.push(encodedOPs.charCodeAt(i) - 33);\n    }\n}\n\nexport function encodeOps(ops: ReflectionOp[]): string {\n    return ops.map(v => String.fromCharCode(v + 33)).join('');\n}\n\n/**\n * Pack a pack structure (op instructions + pre-defined stack) and create a encoded version of it.\n */\nexport function pack(packOrOps: PackStruct | ReflectionOp[]): Packed {\n    const ops = isArray(packOrOps) ? packOrOps : packOrOps.ops;\n    const encodedOps = encodeOps(ops);\n\n    if (!isArray(packOrOps)) {\n        if (packOrOps.stack.length) {\n            return [...packOrOps.stack as RuntimeStackEntry[], encodedOps];\n        }\n    }\n\n    return [encodedOps];\n}\n\nexport function unpack(pack: Packed): PackStruct {\n    const ops: ReflectionOp[] = [];\n\n    const encodedOPs = pack[pack.length - 1];\n\n    //the end has always to be a string\n    if ('string' !== typeof encodedOPs) return { ops: [], stack: [] };\n\n    unpackOps(ops, encodedOPs);\n\n    return { ops, stack: pack.length > 1 ? pack.slice(0, -1) : [] };\n}\n\nexport function resolvePacked(type: Packed, args: any[] = [], options?: ReflectOptions): Type {\n    return resolveRuntimeType(type, args, options) as Type;\n}\n\nfunction isPack(o: any): o is Packed {\n    return isArray(o);\n}\n\n/**\n * Computes a type of given object. This function caches the result on the object itself.\n * This is the slow path, using the full type virtual machine to resolve the type.\n * If you want to handle some fast paths (including cache), try using resolveReceiveType() instead.\n */\nexport function resolveRuntimeType(o: ClassType | Function | Packed | any, args: any[] = [], options?: ReflectOptions): Type {\n    const type = Processor.get().reflect(o, args, options || { reuseCached: true });\n\n    if (isType(type)) {\n        return type as Type;\n    }\n\n    throw new Error('No type returned from runtime type program');\n}\n\ninterface Frame {\n    index: number; //just the general frame index\n    startIndex: number; //when the frame started, index of the stack\n    variables: number;\n    inputs: RuntimeStackEntry[];\n    previous?: Frame;\n    mappedType?: Loop;\n    distributiveLoop?: Loop;\n}\n\nclass Loop {\n    private types: Type[] = [];\n    private i: number = 0;\n\n    constructor(public fromType: Type) {\n        if (fromType.kind === ReflectionKind.union) {\n            this.types = fromType.types;\n        } else {\n            this.types = [fromType];\n        }\n    }\n\n    next(): Type | undefined {\n        return this.types[this.i++];\n    }\n}\n\ninterface Program {\n    frame: Frame;\n    active: boolean;\n    stack: (RuntimeStackEntry | Type)[];\n    stackPointer: number; //pointer to the stack\n    program: number; //pointer to the current op\n    depth: number;\n    initialStack: (RuntimeStackEntry | Type)[];\n    resultType: Type;\n    ops: ReflectionOp[];\n    end: number;\n    inputs: RuntimeStackEntry[];\n    resultTypes?: Type[];\n    started: number;\n    typeParameters?: Type[];\n    previous?: Program;\n    //don't operate on newly created ref resultType but return whatever is on the stack directly\n    //used in inline-only programs like `typeOf<MyAlias>()` where we want the type of (cached) MyAlias and not a new reference.\n    directReturn?: boolean;\n    object?: ClassType | Function | Packed | any;\n}\n\nfunction assignResult<T extends Type>(ref: Type, result: T, assignParents: boolean): T {\n    Object.assign(ref, result);\n\n    if (assignParents) {\n        // if (ref.kind === ReflectionKind.class && ref.arguments) {\n        //     for (const member of ref.arguments) member.parent = ref;\n        // }\n\n        if (ref.kind === ReflectionKind.function || ref.kind === ReflectionKind.method || ref.kind === ReflectionKind.methodSignature) {\n            ref.return.parent = ref;\n            for (const member of ref.parameters) member.parent = ref as any;\n        }\n\n        if ('types' in ref) {\n            for (const member of ref.types) {\n                member.parent = ref;\n            }\n        }\n    }\n\n    return ref as T;\n}\n\nfunction isConditionTruthy(condition: Type | number): boolean {\n    if ('number' === typeof condition) return condition !== 0;\n    return !!(condition.kind === ReflectionKind.literal && condition.literal);\n}\n\nfunction createProgram(options: Partial<Program>, inputs?: RuntimeStackEntry[]): Program {\n    const program: Program = {\n        active: true,\n        frame: { index: 0, startIndex: -1, inputs: inputs || [], variables: 0, previous: undefined },\n        stack: options.stack || [],\n        stackPointer: options.stackPointer ?? -1,\n        program: 0,\n        depth: 0,\n        initialStack: options.initialStack || [],\n        resultType: options.resultType || { kind: ReflectionKind.unknown },\n        ops: options.ops || [],\n        end: options.end ?? (options.ops ? options.ops.length : 0),\n        inputs: inputs || [],\n        started: Date.now(),\n        // resultTypes: [],\n        // typeParameters: [],\n        // previous: undefined,\n        object: options.object,\n    };\n\n    if (options.initialStack) for (let i = 0; i < options.initialStack.length; i++) {\n        if (i < program.stack.length) {\n            program.stack[i] = options.initialStack[i];\n        } else {\n            program.stack.push(options.initialStack[i]);\n        }\n    }\n\n    program.stackPointer = options.initialStack ? options.initialStack.length - 1 : -1;\n    program.frame.startIndex = program.stackPointer;\n\n    return program;\n}\n\nfunction isValidCacheEntry(current: Program, object: ClassType | Function | Packed | any, inputs: RuntimeStackEntry[] = []): Program | undefined {\n    if (current.object === object) {\n        //issue a new reference if inputs are the same\n        //todo: when a function has a default, this is not set in current.inputs, and could fail when it differs to given inputs\n        let sameInputs = current.inputs.length === inputs.length;\n        if (sameInputs) {\n            for (let i = 0; i < current.inputs.length; i++) {\n                if (!inputs[i] || !isSameType(current.inputs[i] as Type, inputs[i] as Type)) {\n                    sameInputs = false;\n                    break;\n                }\n            }\n            if (sameInputs) {\n                return current;\n            }\n        }\n    }\n    return;\n}\n\nfunction findExistingProgram(current: Program | undefined, object: ClassType | Function | Packed | any, inputs: RuntimeStackEntry[] = []) {\n    let checks = 0;\n    while (current) {\n        if (current.object === object) {\n            checks++;\n            //as safety check to never go into an endless loop, we return just this program if objects matches and we are 1000 programs deep.\n            if (checks > 1000) return current;\n\n            //issue a new reference if inputs are the same\n            //todo: when a function has a default, this is not set in current.inputs, and could fail when it differs to given inputs\n            let sameInputs = current.inputs.length === inputs.length;\n            if (sameInputs) {\n                for (let i = 0; i < current.inputs.length; i++) {\n                    if (!inputs[i] || !isSameType(current.inputs[i] as Type, inputs[i] as Type)) {\n                        sameInputs = false;\n                        break;\n                    }\n                }\n                if (sameInputs) return current;\n            }\n        }\n\n        current = current.previous;\n    }\n\n    return;\n}\n\nfunction createRef(current: Program): Type {\n    if (!current.resultTypes) current.resultTypes = [];\n    const ref: Type = { ...current.resultType };\n    current.resultTypes.push(ref);\n    return ref;\n}\n\nexport interface ReflectOptions {\n    /**\n     *\n     */\n    reuseCached?: boolean;\n\n    inline?: boolean;\n\n    typeName?: string;\n}\n\n/**\n * @reflection never\n */\nexport class Processor {\n    static typeProcessor?: Processor;\n\n    static get(): Processor {\n        return Processor.typeProcessor ||= new Processor();\n    }\n\n    private cache: Program[] = [];\n\n    /**\n     * Linked list of programs to execute. For each external call to external program will this be changed.\n     */\n    protected program: Program = {\n        active: false,\n        frame: { index: 0, startIndex: -1, inputs: [], variables: 0 },\n        stack: [],\n        stackPointer: -1,\n        program: 0,\n        depth: 0,\n        initialStack: [],\n        resultType: { kind: ReflectionKind.unknown },\n        // resultTypes: [],\n        inputs: [],\n        end: 0,\n        ops: [],\n        started: 0,\n        // previous: undefined,\n        // object: undefined,\n    };\n\n    reflect(object: ClassType | Function | Packed | any, inputs: RuntimeStackEntry[] = [], options: ReflectOptions = {}): Type {\n        const start = Date.now();\n        const result = this._reflect(object, inputs, options);\n\n        const took = Date.now() - start;\n        if (took > 100) {\n            console.warn(`Type computation took very long ${took}ms for ${stringifyType(result)}`);\n        }\n        return result;\n    }\n\n    _reflect(object: ClassType | Function | Packed | any, inputs: RuntimeStackEntry[] = [], options: ReflectOptions = {}): Type {\n        const packed: Packed | undefined = isPack(object) ? object : object.__type;\n        if (!packed) {\n            if (isFunction(object) && object.length === 0) {\n                //functions without any type annotations do not have the overhead of an assigned __type\n                return {\n                    kind: ReflectionKind.function,\n                    function: object, name: object.name,\n                    parameters: [], return: { kind: ReflectionKind.any },\n                };\n            }\n            throw new Error(`No valid runtime type for ${stringifyValueWithType(object)} given. Is @deepkit/type-compiler correctly installed? Execute deepkit-type-install to check`);\n        }\n\n        for (let i = 0; i < inputs.length; i++) {\n            if (isClass(inputs[i])) inputs[i] = resolveRuntimeType(inputs[i]);\n        }\n\n        //this checks if there is an active program still running for given packed. if so, issue a new reference.\n        //this reference is changed (its content only via Object.assign(reference, computedValues)) once the program finished.\n        //this is independent of reuseCache since it's the cache for the current 'run', not a global cache\n        const found = findExistingProgram(this.program, object, inputs);\n        if (found) {\n            const result = createRef(found);\n            result.typeName ||= options.typeName;\n            return result;\n        }\n\n        //the cache of already computed types is stored on the Packed (the array of the type program) because it's a static object that never changes\n        //and will be GC correctly (and with it this cache). Its crucial that not all reflect() calls cache the content, otherwise it would pollute the\n        //memory with useless types. For example a global type Partial<> would hold all its instances, what we do not want.\n        //We cache only direct non-generic (inputs empty) types passed to typeOf<>() or resolveRuntimeType(). all other reflect() calls do not use this cache.\n        //make sure the same type is returned if already known.\n        //packed.length === 0 for deserialized TypeClass with reconstructed classes.\n        if ((options.reuseCached || packed.length === 0) && packed.__type && inputs.length === 0) {\n            return packed.__type;\n        }\n\n        //all computed types should be cached until the program terminates, otherwise a lot of types will be computed\n        //way too often. This means we have a much bigger array cache and put everything in there, even for generics,\n        //and clear the cache once the program terminates. findExistingProgram will be replaced by that.\n        //with this change we could also remove the linked structure of Program and put it into an array as well.\n        for (const cache of this.cache) {\n            if (isValidCacheEntry(cache, object, inputs)) {\n                //if program is still active, create new ref otherwise copy computed type\n                const result = cache.active ? createRef(cache) : copyAndSetParent(cache.resultType);\n                result.typeName ||= options.typeName;\n                return result;\n            }\n        }\n\n        //if reuseCached is disabled but there is already a computed type, we return that as shallow clone\n        if (!options.reuseCached && packed.__type && inputs.length === 0) {\n            const result = copyAndSetParent(packed.__type);\n            result.typeName ||= options.typeName;\n            if (options.inline) result.inlined = true;\n            return result;\n        }\n\n        // process.stdout.write(`${options.reuseCached} Cache miss ${stringifyValueWithType(object)}(...${inputs.length})\\n`);\n        const pack = packed.__unpack ||= unpack(packed);\n        const program = createProgram({ ops: pack.ops, initialStack: pack.stack, object }, inputs);\n        const type = this.runProgram(program);\n        type.typeName ||= options.typeName;\n\n        if (inputs.length === 0) {\n            packed.__type = type;\n        }\n\n        if (options.inline === true) {\n            //when inline was used, we do not return the original type, because inline means it's part of another type\n            //and its properties will change depending on the context (e.g. parent), which should not propagate to the original type.\n            const result = createRef(program);\n            result.typeName ||= options.typeName;\n            result.inlined = true;\n            return result;\n        }\n\n        return type;\n    }\n\n    run(ops: ReflectionOp[], initialStack: RuntimeStackEntry[], inputs: RuntimeStackEntry[] = [], object?: ClassType | Function | Packed | any): Type {\n        return this.runProgram(createProgram({ ops, initialStack, object }, inputs));\n    }\n\n    runProgram(program: Program): Type {\n        const loopRunning = this.program.end !== 0;\n        program.previous = this.program;\n        program.depth = this.program.depth + 1;\n        this.program = program;\n        this.cache.push(program);\n\n        // process.stdout.write(`jump to program: ${stringifyValueWithType(program.object)}\\n`);\n        if (!loopRunning) {\n            return this.loop(program) as Type;\n        }\n\n        return program.resultType;\n    }\n\n    /**\n     * Semantic is important here: This triggers true only for the very last op of a program.\n     * If it is checked in OP inline then it could be true or false:\n     *\n     * type t<T> = T; => false since we have nominal past the inline op\n     * typeOf<T>() => true since we have no nominal past the inline op\n     */\n    protected isEnded(): boolean {\n        return this.program.program + 1 >= this.program.end;\n    }\n\n    /**\n     * Runs all scheduled programs until termination.\n     */\n    protected loop(until?: Program): Type | RuntimeStackEntry {\n        let result = this.program.stack[0];\n\n        programLoop:\n            while (this.program.active) {\n                const program = this.program;\n                // process.stdout.write(`jump to program: ${stringifyValueWithType(program.object)}\\n`);\n                for (; program.program < program.end; program.program++) {\n                    const op = program.ops[program.program];\n\n                    // process.stdout.write(`[${program.depth}:${program.frame.index}] step ${program.program} ${ReflectionOp[op]}\\n`);\n                    switch (op) {\n                        case ReflectionOp.string:\n                            this.pushType({ kind: ReflectionKind.string });\n                            break;\n                        case ReflectionOp.number:\n                            this.pushType({ kind: ReflectionKind.number });\n                            break;\n                        case ReflectionOp.numberBrand:\n                            const ref = this.eatParameter() as number;\n                            this.pushType({ kind: ReflectionKind.number, brand: ref });\n                            break;\n                        case ReflectionOp.boolean:\n                            this.pushType({ kind: ReflectionKind.boolean });\n                            break;\n                        case ReflectionOp.void:\n                            this.pushType({ kind: ReflectionKind.void });\n                            break;\n                        case ReflectionOp.unknown:\n                            this.pushType({ kind: ReflectionKind.unknown });\n                            break;\n                        case ReflectionOp.object:\n                            this.pushType({ kind: ReflectionKind.object });\n                            break;\n                        case ReflectionOp.never:\n                            this.pushType({ kind: ReflectionKind.never });\n                            break;\n                        case ReflectionOp.undefined:\n                            this.pushType({ kind: ReflectionKind.undefined });\n                            break;\n                        case ReflectionOp.bigint:\n                            this.pushType({ kind: ReflectionKind.bigint });\n                            break;\n                        case ReflectionOp.symbol:\n                            this.pushType({ kind: ReflectionKind.symbol });\n                            break;\n                        case ReflectionOp.null:\n                            this.pushType({ kind: ReflectionKind.null });\n                            break;\n                        case ReflectionOp.any:\n                            this.pushType({ kind: ReflectionKind.any });\n                            break;\n                        case ReflectionOp.literal: {\n                            const ref = this.eatParameter() as number;\n                            this.pushType({ kind: ReflectionKind.literal, literal: program.stack[ref] as string | number | boolean | bigint });\n                            break;\n                        }\n                        case ReflectionOp.templateLiteral: {\n                            this.handleTemplateLiteral();\n                            break;\n                        }\n                        case ReflectionOp.date:\n                            this.pushType({ kind: ReflectionKind.class, classType: Date, types: [] });\n                            break;\n                        case ReflectionOp.uint8Array:\n                            this.pushType({ kind: ReflectionKind.class, classType: Uint8Array, types: [] });\n                            break;\n                        case ReflectionOp.int8Array:\n                            this.pushType({ kind: ReflectionKind.class, classType: Int8Array, types: [] });\n                            break;\n                        case ReflectionOp.uint8ClampedArray:\n                            this.pushType({ kind: ReflectionKind.class, classType: Uint8ClampedArray, types: [] });\n                            break;\n                        case ReflectionOp.uint16Array:\n                            this.pushType({ kind: ReflectionKind.class, classType: Uint16Array, types: [] });\n                            break;\n                        case ReflectionOp.int16Array:\n                            this.pushType({ kind: ReflectionKind.class, classType: Int16Array, types: [] });\n                            break;\n                        case ReflectionOp.uint32Array:\n                            this.pushType({ kind: ReflectionKind.class, classType: Uint32Array, types: [] });\n                            break;\n                        case ReflectionOp.int32Array:\n                            this.pushType({ kind: ReflectionKind.class, classType: Int32Array, types: [] });\n                            break;\n                        case ReflectionOp.float32Array:\n                            this.pushType({ kind: ReflectionKind.class, classType: Float32Array, types: [] });\n                            break;\n                        case ReflectionOp.float64Array:\n                            this.pushType({ kind: ReflectionKind.class, classType: Float64Array, types: [] });\n                            break;\n                        case ReflectionOp.bigInt64Array:\n                            this.pushType({\n                                kind: ReflectionKind.class,\n                                classType: 'undefined' !== typeof BigInt64Array ? BigInt64Array : class BigInt64ArrayNotAvailable {\n                                },\n                                types: [],\n                            });\n                            break;\n                        case ReflectionOp.arrayBuffer:\n                            this.pushType({ kind: ReflectionKind.class, classType: ArrayBuffer, types: [] });\n                            break;\n                        case ReflectionOp.class: {\n                            const types = this.popFrame() as Type[];\n                            let t = { kind: ReflectionKind.class, id: state.nominalId++, classType: Object, types: [] } as TypeClass;\n\n                            function add(member: Type) {\n                                if (member.kind === ReflectionKind.propertySignature) {\n                                    member = {\n                                        ...member,\n                                        parent: t,\n                                        visibility: ReflectionVisibility.public,\n                                        kind: ReflectionKind.property,\n                                    } as TypeProperty;\n                                } else if (member.kind === ReflectionKind.methodSignature) {\n                                    member = {\n                                        ...member,\n                                        parent: t,\n                                        visibility: ReflectionVisibility.public,\n                                        kind: ReflectionKind.method,\n                                    } as TypeMethod;\n                                }\n\n                                switch (member.kind) {\n                                    case ReflectionKind.indexSignature: {\n                                        //todo, replace the old one?\n                                        t.types.push(member);\n                                        break;\n                                    }\n                                    case ReflectionKind.property:\n                                    case ReflectionKind.method: {\n                                        const existing = t.types.findIndex(v => (v.kind === ReflectionKind.property || v.kind === ReflectionKind.method) && v.name === (member as TypeProperty | TypeMethod).name);\n                                        if (existing !== -1) {\n                                            //remove entry, since we replace it\n                                            t.types.splice(existing, 1);\n                                        }\n                                        t.types.push(member);\n\n                                        if (member.kind === ReflectionKind.method && member.name === 'constructor') {\n                                            for (const parameter of member.parameters) {\n                                                if (parameter.visibility !== undefined || parameter.readonly) {\n                                                    const property = {\n                                                        kind: ReflectionKind.property,\n                                                        name: parameter.name,\n                                                        visibility: parameter.visibility,\n                                                        default: parameter.default,\n                                                        type: parameter.type,\n                                                    } as TypeProperty;\n                                                    if (parameter.optional) property.optional = true;\n                                                    if (parameter.readonly) property.readonly = true;\n                                                    parameter.type.parent = property;\n                                                    add(property);\n                                                }\n                                            }\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n\n                            for (const member of types) {\n                                switch (member.kind) {\n                                    case ReflectionKind.objectLiteral:\n                                    case ReflectionKind.class: {\n                                        for (const sub of member.types) add(sub);\n                                        break;\n                                    }\n                                    case ReflectionKind.indexSignature:\n                                    case ReflectionKind.property:\n                                    case ReflectionKind.method: {\n                                        add(member);\n                                    }\n                                }\n                                // if (member.kind === ReflectionKind.property) member.type = widenLiteral(member.type);\n                            }\n                            const args = program.frame.inputs.filter(isType);\n\n                            for (const member of t.types) member.parent = t;\n                            if (t.arguments) for (const member of t.arguments) member.parent = t;\n\n                            if (args.length) t.arguments = args;\n                            t.typeArguments = program.typeParameters;\n\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.widen: {\n                            const current = (program.stack[program.stackPointer] as Type);\n                            if (current.kind === ReflectionKind.literal) {\n                                this.pushType(widenLiteral(this.pop() as TypeLiteral));\n                            }\n                            break;\n                        }\n                        case ReflectionOp.classExtends: {\n                            const argsNumber = this.eatParameter() as number;\n                            const typeArguments: Type[] = [];\n                            for (let i = 0; i < argsNumber; i++) {\n                                typeArguments.push(this.pop() as Type);\n                            }\n\n                            (program.stack[program.stackPointer] as TypeClass).extendsArguments = typeArguments;\n\n                            break;\n                        }\n                        case ReflectionOp.implements: {\n                            const argsNumber = this.eatParameter() as number;\n                            const types: Type[] = [];\n                            for (let i = 0; i < argsNumber; i++) {\n                                types.push(this.pop() as Type);\n                            }\n\n                            (program.stack[program.stackPointer] as TypeClass).implements = types;\n\n                            break;\n                        }\n                        case ReflectionOp.parameter: {\n                            const ref = this.eatParameter() as number;\n                            const t: Type = { kind: ReflectionKind.parameter, parent: undefined as any, name: program.stack[ref] as string, type: this.pop() as Type };\n                            t.type.parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.functionReference:\n                        case ReflectionOp.classReference: {\n                            const ref = this.eatParameter() as number;\n                            const classOrFunction = resolveFunction(program.stack[ref] as Function, program.object);\n                            const inputs = this.popFrame() as Type[];\n                            if (!classOrFunction) {\n                                this.pushType({ kind: ReflectionKind.unknown });\n                                break;\n                            }\n\n                            if (!classOrFunction.__type) {\n                                if (op === ReflectionOp.classReference) {\n                                    this.pushType({ kind: ReflectionKind.class, classType: classOrFunction, typeArguments: inputs, types: [] });\n                                } else if (op === ReflectionOp.functionReference) {\n                                    this.pushType({ kind: ReflectionKind.function, function: classOrFunction, parameters: [], return: { kind: ReflectionKind.unknown } });\n                                }\n                            } else {\n                                //when it's just a simple reference resolution like typeOf<Class>() then enable cache re-use (so always the same type is returned)\n                                const directReference = !!(this.isEnded() && program.previous && program.previous.end === 0);\n                                const result = this.reflect(classOrFunction, inputs, { inline: !directReference, reuseCached: directReference });\n                                if (directReference) program.directReturn = true;\n                                this.push(result, program);\n\n                                if (isWithAnnotations(result) && inputs.length) {\n                                    result.typeArguments = result.typeArguments || [];\n                                    for (let i = 0; i < inputs.length; i++) {\n                                        result.typeArguments[i] = inputs[i];\n                                    }\n                                }\n\n                                //this.reflect/run might create another program onto the stack. switch to it if so\n                                if (this.program !== program) {\n                                    //continue to next this.program.\n                                    program.program++; //manual increment as the for loop would normally do that\n                                    continue programLoop;\n                                }\n                            }\n                            break;\n                        }\n                        case ReflectionOp.enum: {\n                            const types = this.popFrame() as TypeEnumMember[];\n                            const enumType: { [name: string]: string | number } = {};\n\n                            let i = 0;\n                            for (const type of types) {\n                                if (type.default) {\n                                    const v = type.default();\n                                    enumType[type.name] = v;\n                                    if ('number' === typeof v) {\n                                        i = v + 1;\n                                    }\n                                } else {\n                                    enumType[type.name] = i++;\n                                }\n                            }\n                            const values = Object.values(enumType);\n                            const t: Type = { kind: ReflectionKind.enum, enum: enumType, values, indexType: getEnumType(values) };\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.enumMember: {\n                            const name = program.stack[this.eatParameter() as number] as string | (() => string);\n                            this.pushType({\n                                kind: ReflectionKind.enumMember,\n                                parent: undefined as any,\n                                name: isFunction(name) ? name() : name,\n                            });\n                            break;\n                        }\n                        case ReflectionOp.tuple: {\n                            this.handleTuple();\n                            break;\n                        }\n                        case ReflectionOp.tupleMember: {\n                            const t: TypeTupleMember = {\n                                kind: ReflectionKind.tupleMember, type: this.pop() as Type,\n                                parent: undefined as any,\n                            };\n                            t.type.parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.namedTupleMember: {\n                            const name = program.stack[this.eatParameter() as number] as string;\n                            const t: Type = {\n                                kind: ReflectionKind.tupleMember, type: this.pop() as Type,\n                                parent: undefined as any,\n                                name: isFunction(name) ? name() : name,\n                            };\n                            t.type.parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.rest: {\n                            const t: Type = {\n                                kind: ReflectionKind.rest,\n                                parent: undefined as any,\n                                type: this.pop() as Type,\n                            };\n                            t.type.parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.regexp: {\n                            this.pushType({ kind: ReflectionKind.regexp });\n                            break;\n                        }\n                        case ReflectionOp.typeParameter:\n                        case ReflectionOp.typeParameterDefault: {\n                            const nameRef = this.eatParameter() as number;\n                            program.typeParameters = program.typeParameters || [];\n                            let type = program.frame.inputs[program.frame.variables++];\n\n                            if (op === ReflectionOp.typeParameterDefault) {\n                                const defaultValue = this.pop();\n                                if (type === undefined) {\n                                    type = defaultValue;\n                                }\n                            }\n\n                            if (type === undefined) {\n                                //generic not instantiated\n                                program.typeParameters.push({ kind: ReflectionKind.any, typeParameter: true } as any);\n                                this.pushType({ kind: ReflectionKind.typeParameter, name: program.stack[nameRef] as string });\n                            } else {\n                                program.typeParameters.push(type as Type);\n                                this.pushType(type as Type);\n                            }\n                            break;\n                        }\n                        case ReflectionOp.set: {\n                            const t: Type = { kind: ReflectionKind.class, classType: Set, arguments: [this.pop() as Type], types: [] };\n                            t.arguments![0].parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.map: {\n                            const value = this.pop() as Type;\n                            const key = this.pop() as Type;\n                            const t: TypeClass = { kind: ReflectionKind.class, classType: Map, arguments: [key, value], types: [] };\n                            t.arguments![0].parent = t;\n                            t.arguments![1].parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.promise: {\n                            const type = this.pop() as Type;\n                            const t: TypePromise = { kind: ReflectionKind.promise, type };\n                            t.type.parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.union: {\n                            const types = this.popFrame() as Type[];\n                            const flattened = flattenUnionTypes(types);\n                            const t: Type = unboxUnion({ kind: ReflectionKind.union, types: flattened });\n                            if (t.kind === ReflectionKind.union) {\n                                for (const member of t.types) {\n                                    member.parent = t;\n                                }\n                            }\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.intersection: {\n                            let t = this.handleIntersection();\n                            if (t) this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.callSignature:\n                        case ReflectionOp.function: {\n                            const types = this.popFrame() as Type[];\n                            let name = program.stack[this.eatParameter() as number] as string;\n\n                            const returnType = types.length > 0 ? types[types.length - 1] as Type : { kind: ReflectionKind.any } as Type;\n                            const parameters = types.length > 1 ? types.slice(0, -1) as TypeParameter[] : [];\n                            if (isFunction(name)) name = name();\n\n                            let t = op === ReflectionOp.callSignature ? {\n                                kind: ReflectionKind.callSignature,\n                                return: returnType,\n                                parameters,\n                            } as TypeCallSignature : {\n                                kind: ReflectionKind.function,\n                                name: name || undefined,\n                                return: returnType,\n                                parameters,\n                            } as TypeFunction;\n                            t.return.parent = t;\n                            for (const member of t.parameters) member.parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.array: {\n                            const t: Type = { kind: ReflectionKind.array, type: this.pop() as Type };\n                            t.type.parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.property:\n                        case ReflectionOp.propertySignature: {\n                            const name = program.stack[this.eatParameter() as number] as number | string | symbol | (() => symbol);\n                            let type = this.pop() as Type;\n                            let isOptional = false;\n\n                            if (type.kind === ReflectionKind.union && type.types.length === 2) {\n                                const undefinedType = type.types.find(v => v.kind === ReflectionKind.undefined);\n                                const restType = type.types.find(v => v.kind !== ReflectionKind.null && v.kind !== ReflectionKind.undefined);\n                                if (restType && undefinedType) {\n                                    type = restType;\n                                    isOptional = true;\n                                }\n                            }\n\n                            const property = {\n                                kind: op === ReflectionOp.propertySignature ? ReflectionKind.propertySignature : ReflectionKind.property,\n                                type,\n                                name: isFunction(name) ? name() : name,\n                            } as TypeProperty | TypePropertySignature;\n\n                            if (isOptional) {\n                                property.optional = true;\n                            }\n\n                            if (op === ReflectionOp.property) {\n                                (property as TypeProperty).visibility = ReflectionVisibility.public;\n                            }\n\n                            property.type.parent = property;\n                            this.pushType(property);\n                            break;\n                        }\n                        case ReflectionOp.method:\n                        case ReflectionOp.methodSignature: {\n                            let name = program.stack[this.eatParameter() as number] as number | string | symbol | (() => symbol);\n                            const types = this.popFrame() as Type[];\n                            const returnType = types.length > 0 ? types[types.length - 1] as Type : { kind: ReflectionKind.any } as Type;\n                            const parameters: TypeParameter[] = types.length > 1 ? types.slice(0, -1) as TypeParameter[] : [];\n                            if (isFunction(name)) name = name();\n\n                            let t: TypeMethod | TypeMethodSignature = op === ReflectionOp.method\n                                ? { kind: ReflectionKind.method, parent: undefined as any, visibility: ReflectionVisibility.public, name, return: returnType, parameters }\n                                : { kind: ReflectionKind.methodSignature, parent: undefined as any, name, return: returnType, parameters };\n                            t.return.parent = t;\n                            for (const member of t.parameters) member.parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.optional:\n                            (program.stack[program.stackPointer] as TypeBaseMember | TypeTupleMember).optional = true;\n                            break;\n                        case ReflectionOp.readonly:\n                            (program.stack[program.stackPointer] as TypeBaseMember).readonly = true;\n                            break;\n                        case ReflectionOp.public:\n                            (program.stack[program.stackPointer] as TypeBaseMember).visibility = ReflectionVisibility.public;\n                            break;\n                        case ReflectionOp.protected:\n                            (program.stack[program.stackPointer] as TypeBaseMember).visibility = ReflectionVisibility.protected;\n                            break;\n                        case ReflectionOp.private:\n                            (program.stack[program.stackPointer] as TypeBaseMember).visibility = ReflectionVisibility.private;\n                            break;\n                        case ReflectionOp.abstract:\n                            (program.stack[program.stackPointer] as TypeBaseMember).abstract = true;\n                            break;\n                        case ReflectionOp.static:\n                            (program.stack[program.stackPointer] as TypeBaseMember).static = true;\n                            break;\n                        case ReflectionOp.defaultValue:\n                            (program.stack[program.stackPointer] as TypeProperty | TypeEnumMember | TypeParameter).default = program.stack[this.eatParameter() as number] as () => any;\n                            break;\n                        case ReflectionOp.description:\n                            (program.stack[program.stackPointer] as TypeProperty).description = program.stack[this.eatParameter() as number] as string;\n                            break;\n                        case ReflectionOp.typeName: {\n                            const type = (program.stack[program.stackPointer] as Type);\n                            const name = program.stack[this.eatParameter() as number] as string;\n                            if (type.typeName) {\n                                type.originTypes = [{ typeName: type.typeName, typeArguments: type.typeArguments }, ...(type.originTypes || [])];\n                                type.typeArguments = undefined;\n                            }\n                            type.typeName = name;\n                            break;\n                        }\n                        case ReflectionOp.indexSignature: {\n                            const type = this.pop() as Type;\n                            const index = this.pop() as Type;\n                            const t: Type = { kind: ReflectionKind.indexSignature, parent: undefined as any, index, type };\n                            t.type.parent = t;\n                            t.index.parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        case ReflectionOp.objectLiteral: {\n                            let t = {\n                                kind: ReflectionKind.objectLiteral,\n                                id: state.nominalId++,\n                                types: [],\n                            } as TypeObjectLiteral;\n\n                            const frameTypes = this.popFrame() as (TypeIndexSignature | TypePropertySignature | TypeMethodSignature | TypeObjectLiteral | TypeCallSignature)[];\n                            pushObjectLiteralTypes(t, frameTypes);\n                            for (const member of t.types) member.parent = t;\n                            this.pushType(t);\n                            break;\n                        }\n                        // case ReflectionOp.pointer: {\n                        //     this.push(program.stack[this.eatParameter() as number]);\n                        //     break;\n                        // }\n                        case ReflectionOp.distribute: {\n                            this.handleDistribute(program);\n                            break;\n                        }\n                        case ReflectionOp.condition: {\n                            const right = this.pop() as Type;\n                            const left = this.pop() as Type;\n                            const condition = this.pop() as Type | number;\n                            this.popFrame();\n                            isConditionTruthy(condition) ? this.pushType(left) : this.pushType(right);\n                            break;\n                        }\n                        case ReflectionOp.jumpCondition: {\n                            const leftProgram = this.eatParameter() as number;\n                            const rightProgram = this.eatParameter() as number;\n                            const condition = this.pop() as Type | number;\n                            const truthy = isConditionTruthy(condition);\n                            this.call(truthy ? leftProgram : rightProgram);\n                            break;\n                        }\n                        case ReflectionOp.infer: {\n                            const frameOffset = this.eatParameter() as number;\n                            const stackEntryIndex = this.eatParameter() as number;\n                            const frame = program.frame;\n\n                            let last: Type = { kind: ReflectionKind.unknown };\n                            this.push({\n                                kind: ReflectionKind.infer, set: (type: Type) => {\n                                    if (last.kind !== ReflectionKind.unknown) {\n                                        if (last.kind === ReflectionKind.union || last.kind === ReflectionKind.intersection) {\n                                            if (!isTypeIncluded(last.types, type)) {\n                                                last.types.push(type);\n                                            }\n                                        } else {\n                                            if (type.parent && type.parent.kind === ReflectionKind.parameter) {\n                                                last = { kind: ReflectionKind.intersection, types: [last, type] };\n                                            } else {\n                                                last = { kind: ReflectionKind.union, types: [last, type] };\n                                            }\n                                        }\n                                    } else {\n                                        last = type;\n                                    }\n\n                                    if (frameOffset === 0) {\n                                        program.stack[frame.startIndex + 1 + stackEntryIndex] = last;\n                                    } else if (frameOffset === 1) {\n                                        program.stack[frame.previous!.startIndex + 1 + stackEntryIndex] = last;\n                                    } else if (frameOffset === 2) {\n                                        program.stack[frame.previous!.previous!.startIndex + 1 + stackEntryIndex] = last;\n                                    } else if (frameOffset === 3) {\n                                        program.stack[frame.previous!.previous!.previous!.startIndex + 1 + stackEntryIndex] = last;\n                                    } else if (frameOffset === 4) {\n                                        program.stack[frame.previous!.previous!.previous!.previous!.startIndex + 1 + stackEntryIndex] = last;\n                                    } else {\n                                        let current = frame;\n                                        for (let i = 0; i < frameOffset; i++) current = current.previous!;\n                                        program.stack[current.startIndex + 1 + stackEntryIndex] = last;\n                                    }\n                                },\n                            } as TypeInfer);\n                            break;\n                        }\n                        case ReflectionOp.extends: {\n                            const right = this.pop() as string | number | boolean | Type;\n                            const left = this.pop() as string | number | boolean | Type;\n                            const result = isExtendable(left, right);\n                            this.pushType({ kind: ReflectionKind.literal, literal: result });\n                            break;\n                        }\n                        case ReflectionOp.indexAccess: {\n                            this.handleIndexAccess();\n                            break;\n                        }\n                        case ReflectionOp.typeof: {\n                            const param1 = this.eatParameter() as number;\n                            const fn = program.stack[param1] as () => any;\n                            const value = fn();\n\n                            //typeInfer calls Processor.run() and changes this.program, so handle it correctly\n                            const result = typeInfer(value);\n                            this.push(result, program);\n\n                            //this.reflect/run might create another program onto the stack. switch to it if so\n                            if (this.program !== program) {\n                                //continue to next this.program.\n                                program.program++; //manual increment as the for loop would normally do that\n                                continue programLoop;\n                            }\n                            break;\n                        }\n                        case ReflectionOp.keyof: {\n                            this.handleKeyOf();\n                            break;\n                        }\n                        case ReflectionOp.var: {\n                            this.push({ kind: ReflectionKind.unknown, var: true });\n                            program.frame.variables++;\n                            break;\n                        }\n                        case ReflectionOp.mappedType2: {\n                            this.handleMappedType(program, true);\n                            break;\n                        }\n                        case ReflectionOp.mappedType: {\n                            this.handleMappedType(program);\n                            break;\n                        }\n                        case ReflectionOp.loads: {\n                            const frameOffset = this.eatParameter() as number;\n                            const stackEntryIndex = this.eatParameter() as number;\n                            if (frameOffset === 0) {\n                                this.push(program.stack[program.frame.startIndex + 1 + stackEntryIndex]);\n                            } else if (frameOffset === 1) {\n                                this.push(program.stack[program.frame.previous!.startIndex + 1 + stackEntryIndex]);\n                            } else if (frameOffset === 2) {\n                                this.push(program.stack[program.frame.previous!.previous!.startIndex + 1 + stackEntryIndex]);\n                            } else if (frameOffset === 3) {\n                                this.push(program.stack[program.frame.previous!.previous!.previous!.startIndex + 1 + stackEntryIndex]);\n                            } else if (frameOffset === 4) {\n                                this.push(program.stack[program.frame.previous!.previous!.previous!.previous!.startIndex + 1 + stackEntryIndex]);\n                            } else {\n                                let current = program.frame;\n                                for (let i = 0; i < frameOffset; i++) current = current.previous!;\n                                this.push(program.stack[current.startIndex + 1 + stackEntryIndex]);\n                            }\n                            break;\n                        }\n                        case ReflectionOp.arg: {\n                            //used by InlineRuntimeType too\n                            const arg = this.eatParameter() as number;\n                            const t = program.stack[arg] as Type | ReflectionClass<any> | number | string | boolean | bigint;\n                            if (t instanceof ReflectionClass) {\n                                this.push({ ...t.type, typeName: t.getClassName() });\n                            } else if ('string' === typeof t || 'number' === typeof t || 'boolean' === typeof t || 'bigint' === typeof t) {\n                                this.push({ kind: ReflectionKind.literal, literal: t });\n                            } else {\n                                this.push(t);\n                            }\n                            break;\n                        }\n                        case ReflectionOp.return: {\n                            this.returnFrame();\n                            break;\n                        }\n                        case ReflectionOp.frame: {\n                            this.pushFrame();\n                            break;\n                        }\n                        case ReflectionOp.moveFrame: {\n                            const type = this.pop();\n                            this.popFrame();\n                            if (type) this.push(type);\n                            break;\n                        }\n                        case ReflectionOp.jump: {\n                            const arg = this.eatParameter() as number;\n                            program.program = arg - 1; //-1 because next iteration does program++\n                            break;\n                        }\n                        case ReflectionOp.call: {\n                            const programPointer = this.eatParameter() as number;\n                            this.call(programPointer);\n                            break;\n                        }\n                        case ReflectionOp.nominal: {\n                            const t = program.stack[program.stackPointer] as Type;\n                            //program ended, so assign new nominal id to objectLiteral or class\n                            t.id = state.nominalId++;\n                            break;\n                        }\n                        case ReflectionOp.inline: {\n                            const pPosition = this.eatParameter() as number;\n                            const pOrFn = program.stack[pPosition] as number | Packed | (() => Packed);\n                            const p = isFunction(pOrFn) ? pOrFn() : pOrFn;\n                            if (p === undefined) {\n                                debug(`Failed runtime inlining of ${pOrFn.toString()}. Value is undefined, probably because of a circular reference or failed import.`);\n                                this.push({ kind: ReflectionKind.unknown });\n                            } else if ('number' === typeof p) {\n                                //self circular reference, usually a 0, which indicates we put the result of the current program as the type on the stack.\n                                this.push(program.resultType);\n                            } else {\n                                //when it's just a simple reference resolution like typeOf<Class>() then don't issue a new reference (no inline: true)\n                                const directReference = !!(this.isEnded() && program.previous && program.previous.end === 0);\n                                const result = this.reflect(p, [], { inline: !directReference, reuseCached: directReference });\n                                if (directReference) program.directReturn = true;\n                                this.push(result, program);\n\n                                //this.reflect/run might create another program onto the stack. switch to it if so\n                                if (this.program !== program) {\n                                    //continue to next this.program.\n                                    program.program++; //manual increment as the for loop would normally do that\n                                    continue programLoop;\n                                }\n                            }\n                            break;\n                        }\n                        case ReflectionOp.inlineCall: {\n                            const pPosition = this.eatParameter() as number;\n                            const argumentSize = this.eatParameter() as number;\n                            const inputs: Type[] = [];\n                            for (let i = 0; i < argumentSize; i++) {\n                                let input = this.pop() as Type;\n                                if ((input.kind === ReflectionKind.never || input.kind === ReflectionKind.unknown) && program.inputs[i]) input = program.inputs[i] as Type;\n                                inputs.unshift(input);\n                            }\n                            const pOrFn = program.stack[pPosition] as number | Packed | (() => Packed);\n                            const p = isFunction(pOrFn) ? pOrFn() : pOrFn;\n                            if (p === undefined) {\n                                debug(`Failed runtime inlining call of ${pOrFn.toString()}. Value is undefined, probably because of a circular reference or failed import.`);\n                                this.push({ kind: ReflectionKind.unknown });\n                            } else if ('number' === typeof p) {\n                                if (argumentSize === 0) {\n                                    //self circular reference, usually a 0, which indicates we put the result of the current program as the type on the stack.\n                                    this.push(program.resultType);\n                                } else {\n                                    const found = findExistingProgram(this.program, program.object, inputs);\n                                    if (found) {\n                                        this.push(createRef(found), program);\n                                    } else {\n                                        // process.stdout.write(`Cache miss ${pOrFn.toString()}(...${inputs.length})\\n`);\n                                        //execute again the current program\n                                        const nextProgram = createProgram({\n                                            ops: program.ops,\n                                            initialStack: program.initialStack,\n                                        }, inputs);\n                                        this.push(this.runProgram(nextProgram), program);\n\n                                        //continue to next this.program that was assigned by runProgram()\n                                        program.program++; //manual increment as the for loop would normally do that\n                                        continue programLoop;\n                                    }\n                                }\n                            } else {\n                                const result = this.reflect(p, inputs);\n\n                                if (isWithAnnotations(result) && inputs.length) {\n                                    result.typeArguments = result.typeArguments || [];\n                                    for (let i = 0; i < inputs.length; i++) {\n                                        result.typeArguments[i] = inputs[i];\n                                    }\n                                }\n\n                                this.push(result, program);\n\n                                //this.reflect/run might create another program onto the stack. switch to it if so\n                                if (this.program !== program) {\n                                    //continue to next this.program.\n                                    program.program++; //manual increment as the for loop would normally do that\n                                    continue programLoop;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                }\n\n                result = narrowOriginalLiteral(program.stack[program.stackPointer] as Type);\n                // process.stdout.write(`Done ${program.depth} in ${Date.now() - program.started}ms with ${stringifyValueWithType(program.object)} -> ${stringifyShortResolvedType(result as Type)}\\n`);\n\n                if (isType(result)) {\n                    if (program.object) {\n                        if (result.kind === ReflectionKind.class && result.classType === Object) {\n                            result.classType = program.object;\n                            applyClassDecorators(result);\n                        }\n                        if (result.kind === ReflectionKind.function && !result.function) {\n                            result.function = program.object;\n                        }\n                    }\n                    if (!program.directReturn) {\n                        result = assignResult(program.resultType, result as Type, !result.inlined);\n                        applyScheduledAnnotations(program.resultType);\n                    }\n                }\n\n                program.active = false;\n                if (program.previous) this.program = program.previous;\n\n                if (program.resultTypes) for (const ref of program.resultTypes) {\n                    assignResult(ref, result as Type, false);\n                    applyScheduledAnnotations(ref);\n                }\n                if (until === program) {\n                    this.cache = [];\n                    return result;\n                }\n            }\n\n        this.cache = [];\n        return result;\n    }\n\n    private handleTuple() {\n        const types: TypeTupleMember[] = [];\n        const stackTypes = this.popFrame() as Type[];\n        for (const type of stackTypes) {\n            const resolved: TypeTupleMember = type.kind === ReflectionKind.tupleMember ? type : {\n                kind: ReflectionKind.tupleMember,\n                parent: undefined as any,\n                type,\n            };\n            type.parent = resolved;\n            if (resolved.type.kind === ReflectionKind.rest) {\n                if (resolved.type.type.kind === ReflectionKind.tuple) {\n                    for (const sub of resolved.type.type.types) {\n                        types.push(sub);\n                    }\n                } else {\n                    types.push(resolved);\n                }\n            } else {\n                types.push(resolved);\n            }\n        }\n        const t: Type = { kind: ReflectionKind.tuple, types };\n        for (const member of t.types) member.parent = t;\n        this.pushType(t);\n    }\n\n    private handleIntersection() {\n        const types = this.popFrame() as Type[];\n        let result: Type | undefined = { kind: ReflectionKind.unknown };\n        if (!types.length) {\n            this.pushType({ kind: ReflectionKind.never });\n            return;\n        }\n        const annotations: Annotations = {};\n        const decorators: TypeObjectLiteral[] = [];\n        const defaultDecorators: Type[] = [];\n\n        function appendAnnotations(a: Type) {\n            if (a.annotations === annotations) return;\n            if (a.annotations) Object.assign(annotations, a.annotations);\n            if (a.decorators) decorators.push(...a.decorators as TypeObjectLiteral[]);\n        }\n\n        function handleUnion(a: Type, unionType: TypeUnion): Type {\n            if (a.kind === ReflectionKind.objectLiteral || a.kind === ReflectionKind.class) {\n                return unboxUnion({ kind: ReflectionKind.union, types: unionType.types.map(v => collapse(v, a)).filter(v => v.kind !== ReflectionKind.never) });\n            }\n            return unboxUnion({ kind: ReflectionKind.union, types: unionType.types.filter(v => isExtendable(v, a)) });\n        }\n\n        function handleAndObject(a: Type, objectType: TypeObjectLiteral): Type {\n            if (objectType.types.length === 0) {\n                return isExtendable(a, objectType) ? a : { kind: ReflectionKind.never };\n            }\n            defaultDecorators.push(objectType);\n            annotations[defaultAnnotation.symbol] = defaultDecorators;\n            return a;\n        }\n\n        function collapse(a: Type, b: Type): Type {\n            if (a.kind === ReflectionKind.any) return a;\n            if (b.kind === ReflectionKind.any) return b;\n\n            if (a.kind === ReflectionKind.union) {\n                return handleUnion(b, a);\n            }\n\n            if (b.kind === ReflectionKind.union) {\n                return handleUnion(a, b);\n            }\n\n            if ((a.kind === ReflectionKind.objectLiteral || a.kind === ReflectionKind.class) && (b.kind === ReflectionKind.objectLiteral || b.kind === ReflectionKind.class)) {\n                appendAnnotations(a);\n                appendAnnotations(b);\n                return merge([a, b]);\n            }\n\n            // object & {then() ...}\n            if (a.kind === ReflectionKind.object && b.kind === ReflectionKind.objectLiteral) {\n                return b;\n            }\n            if (b.kind === ReflectionKind.object && a.kind === ReflectionKind.objectLiteral) {\n                return a;\n            }\n\n            if (isPrimitive(a) && b.kind === ReflectionKind.objectLiteral) {\n                return handleAndObject(a, b);\n            }\n\n            if (isPrimitive(b) && a.kind === ReflectionKind.objectLiteral) {\n                return handleAndObject(b, a);\n            }\n\n            //1 & number => 1\n            //number & 1 => 1\n            //'2' & string => '2'\n            //string & '2' => '2'\n            //2 & string => never\n            //string & 2 => never\n            //'b' & number => never\n            //number & 'b' => never\n            if (isPrimitive(a) && b.kind === ReflectionKind.literal) {\n                return isExtendable(b, a) ? b : { kind: ReflectionKind.never };\n            }\n            if (isPrimitive(b) && a.kind === ReflectionKind.literal) {\n                return isExtendable(a, b) ? a : { kind: ReflectionKind.never };\n            }\n\n            // two different primitives always return never\n            if (isPrimitive(a) && isPrimitive(b) && a.kind !== b.kind) {\n                return { kind: ReflectionKind.never }\n            }\n\n            if (a.kind === ReflectionKind.objectLiteral || a.kind === ReflectionKind.class || a.kind === ReflectionKind.never || a.kind === ReflectionKind.unknown) return b;\n\n            if (b.annotations) {\n                Object.assign(annotations, b.annotations);\n            }\n\n            return a;\n        }\n\n        outer:\n            for (const type of types) {\n                if (type.kind === ReflectionKind.never) continue;\n                if (type.kind === ReflectionKind.objectLiteral) {\n                    for (const decorator of typeDecorators) {\n                        if (decorator(annotations, type)) {\n                            decorators.push(type);\n                            continue outer;\n                        }\n                    }\n                }\n                if (result.kind === ReflectionKind.never) {\n                    result = { kind: ReflectionKind.never };\n                    break;\n                } else if (result.kind === ReflectionKind.unknown) {\n                    result = type;\n                    appendAnnotations(type);\n                } else {\n                    result = collapse(result, type);\n                }\n            }\n\n        if (result.kind === ReflectionKind.unknown) {\n            //type not calculated yet, so schedule annotations. Those will be applied once the type is fully computed.\n            result.scheduleDecorators = decorators;\n        } else {\n            //copy so the original type is not modified\n            result = copyAndSetParent(result);\n            result.annotations = result.annotations || {};\n            if (decorators.length) result.decorators = decorators;\n            Object.assign(result.annotations, annotations);\n        }\n        return result;\n    }\n\n    private handleDistribute(program: Program) {\n        const programPointer = this.eatParameter() as number;\n\n        if (program.frame.distributiveLoop) {\n            const type = this.pop() as Type;\n\n            if (type.kind === ReflectionKind.never) {\n                //we ignore never, to filter them out\n            } else {\n                this.push(type);\n            }\n        } else {\n            //start loop\n            const distributeOver = this.pop() as Type;\n            program.frame.distributiveLoop = new Loop(distributeOver);\n        }\n\n        const next = program.frame.distributiveLoop.next();\n        if (next === undefined) {\n            //end\n            const types = this.popFrame() as Type[];\n            const result: TypeUnion = { kind: ReflectionKind.union, types: flattenUnionTypes(types) };\n            const t: Type = unboxUnion(result);\n            if (t.kind === ReflectionKind.union) for (const member of t.types) member.parent = t;\n            this.push(t);\n        } else {\n            program.stack[program.frame.startIndex + 1] = next;\n            this.call(programPointer, -1); //-1=jump back to this very same position, to be able to loop\n        }\n    }\n\n    private handleIndexAccess() {\n        const right = this.pop() as Type;\n        const left = this.pop() as Type;\n\n        if (!isType(left)) {\n            this.push({ kind: ReflectionKind.never });\n        } else {\n            const t: Type = indexAccess(left, right);\n            if (isWithAnnotations(t)) {\n                t.indexAccessOrigin = { container: left as TypeObjectLiteral, index: right as Type };\n            }\n            this.push(copyAndSetParent(t));\n        }\n    }\n\n    private handleKeyOf() {\n        const type = this.pop() as Type;\n        if (type.kind === ReflectionKind.objectLiteral || type.kind === ReflectionKind.class) {\n            const union = { kind: ReflectionKind.union, origin: type, types: [] } as TypeUnion;\n            for (const member of type.types) {\n                if ((member.kind === ReflectionKind.propertySignature || member.kind === ReflectionKind.property) && member.name !== 'new') {\n                    union.types.push({ kind: ReflectionKind.literal, literal: member.name, parent: union, origin: member } as TypeLiteral);\n                } else if ((member.kind === ReflectionKind.methodSignature || member.kind === ReflectionKind.method) && member.name !== 'constructor') {\n                    union.types.push({ kind: ReflectionKind.literal, literal: member.name, parent: union, origin: member } as TypeLiteral);\n                }\n            }\n            this.push(union);\n        } else if (type.kind === ReflectionKind.tuple) {\n            const union = { kind: ReflectionKind.union, origin: type, types: [] } as TypeUnion;\n            for (let i = 0; i < type.types.length; i++) {\n                union.types.push({ kind: ReflectionKind.literal, literal: i, parent: union } as TypeLiteral);\n            }\n            this.push(union);\n        } else if (type.kind === ReflectionKind.any) {\n            this.push({ kind: ReflectionKind.union, types: [{ kind: ReflectionKind.string }, { kind: ReflectionKind.number }, { kind: ReflectionKind.symbol }] });\n        } else {\n            this.push({ kind: ReflectionKind.never });\n        }\n    }\n\n    private handleMappedType(program: Program, withName = false) {\n        const functionPointer = this.eatParameter() as number;\n        const modifier = this.eatParameter() as number;\n\n        function isSimpleIndex(index: Type): boolean {\n            if (index.kind === ReflectionKind.string || index.kind === ReflectionKind.number || index.kind === ReflectionKind.symbol) return true;\n            if (index.kind === ReflectionKind.union) {\n                const types = index.types.filter(v => isSimpleIndex(v));\n                return types.length === 0;\n            }\n            return false;\n        }\n\n        if (program.frame.mappedType) {\n            let type = this.pop() as Type;\n            let index: Type | string | boolean | symbol | number | bigint = program.stack[program.frame.startIndex + 1] as Type;\n            if (withName) {\n                if (type.kind === ReflectionKind.tuple) {\n                    index = type.types[1].type;\n                    type = type.types[0].type;\n                } else {\n                    throw new Error('Tuple expect');\n                }\n            }\n            const fromType = program.frame.mappedType.fromType;\n            const isTuple = fromType.origin && fromType.origin.kind === ReflectionKind.tuple;\n\n            if (index.kind === ReflectionKind.never) {\n                //ignore\n            } else if (index.kind === ReflectionKind.any || isSimpleIndex(index)) {\n                const t: TypeIndexSignature = { kind: ReflectionKind.indexSignature, type, index, parent: undefined as any };\n                t.type.parent = t;\n                t.index.parent = t;\n                this.push(t);\n            } else {\n                let optional: true | undefined = undefined;\n                let readonly: true | undefined = undefined;\n\n                if (index.kind === ReflectionKind.literal && !(index.literal instanceof RegExp)) {\n                    optional = !!index.origin && isMember(index.origin) && index.origin.optional ? true : undefined;\n                    index = index.literal;\n                }\n\n                // If the type was a property, then grab the optional modifier from the property itself.\n                // Note: This is inconsistent with TS official behaviour, as\n                // mapped types only preserve modifiers when its homomorphic\n                // https://github.com/microsoft/TypeScript/pull/12563\n                if (type.parent && (type.parent.kind === ReflectionKind.propertySignature || type.parent.kind === ReflectionKind.property)) {\n                    if (type.parent.optional) optional = true;\n                    if (type.parent.readonly) readonly = true;\n                }\n\n                const property: TypeProperty | TypePropertySignature | TypeTupleMember = type.kind === ReflectionKind.propertySignature || type.kind === ReflectionKind.property || type.kind === ReflectionKind.tupleMember\n                    ? type\n                    : { kind: isTuple ? ReflectionKind.tupleMember : ReflectionKind.propertySignature, name: index, type } as TypePropertySignature;\n\n                if (optional) property.optional = true;\n                if (readonly && property.kind !== ReflectionKind.tupleMember) property.readonly = true;\n\n                if (property !== type) type.parent = property;\n                if (property.type.kind !== ReflectionKind.never) {\n                    //never is filtered out\n                    if (modifier !== 0) {\n                        if (modifier & MappedModifier.optional) {\n                            property.optional = true;\n                        }\n                        if (modifier & MappedModifier.removeOptional && property.optional) {\n                            property.optional = undefined;\n                        }\n                        if (property.kind !== ReflectionKind.tupleMember) {\n                            if (modifier & MappedModifier.readonly) {\n                                property.readonly = true;\n                            }\n                            if (modifier & MappedModifier.removeReadonly && property.readonly) {\n                                property.readonly = undefined;\n                            }\n                        }\n                    }\n                    this.push(property);\n                }\n            }\n        } else {\n            program.frame.mappedType = new Loop(this.pop() as Type);\n        }\n\n        let next = program.frame.mappedType.next();\n        if (next === undefined) {\n            //end\n            const fromType = program.frame.mappedType.fromType;\n            const members = this.popFrame() as Type[];\n            let t: Type;\n\n            if (fromType.origin && fromType.origin.kind === ReflectionKind.tuple) {\n                t = { kind: ReflectionKind.tuple, types: members as any[] };\n            } else {\n                t = { kind: ReflectionKind.objectLiteral, id: state.nominalId++, types: members as any[] };\n            }\n\n            this.push(t);\n        } else {\n            if (isMember(next)) {\n                next = { kind: ReflectionKind.literal, literal: next.name };\n            }\n            program.stack[program.frame.startIndex + 1] = next; //change the mapped type parameter\n            this.call(functionPointer, -2);\n        }\n    }\n\n    private handleTemplateLiteral() {\n        const types = this.popFrame() as Type[];\n        const result: TypeUnion = { kind: ReflectionKind.union, types: [] };\n        const cartesian = new CartesianProduct();\n        for (const type of types) {\n            cartesian.add(type);\n        }\n        const product = cartesian.calculate();\n\n        outer:\n            for (const combination of product) {\n                const template: TypeTemplateLiteral = { kind: ReflectionKind.templateLiteral, types: [] };\n                let hasPlaceholder = false;\n                let lastLiteral: { kind: ReflectionKind.literal, literal: string, parent?: Type } | undefined = undefined;\n                //merge a combination of types, e.g. [string, 'abc', '3'] as template literal => `${string}abc3`.\n                for (const item of combination) {\n                    if (item.kind === ReflectionKind.never) {\n                        //template literals that contain a never like `prefix.${never}` are completely ignored\n                        continue outer;\n                    }\n\n                    if (item.kind === ReflectionKind.literal) {\n                        if (lastLiteral) {\n                            lastLiteral.literal += item.literal as string + '';\n                        } else {\n                            lastLiteral = { kind: ReflectionKind.literal, literal: item.literal as string + '', parent: template };\n                            template.types.push(lastLiteral);\n                        }\n                    } else {\n                        hasPlaceholder = true;\n                        lastLiteral = undefined;\n                        item.parent = template;\n                        template.types.push(item as TypeTemplateLiteral['types'][number]);\n                    }\n                }\n\n                if (hasPlaceholder) {\n                    if (template.types.length === 1 && template.types[0].kind === ReflectionKind.string) {\n                        template.types[0].parent = result;\n                        result.types.push(template.types[0]);\n                    } else {\n                        template.parent = result;\n                        result.types.push(template);\n                    }\n                } else if (lastLiteral) {\n                    lastLiteral.parent = result;\n                    result.types.push(lastLiteral);\n                }\n            }\n        const t: Type = unboxUnion(result);\n        if (t.kind === ReflectionKind.union) for (const member of t.types) member.parent = t;\n        this.pushType(t);\n    }\n\n    protected push(entry: RuntimeStackEntry, program: Program = this.program): void {\n        const i = ++program.stackPointer;\n\n        if (i < program.stack.length) {\n            program.stack[i] = entry;\n        } else {\n            program.stack.push(entry);\n        }\n    }\n\n    protected pop(): RuntimeStackEntry {\n        if (this.program.stackPointer < 0) throw new Error('Stack empty');\n        // return this.program.stack.pop()!;\n        return this.program.stack[this.program.stackPointer--];\n    }\n\n    protected pushFrame(): void {\n        this.program.frame = {\n            index: this.program.frame.index + 1,\n            startIndex: this.program.stackPointer,\n            inputs: [],\n            variables: 0,\n            previous: this.program.frame,\n        };\n    }\n\n    protected popFrame(): RuntimeStackEntry[] {\n        const result = this.program.stack.slice(this.program.frame.startIndex + this.program.frame.variables + 1, this.program.stackPointer + 1);\n        this.program.stackPointer = this.program.frame.startIndex;\n        if (this.program.frame.previous) this.program.frame = this.program.frame.previous;\n        return result;\n    }\n\n    /**\n     * Create a new stack frame with the calling convention.\n     */\n    protected call(program: number, jumpBackTo: number = 1): void {\n        this.push(this.program.program + jumpBackTo); //the `return address`\n        this.pushFrame();\n        // process.stdout.write(`[${this.program.frame.index}] call ${program}\\n`);\n        this.program.program = program - 1; //-1 because next iteration does program++\n    }\n\n    /**\n     * Removes the stack frame, and puts the latest entry on the stack.\n     */\n    protected returnFrame(): void {\n        const returnValue = this.pop(); //latest entry on the stack is the return value\n        const returnAddress = this.program.stack[this.program.frame.startIndex]; //startIndex points the to new frame - 1 position, which is the `return address`.\n        // process.stdout.write(`[${this.program.frame.index}] return ${returnAddress}\\n`);\n        this.program.stackPointer = this.program.frame.startIndex - 1; //-1 because call convention adds `return address` before entering new frame\n        this.push(returnValue);\n        if ('number' === typeof returnAddress) this.program.program = returnAddress - 1; //-1 because iteration does program++\n        if (this.program.frame.previous) this.program.frame = this.program.frame.previous;\n    }\n\n    protected pushType(type: Type): void {\n        this.push(type);\n    }\n\n    protected eatParameter(): RuntimeStackEntry {\n        return this.program.ops[++this.program.program];\n    }\n}\n\nfunction typeInferFromContainer(container: Iterable<any>): Type {\n    const union: TypeUnion = { kind: ReflectionKind.union, types: [] };\n    for (const item of container) {\n        const type = widenLiteral(typeInfer(item));\n        if (!isTypeIncluded(union.types, type)) union.types.push(type);\n    }\n\n    return union.types.length === 0 ? { kind: ReflectionKind.any } : union.types.length === 1 ? union.types[0] : union;\n}\n\nexport function typeInfer(value: any): Type {\n    if ('string' === typeof value || 'number' === typeof value || 'boolean' === typeof value || 'bigint' === typeof value || 'symbol' === typeof value) {\n        return { kind: ReflectionKind.literal, literal: value };\n    } else if (null === value) {\n        return { kind: ReflectionKind.null };\n    } else if (undefined === value) {\n        return { kind: ReflectionKind.undefined };\n    } else if (value instanceof RegExp) {\n        return { kind: ReflectionKind.literal, literal: value };\n    } else if ('function' === typeof value) {\n        if (isArray(value.__type)) {\n            //with emitted types: function or class\n            //don't use resolveRuntimeType since we don't allow cache here\n            // console.log('typeInfer of', value.name);\n            return Processor.get().reflect(value, undefined, { inline: true }) as Type;\n        }\n\n        if (isClass(value)) {\n            //unknown class\n            return { kind: ReflectionKind.class, classType: value as ClassType, types: [] };\n        }\n\n        return { kind: ReflectionKind.function, function: value, name: value.name, return: { kind: ReflectionKind.any }, parameters: [] };\n    } else if (isArray(value)) {\n        return { kind: ReflectionKind.array, type: typeInferFromContainer(value) };\n    } else if ('object' === typeof value) {\n        const constructor = value.constructor;\n        if ('function' === typeof constructor && constructor !== Object && isArray(constructor.__type)) {\n            //with emitted types\n            //don't use resolveRuntimeType since we don't allow cache here\n            return Processor.get().reflect(constructor, undefined, { inline: true }) as Type;\n        }\n\n        if (constructor === RegExp) return { kind: ReflectionKind.regexp };\n        if (constructor === Date) return { kind: ReflectionKind.class, classType: Date, types: [] };\n        if (constructor === Set) {\n            const type = typeInferFromContainer(value);\n            return { kind: ReflectionKind.class, classType: Set, arguments: [type], types: [] };\n        }\n\n        if (constructor === Map) {\n            const keyType = typeInferFromContainer((value as Map<any, any>).keys());\n            const valueType = typeInferFromContainer((value as Map<any, any>).values());\n            return { kind: ReflectionKind.class, classType: Map, arguments: [keyType, valueType], types: [] };\n        }\n\n        //generate a new program that builds a objectLiteral. This is necessary since typeInfer() with its Processor.reflect() calls might return immediately TypeAny if\n        //the execution was scheduled (if we are in an executing program) so we can not depend on the result directly.\n        //each part of the program of a value[i] is executed after the current OP, so we have to schedule new OPs doing the same as\n        //in this loop here and construct the objectLiteral in the VM.\n        const resultType: TypeObjectLiteral = { kind: ReflectionKind.objectLiteral, id: state.nominalId++, types: [] };\n        const ops: ReflectionOp[] = [];\n        const stack: RuntimeStackEntry[] = [];\n\n        for (const i in value) {\n            const indexTypeOfArg = stack.length;\n            stack.push(() => value[i]);\n            ops.push(ReflectionOp.typeof, indexTypeOfArg, ReflectionOp.widen);\n\n            const indexName = stack.length;\n            stack.push(i);\n            ops.push(ReflectionOp.propertySignature, indexName);\n        }\n\n        ops.push(ReflectionOp.objectLiteral);\n\n        return Processor.get().runProgram(createProgram({ ops, stack, resultType })) as Type;\n    }\n    return { kind: ReflectionKind.any };\n}\n\nfunction applyClassDecorators(type: TypeClass) {\n    if (!isWithDeferredDecorators(type.classType)) return;\n\n    for (const decorator of type.classType.__decorators) {\n        const { data, property, parameterIndexOrDescriptor } = decorator;\n\n        if (property !== undefined) {\n            const member = getMember(type, property);\n            if (!member) continue;\n\n            if (member.kind === ReflectionKind.propertySignature || member.kind === ReflectionKind.property) {\n                applyPropertyDecorator(member.type, data);\n            }\n\n            if ('number' === typeof parameterIndexOrDescriptor && (member.kind === ReflectionKind.method || member.kind === ReflectionKind.methodSignature)) {\n                const param = member.parameters[parameterIndexOrDescriptor];\n                if (param) {\n                    applyPropertyDecorator(param.type, data);\n                }\n            }\n        }\n    }\n}\n\nfunction applyPropertyDecorator(type: Type, data: TData) {\n    //map @t.validate to Validate<>\n    if (data.validators.length && isWithAnnotations(type)) {\n        const annotations = getAnnotations(type);\n        for (const validator of data.validators) {\n            validationAnnotation.register(annotations, {\n                name: 'function',\n                args: [{ kind: ReflectionKind.function, function: validator, parameters: [], return: { kind: ReflectionKind.any } }],\n            });\n        }\n    }\n}\n\nfunction collapseFunctionToMethod(member: TypePropertySignature | TypeMethodSignature): member is TypePropertySignature & { type: TypeMethodSignature } {\n    return member.kind === ReflectionKind.propertySignature && member.type.kind === ReflectionKind.function && member.type.function !== Function;\n}\n\nfunction pushObjectLiteralTypes(\n    type: TypeObjectLiteral,\n    types: (TypeIndexSignature | TypePropertySignature | TypeMethodSignature | TypeObjectLiteral | TypeCallSignature)[],\n) {\n    let annotations: Annotations = {};\n    const decorators: Type[] = [];\n\n    outer:\n        for (const member of types) {\n            if (member.kind === ReflectionKind.propertySignature && member.type.kind === ReflectionKind.never) continue;\n\n            if (member.kind === ReflectionKind.objectLiteral) {\n                //all `extends T` expression land at the beginning of the stack frame, and are always an objectLiteral.\n                //we use it as base and move its types first into types\n\n                //it might be a decorator\n                for (const decorator of typeDecorators) {\n                    if (decorator(annotations, member)) {\n                        decorators.push(member);\n                        continue outer;\n                    }\n                }\n\n                type.implements ||= [];\n                type.implements.push(member);\n\n                pushObjectLiteralTypes(type, member.types);\n\n                //redirect decorators\n                if (member.decorators) {\n                    decorators.push(...member.decorators);\n                }\n                if (member.annotations) {\n                    annotations = Object.assign(member.annotations, annotations);\n                }\n            } else if (member.kind === ReflectionKind.indexSignature) {\n                //note: is it possible to overwrite an index signature?\n                type.types.push(member);\n            } else if (member.kind === ReflectionKind.propertySignature || member.kind === ReflectionKind.methodSignature) {\n                const toAdd = collapseFunctionToMethod(member) ? {\n                    kind: ReflectionKind.methodSignature,\n                    name: member.name,\n                    optional: member.optional,\n                    parameters: member.type.parameters,\n                    return: member.type.return,\n                } as TypeMethodSignature : member;\n\n                const existing = type.types.findIndex(v => (v.kind === ReflectionKind.propertySignature || v.kind === ReflectionKind.methodSignature) && v.name === toAdd.name);\n                if (existing !== -1) {\n                    //remove entry, since we replace it\n                    type.types.splice(existing, 1, toAdd);\n                } else {\n                    type.types.push(toAdd);\n                }\n            } else if (member.kind === ReflectionKind.callSignature) {\n                type.types.push(member);\n            }\n        }\n\n    type.annotations = type.annotations || {};\n    if (decorators.length) type.decorators = decorators;\n\n    Object.assign(type.annotations, annotations);\n}\n\nexport function getEnumType(values: any[]): Type {\n    let allowUndefined = false;\n    let allowNull = false;\n    let allowString = false;\n    let allowNumber = false;\n\n    for (const v of values) {\n        if (v === undefined) allowUndefined = true;\n        if (v === null) allowNull = true;\n        if (typeof v === 'number') allowNumber = true;\n        if (typeof v === 'string') allowString = true;\n    }\n\n    const union: TypeUnion = { kind: ReflectionKind.union, types: [] };\n    if (allowString) union.types.push({ kind: ReflectionKind.string });\n    if (allowNumber) union.types.push({ kind: ReflectionKind.number });\n    if (allowNull) union.types.push({ kind: ReflectionKind.null });\n    if (allowUndefined) union.types.push({ kind: ReflectionKind.undefined });\n\n    return unboxUnion(union);\n}\n\nfunction resolveFunction<T extends Function>(fn: T, forObject: any): any {\n    try {\n        return fn();\n    } catch (error) {\n        return undefined;\n        // throw new Error(`Could not resolve function of object ${getClassName(forObject)} via ${fn.toString()}: ${error}`);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7961, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7967, "column": 0}, "map": {"version":3,"file":"utils.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/utils.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport { stringify, v4 } from 'uuid';\n\nexport class NoTypeReceived extends Error {\n    constructor(message: string = 'No type information received. Circular import or no runtime type available.') {\n        super(message);\n    }\n}\n\n/**\n * Returns a new UUID v4 as string.\n */\nexport function uuid(): string {\n    return v4();\n}\n\n/**\n * Writes a new uuid v4 into an existing buffer, and returns the same buffer.\n */\nexport function writeUuid(buffer: Uint8Array, offset: number = 0): Uint8Array {\n    v4(undefined, buffer, offset);\n    return buffer;\n}\n\n/**\n * Stringify an exising Uint8Array buffer.\n */\nexport function stringifyUuid(buffer: Uint8Array, offset: number = 0): string {\n    return stringify(buffer, offset);\n}\n\nexport type Binary = ArrayBuffer | Uint8Array | Int8Array | Uint8ClampedArray | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array;\n\nexport type JSONPartial<T> = T extends Date ? string :\n    T extends Array<infer K> ? Array<JSONPartial<K>> :\n        // T extends TypedArrays ? string :\n        T extends Binary ? string :\n            T extends object ? JSONPartialObject<T> :\n                T extends string ? number | T :\n                    T extends boolean ? number | string | T :\n                        T extends bigint ? number | string | T :\n                            T extends number ? bigint | string | T :\n                                T;\n\nexport type JSONPartialObject<T> = { [name in keyof T]?: T[name] | null };\n\nexport type JSONSingle<T> = T extends Date ? string | Date :\n    T extends Array<infer K> ? Array<JSONSingle<K>> :\n        T extends Binary ? string :\n            T extends object ? JSONEntity<T> :\n                T extends string ? string | number | boolean | undefined :\n                    T extends boolean ? T | number | string :\n                        T extends number ? T | string : T;\nexport type JSONEntity<T> = { [name in keyof T]: JSONSingle<T[name]> };\n\n// export type AnyEntitySingle<T> =\n//     T extends Array<infer K> ? Array<AnyEntitySingle<K>> :\n//     T extends TypedArrays ? any :\n//     T extends ArrayBuffer ? any :\n//     T extends object ? AnyEntity<T> :\n//     T extends string ? any :\n//     T extends boolean ? any :\n//     T extends number ? any : any;\n// export type AnyEntity<T> = { [name in keyof T & string]: AnyEntitySingle<ExtractPrimaryKeyOrReferenceType<T[name]>> };\n//\n// export type JSONPatch<T> = { [name in keyof T & string]: JSONSingle<T[name]> } | { [name: string]: any };\n//\n// export type FlattenIfArray<T> = T extends Array<any> ? T[0] : T;\n//\n// export type ExtractClassType<T, A = never> = T extends ClassType<infer K> ? K :\n//     T extends ClassSchema<infer K> ? K : A;\n//\n// export type PlainOrFullEntityFromClassTypeOrSchema<T> = { [name: string]: any } | JSONPartial<ExtractClassType<T>> | ExtractClassType<T>;\n\nexport function regExpFromString(v: string): RegExp {\n    if (v[0] === '/') {\n        const end = v.lastIndexOf('/');\n        const regexp = v.slice(1, end);\n        const modifiers = v.slice(1 + end);\n        return new RegExp(regexp, modifiers);\n    }\n    return new RegExp(v);\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;GAQG;;;;;;;;;;;;AAEH,OAAO,EAAE,SAAS,EAAE,EAAE,EAAE,MAAM,MAAM,CAAC;;;AAE/B,MAAO,cAAe,SAAQ,KAAK;IACrC,YAAY,UAAkB,6EAA6E,CAAA;QACvG,KAAK,CAAC,OAAO,CAAC,CAAC;IACnB,CAAC;;;;;;;;;;AAMC,SAAU,IAAI;IAChB,8LAAO,KAAA,AAAE,EAAE,CAAC;AAChB,CAAC;;;;;AAKK,SAAU,SAAS,CAAC,MAAkB,EAAE,SAAiB,CAAC;2LAC5D,KAAA,AAAE,EAAC,SAAS,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IAC9B,OAAO,MAAM,CAAC;AAClB,CAAC;;;;;;;;AAKK,SAAU,aAAa,CAAC,MAAkB,EAAE,SAAiB,CAAC;IAChE,OAAO,iNAAA,AAAS,EAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AACrC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CK,SAAU,gBAAgB,CAAC,CAAS;IACtC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;QACf,MAAM,GAAG,GAAG,CAAC,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QAC/B,MAAM,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;QAC/B,MAAM,SAAS,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;QACnC,OAAO,IAAI,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IACzC,CAAC;IACD,OAAO,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC"}},
    {"offset": {"line": 8081, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8087, "column": 0}, "map": {"version":3,"file":"inheritance.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/inheritance.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\n// import { ClassSchema, PropertySchema } from './model.js';\n//\n//\n// export function findCommonDiscriminant(classSchemas: ClassSchema[]): string | undefined {\n//     //check if all discriminators are correct\n//     let discriminatorFound: { schema: ClassSchema, property: PropertySchema } | undefined;\n//     for (const schema of classSchemas) {\n//         if (discriminatorFound && !schema.discriminant) {\n//             throw new Error(`${discriminatorFound.schema.getClassName()} has a discriminant on '${discriminatorFound.property.name}' but ${schema.getClassName()} has none.`);\n//         }\n//\n//         if (discriminatorFound && schema.discriminant && schema.discriminant !== discriminatorFound.property.name) {\n//             throw new Error(`${discriminatorFound.schema.getClassName()} has a discriminant on '${discriminatorFound.property.name}' but ${schema.getClassName()} has one on '${schema.discriminant}'.`);\n//         }\n//\n//         if (!discriminatorFound && schema.discriminant) {\n//             discriminatorFound = { schema: schema, property: schema.getProperty(schema.discriminant) };\n//         }\n//     }\n//\n//     return discriminatorFound ? discriminatorFound.property.name : undefined;\n// }\n\nimport { ReflectionClass } from './reflection/reflection.js';\nimport { ReflectionKind } from './reflection/type.js';\n\nexport function findCommonLiteral(reflectionClasses: ReflectionClass<any>[]): string | undefined {\n    const candidates: { [name: string]: { found: number, values: any[], schemas: ReflectionClass<any>[] } } = {};\n\n    for (const schema of reflectionClasses) {\n        for (const property of schema.getProperties()) {\n            if (property.type.kind !== ReflectionKind.literal) continue;\n\n            if (candidates[property.name]) {\n                let candidate = candidates[property.name];\n                candidate.found++;\n                if (candidate.values.includes(property.type.literal)) {\n                    const usedBy = candidate.schemas[candidate.values.indexOf(property.type.literal)];\n                    if (usedBy !== schema) {\n                        throw new Error(`${schema.getClassName()} has a literal on ${property.name} that is already used by ${usedBy.getClassName()}.`);\n                    }\n                }\n                candidate.values.push(property.type.literal);\n                candidate.schemas.push(schema);\n            } else {\n                candidates[property.name] = { found: 1, values: [property.type.literal], schemas: [schema] };\n            }\n        }\n    }\n\n    //check which candidate has the right amount of usages\n    for (const [name, info] of Object.entries(candidates)) {\n        if (info.found === reflectionClasses.length) return name;\n    }\n\n    return;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;GAQG,CAEH,4DAA4D;AAC5D,EAAE;AACF,EAAE;AACF,4FAA4F;AAC5F,gDAAgD;AAChD,6FAA6F;AAC7F,2CAA2C;AAC3C,4DAA4D;AAC5D,iLAAiL;AACjL,YAAY;AACZ,EAAE;AACF,uHAAuH;AACvH,4MAA4M;AAC5M,YAAY;AACZ,EAAE;AACF,4DAA4D;AAC5D,0GAA0G;AAC1G,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,gFAAgF;AAChF,IAAI;;;;AAEJ,OAAO,EAAE,eAAe,EAAE,MAAM,4BAA4B,CAAC;AAC7D,OAAO,EAAE,cAAc,EAAE,MAAM,sBAAsB,CAAC;;;AAEhD,SAAU,iBAAiB,CAAC,iBAAyC;IACvE,MAAM,UAAU,GAA0F,CAAA,CAAE,CAAC;IAE7G,KAAK,MAAM,MAAM,IAAI,iBAAiB,CAAE,CAAC;QACrC,KAAK,MAAM,QAAQ,IAAI,MAAM,CAAC,aAAa,EAAE,CAAE,CAAC;YAC5C,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,mLAAK,iBAAc,CAAC,OAAO,EAAE,SAAS;YAE5D,IAAI,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC5B,IAAI,SAAS,GAAG,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAC1C,SAAS,CAAC,KAAK,EAAE,CAAC;gBAClB,IAAI,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;oBACnD,MAAM,MAAM,GAAG,SAAS,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;oBAClF,IAAI,MAAM,KAAK,MAAM,EAAE,CAAC;wBACpB,MAAM,IAAI,KAAK,CAAC,GAAG,MAAM,CAAC,YAAY,EAAE,CAAA,kBAAA,EAAqB,QAAQ,CAAC,IAAI,CAAA,yBAAA,EAA4B,MAAM,CAAC,YAAY,EAAE,CAAA,CAAA,CAAG,CAAC,CAAC;oBACpI,CAAC;gBACL,CAAC;gBACD,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC7C,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACnC,CAAC,MAAM,CAAC;gBACJ,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG;oBAAE,KAAK,EAAE,CAAC;oBAAE,MAAM,EAAE;wBAAC,QAAQ,CAAC,IAAI,CAAC,OAAO;qBAAC;oBAAE,OAAO,EAAE;wBAAC,MAAM;qBAAC;gBAAA,CAAE,CAAC;YACjG,CAAC;QACL,CAAC;IACL,CAAC;IAED,sDAAsD;IACtD,KAAK,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAE,CAAC;QACpD,IAAI,IAAI,CAAC,KAAK,KAAK,iBAAiB,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC;IAC7D,CAAC;IAED,OAAO;AACX,CAAC"}},
    {"offset": {"line": 8165, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8171, "column": 0}, "map": {"version":3,"file":"type-serialization.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/type-serialization.ts"],"sourcesContent":["import {\n    entityAnnotation,\n    EntityOptions,\n    findMember,\n    isSameType,\n    isTypeIncluded,\n    isWithAnnotations,\n    ReflectionKind,\n    ReflectionVisibility,\n    Type,\n    TypeArray,\n    TypeClass,\n    typeDecorators,\n    TypeEnum,\n    TypeFunction,\n    TypeIndexSignature,\n    TypeLiteral,\n    TypeObjectLiteral,\n    TypeParameter,\n    TypeProperty,\n    TypeRest,\n    TypeTuple,\n    TypeTupleMember\n} from './reflection/type.js';\nimport { getClassName, getParentClass } from '@deepkit/core';\nimport { reflect, ReflectionClass, typeOf } from './reflection/reflection.js';\nimport { typeSettings } from './core.js';\nimport { regExpFromString } from './utils.js';\n\nexport interface SerializedTypeAnnotations {\n    entityOptions?: EntityOptions;\n\n    typeName?: string;\n\n    typeArguments?: SerializedTypeReference[];\n\n    indexAccessOrigin?: { container: SerializedTypeReference, index: SerializedTypeReference };\n\n    // annotations will be generated on deserialization from the decorators\n    // annotations?: Annotations; //parsed decorator types as annotations\n\n    decorators?: SerializedTypeReference[]; //original decorator type\n}\n\ninterface SerializedTypeObjectLiteral extends SerializedTypeAnnotations {\n    kind: ReflectionKind.objectLiteral,\n    types: SerializedTypeReference[];\n}\n\ninterface SerializedTypeClassType extends SerializedTypeAnnotations {\n    kind: ReflectionKind.class,\n    name?: string; //@entity.name\n    globalObject?: true; //Uint8Array, Date, etc\n    classType: string; //getClassName result\n    extendsArguments?: SerializedTypeReference[];\n    arguments?: SerializedTypeReference[];\n    superClass?: SerializedTypeReference;\n    types: SerializedTypeReference[];\n}\n\ninterface SerializedTypeFunction extends SerializedTypeAnnotations {\n    kind: ReflectionKind.function,\n    name?: number | string | symbol,\n    parameters: SerializedTypeParameter[];\n    return: SerializedTypeReference;\n}\n\ntype SerializedTypeReference = number;\n\ninterface SimpleSerializedType extends SerializedTypeAnnotations {\n    kind: ReflectionKind.never | ReflectionKind.any | ReflectionKind.unknown | ReflectionKind.void | ReflectionKind.object | ReflectionKind.string\n        | ReflectionKind.number | ReflectionKind.boolean | ReflectionKind.symbol | ReflectionKind.bigint | ReflectionKind.null | ReflectionKind.undefined | ReflectionKind.regexp;\n    origin?: SerializedTypeReference;\n}\n\ninterface SerializedTypeLiteral extends SerializedTypeAnnotations {\n    kind: ReflectionKind.literal,\n    literal: { type: 'symbol', name: string } | string | number | boolean | { type: 'bigint', value: string } | { type: 'regex', regex: string };\n}\n\ninterface SerializedTypeTemplateLiteral extends SerializedTypeAnnotations {\n    kind: ReflectionKind.templateLiteral,\n    types: SerializedTypeReference[]\n}\n\ninterface SerializedTypeParameter extends SerializedTypeAnnotations {\n    kind: ReflectionKind.parameter,\n    name: string;\n    type: SerializedTypeReference;\n\n    //parameter could be a property as well if visibility is set\n    visibility?: ReflectionVisibility,\n    readonly?: true;\n    optional?: true,\n\n    /**\n     * Set when the parameter has a default value aka initializer.\n     */\n    default?: true\n}\n\nexport interface SerializedTypeBaseMember extends SerializedTypeAnnotations {\n    visibility: ReflectionVisibility,\n    abstract?: true;\n    optional?: true,\n    readonly?: true;\n}\n\nexport interface SerializedTypeMethod extends SerializedTypeBaseMember {\n    kind: ReflectionKind.method,\n    visibility: ReflectionVisibility,\n    name: number | string | symbol;\n    parameters: SerializedTypeParameter[];\n    optional?: true,\n    abstract?: true;\n    return: SerializedTypeReference;\n}\n\ninterface SerializedTypeProperty extends SerializedTypeBaseMember {\n    kind: ReflectionKind.property,\n    visibility: ReflectionVisibility,\n    name: number | string | symbol;\n    optional?: true,\n    readonly?: true;\n    abstract?: true;\n    description?: string;\n    type: SerializedTypeReference;\n\n    /**\n     * Set when the property has a default value aka initializer.\n     */\n    default?: true\n}\n\ninterface SerializedTypePromise extends SerializedTypeAnnotations {\n    kind: ReflectionKind.promise,\n    type: SerializedTypeReference;\n}\n\ninterface SerializedTypeEnum extends SerializedTypeAnnotations {\n    kind: ReflectionKind.enum,\n    enum: { [name: string]: string | number | undefined | null };\n    values: (string | number | undefined | null)[];\n    indexType: SerializedTypeReference;\n}\n\nexport interface SerializedTypeUnion extends SerializedTypeAnnotations {\n    kind: ReflectionKind.union,\n    types: SerializedTypeReference[];\n}\n\nexport interface SerializedTypeIntersection extends SerializedTypeAnnotations {\n    kind: ReflectionKind.intersection,\n    types: SerializedTypeReference[];\n}\n\ninterface SerializedTypeArray extends SerializedTypeAnnotations {\n    kind: ReflectionKind.array,\n    type: SerializedTypeReference;\n}\n\ninterface SerializedTypeIndexSignature extends SerializedTypeAnnotations {\n    kind: ReflectionKind.indexSignature,\n    index: SerializedTypeReference;\n    type: SerializedTypeReference;\n}\n\ninterface SerializedTypePropertySignature extends SerializedTypeAnnotations {\n    kind: ReflectionKind.propertySignature,\n    name: number | string | symbol;\n    optional?: true;\n    readonly?: true;\n    description?: string;\n    type: SerializedTypeReference;\n}\n\ninterface SerializedTypeMethodSignature extends SerializedTypeAnnotations {\n    kind: ReflectionKind.methodSignature,\n    name: number | string | symbol;\n    optional?: true;\n    parameters: SerializedTypeParameter[];\n    return: SerializedTypeReference;\n}\n\nexport interface SerializedTypeTypeParameter extends SerializedTypeAnnotations {\n    kind: ReflectionKind.typeParameter,\n    name: string,\n}\n\ninterface SerializedTypeInfer extends SerializedTypeAnnotations {\n    kind: ReflectionKind.infer,\n}\n\ninterface SerializedTypeTupleMember extends SerializedTypeAnnotations {\n    kind: ReflectionKind.tupleMember,\n    type: SerializedTypeReference;\n    optional?: true;\n    name?: string;\n}\n\ninterface SerializedTypeTuple extends SerializedTypeAnnotations {\n    kind: ReflectionKind.tuple,\n    types: SerializedTypeTupleMember[]\n}\n\ninterface SerializedTypeRest extends SerializedTypeAnnotations {\n    kind: ReflectionKind.rest,\n    type: SerializedTypeReference,\n}\n\nexport type SerializedType =\n    SimpleSerializedType\n    | SerializedTypeLiteral\n    | SerializedTypeTemplateLiteral\n    | SerializedTypeParameter\n    | SerializedTypeFunction\n    | SerializedTypeMethod\n    | SerializedTypeProperty\n    | SerializedTypePromise\n    | SerializedTypeClassType\n    | SerializedTypeEnum\n    | SerializedTypeUnion\n    | SerializedTypeIntersection\n    | SerializedTypeArray\n    | SerializedTypeObjectLiteral\n    | SerializedTypeIndexSignature\n    | SerializedTypePropertySignature\n    | SerializedTypeMethodSignature\n    | SerializedTypeTypeParameter\n    | SerializedTypeInfer\n    | SerializedTypeTuple\n    | SerializedTypeTupleMember\n    | SerializedTypeRest;\n\nexport type SerializedTypes = SerializedType[];\n\nconst envGlobal: any = typeof globalThis !== \"undefined\"\n    ? globalThis\n    : typeof global !== \"undefined\"\n    ? global\n    : window;\n\nfunction isWithSerializedAnnotations(type: any): type is SerializedTypeAnnotations {\n    return isWithAnnotations(type);\n}\n\nexport interface SerializerState {\n    types: SerializedTypes;\n    disableMethods?: true;\n    refs: Map<Type, number>;\n}\n\nfunction filterRemoveFunctions(v: Type): boolean {\n    return v.kind !== ReflectionKind.function && v.kind !== ReflectionKind.method && v.kind !== ReflectionKind.methodSignature;\n}\n\nfunction exportEntityOptions(type: TypeClass | TypeObjectLiteral, result: SerializedType): void {\n    const reflection = ReflectionClass.from(type);\n\n    let changed = false;\n    const entityAttributes: EntityOptions = {};\n    if (reflection.name !== undefined) {\n        changed = true;\n        entityAttributes.name = reflection.name;\n    }\n    if (reflection.description) {\n        changed = true;\n        entityAttributes.description = reflection.description;\n    }\n    if (reflection.databaseSchemaName !== undefined) {\n        changed = true;\n        entityAttributes.database = reflection.databaseSchemaName;\n    }\n    if (reflection.collectionName !== undefined) {\n        changed = true;\n        entityAttributes.collection = reflection.collectionName;\n    }\n    if (reflection.singleTableInheritance) {\n        changed = true;\n        entityAttributes.singleTableInheritance = reflection.singleTableInheritance;\n    }\n    if (reflection.indexes.length) {\n        changed = true;\n        entityAttributes.indexes = reflection.indexes;\n    }\n\n    if (changed) {\n        result.entityOptions = entityAttributes;\n    }\n}\n\nfunction assignEntityOptions(type: TypeClass | TypeObjectLiteral, serialized: SerializedType): void {\n    if (!serialized.entityOptions) return;\n    const entity = entityAnnotation.getFirst(type) || {};\n\n    if (serialized.entityOptions.name !== undefined) entity.name = serialized.entityOptions.name;\n    if (serialized.entityOptions.description !== undefined) entity.description = serialized.entityOptions.description;\n    if (serialized.entityOptions.database !== undefined) entity.database = serialized.entityOptions.database;\n    if (serialized.entityOptions.collection !== undefined) entity.collection = serialized.entityOptions.collection;\n    if (serialized.entityOptions.singleTableInheritance !== undefined) entity.singleTableInheritance = serialized.entityOptions.singleTableInheritance;\n    if (serialized.entityOptions.indexes !== undefined) entity.indexes = serialized.entityOptions.indexes;\n\n    entityAnnotation.replaceType(type, [entity]);\n}\n\nfunction serialize(type: Type, state: SerializerState): SerializedTypeReference {\n    const serialized = state.refs.get(type);\n    if (serialized) return serialized;\n\n    const result: SerializedType = { kind: type.kind } as SerializedType;\n\n    state.types.push(result);\n    const index = state.types.length - 1;\n    state.refs.set(type, index);\n\n    if (type.typeName) result.typeName = type.typeName;\n    if (type.decorators) (result as SerializedTypeAnnotations).decorators = type.decorators.map(v => serialize(v, state));\n    if (type.typeArguments) (result as SerializedTypeAnnotations).typeArguments = type.typeArguments.map(v => serialize(v, state));\n    if (type.indexAccessOrigin) (result as SerializedTypeAnnotations).indexAccessOrigin = {\n        index: serialize(type.indexAccessOrigin.index, state),\n        container: serialize(type.indexAccessOrigin.container, state)\n    };\n\n    switch (type.kind) {\n        case ReflectionKind.objectLiteral: {\n            if (type.typeName && type.typeName.startsWith('Type')) {\n                //make sure that Type types are not serialized, as they are way too expensive and\n                //there is no need to actually serialize them.\n                const typeType = typeOf<Type>();\n                if (typeType.kind === ReflectionKind.union && isTypeIncluded(typeType.types, type)) {\n                    Object.assign(result, {\n                        kind: ReflectionKind.any,\n                    });\n                    break;\n                }\n            }\n\n            const types = state.disableMethods ? type.types.filter(filterRemoveFunctions) : type.types;\n            Object.assign(result, {\n                kind: ReflectionKind.objectLiteral,\n                types: types.map(member => serialize(member, state)),\n            } as SerializedTypeObjectLiteral);\n            exportEntityOptions(type, result);\n            break;\n        }\n        case ReflectionKind.class: {\n            const types = state.disableMethods ? type.types.filter(filterRemoveFunctions) : type.types;\n            const parent = getParentClass(type.classType);\n            let superClass: SerializedTypeReference | undefined = undefined;\n            try {\n                superClass = parent ? serialize(reflect(parent), state) : undefined;\n            } catch {\n            }\n\n            const classType = getClassName(type.classType);\n            const globalObject: boolean = envGlobal && envGlobal[classType] === type.classType;\n\n            Object.assign(result, {\n                kind: ReflectionKind.class,\n                types: types.map(member => serialize(member, state)),\n                name: ReflectionClass.from(type.classType).name,\n                globalObject: globalObject ? true : undefined,\n                classType,\n                arguments: type.arguments ? type.arguments.map(member => serialize(member, state)) : undefined,\n                extendsArguments: type.extendsArguments ? type.extendsArguments.map(member => serialize(member, state)) : undefined,\n                superClass,\n            } as SerializedTypeClassType);\n            exportEntityOptions(type, result);\n            break;\n        }\n        case ReflectionKind.literal: {\n            Object.assign(result, {\n                kind: ReflectionKind.literal,\n                literal: 'symbol' === typeof type.literal ? { type: 'symbol', name: type.literal.toString().slice(7, -1) } :\n                    'bigint' === typeof type.literal ? { type: 'bigint', value: String(type.literal) } :\n                        type.literal instanceof RegExp ? { type: 'regex', regex: String(type.literal) } :\n                            type.literal\n            } as SerializedTypeLiteral);\n            break;\n        }\n        case ReflectionKind.tuple: {\n            Object.assign(result, {\n                kind: ReflectionKind.tuple,\n                types: type.types.map(member => ({ ...member, jit: undefined, parent: undefined, type: serialize(member.type, state) })),\n\n            } as SerializedTypeTuple);\n            break;\n        }\n        case ReflectionKind.union: {\n            if (type.typeName && type.typeName.startsWith('Type')) {\n                //make sure that Type types are not serialized, as they are way too expensive and\n                //there is no need to actually serialize them.\n                const typeType = typeOf<Type>();\n                if (isSameType(typeType, type)) {\n                    Object.assign(result, {\n                        kind: ReflectionKind.any,\n                    });\n                    break;\n                }\n            }\n\n            const types = state.disableMethods ? type.types.filter(filterRemoveFunctions) : type.types;\n            Object.assign(result, {\n                kind: ReflectionKind.union,\n                types: types.map(member => serialize(member, state)),\n\n            } as SerializedTypeUnion);\n            break;\n        }\n        case ReflectionKind.intersection: {\n            Object.assign(result, {\n                kind: ReflectionKind.intersection,\n                types: type.types.map(member => serialize(member, state)),\n\n            } as SerializedTypeIntersection);\n            break;\n        }\n        case ReflectionKind.templateLiteral: {\n            Object.assign(result, {\n                kind: ReflectionKind.templateLiteral,\n                types: type.types.map(member => serialize(member, state)),\n\n            } as SerializedTypeTemplateLiteral);\n            break;\n        }\n        case ReflectionKind.string:\n        case ReflectionKind.number:\n        case ReflectionKind.boolean:\n        case ReflectionKind.symbol:\n        case ReflectionKind.bigint:\n        case ReflectionKind.regexp: {\n            if (type.origin) (result as SimpleSerializedType).origin = serialize(type.origin, state);\n            break;\n        }\n        case ReflectionKind.function: {\n            if (state.disableMethods) {\n                result.kind = ReflectionKind.never;\n                break;\n            }\n            Object.assign(result, {\n                kind: ReflectionKind.function,\n                parameters: type.parameters.map(v => ({\n                    ...v,\n                    jit: undefined,\n                    parent: undefined,\n                    type: serialize(v.type, state),\n                    default: v.default !== undefined ? true : undefined\n                })),\n                return: serialize(type.return, state)\n            } as SerializedTypeFunction);\n            break;\n        }\n        case ReflectionKind.method: {\n            if (state.disableMethods) {\n                result.kind = ReflectionKind.never;\n                break;\n            }\n            Object.assign(result, {\n                ...type,\n                jit: undefined,\n                parent: undefined,\n                parameters: type.parameters.map(v => ({\n                    ...v,\n                    jit: undefined,\n                    parent: undefined,\n                    type: serialize(v.type, state),\n                    default: v.default !== undefined ? true : undefined\n                } as SerializedTypeParameter)),\n                return: serialize(type.return, state)\n            } as SerializedTypeMethod);\n            break;\n        }\n        case ReflectionKind.methodSignature: {\n            if (state.disableMethods) {\n                result.kind = ReflectionKind.never;\n                break;\n            }\n            Object.assign(result, {\n                ...type,\n                jit: undefined,\n                parent: undefined,\n                parameters: type.parameters.map(v => ({\n                    ...v,\n                    jit: undefined,\n                    parent: undefined,\n                    type: serialize(v.type, state),\n                    default: v.default !== undefined ? true : undefined\n                } as SerializedTypeParameter)),\n                return: serialize(type.return, state)\n            } as SerializedTypeMethodSignature);\n            break;\n        }\n        case ReflectionKind.propertySignature: {\n            Object.assign(result, {\n                ...type,\n                jit: undefined,\n                parent: undefined,\n                type: serialize(type.type, state),\n            } as SerializedTypePropertySignature);\n            break;\n        }\n        case ReflectionKind.property: {\n            Object.assign(result, {\n                ...type,\n                jit: undefined,\n                parent: undefined,\n                default: type.default !== undefined ? true : undefined,\n                type: serialize(type.type, state),\n            } as SerializedTypeProperty);\n            break;\n        }\n        case ReflectionKind.array: {\n            Object.assign(result, {\n                kind: ReflectionKind.array,\n                type: serialize(type.type, state),\n            } as SerializedTypeArray);\n            break;\n        }\n        case ReflectionKind.promise: {\n            Object.assign(result, {\n                kind: ReflectionKind.promise,\n                type: serialize(type.type, state),\n            } as SerializedTypePromise);\n            break;\n        }\n        case ReflectionKind.rest: {\n            Object.assign(result, {\n                kind: ReflectionKind.rest,\n                type: serialize(type.type, state),\n            } as SerializedTypeRest);\n            break;\n        }\n        case ReflectionKind.indexSignature: {\n            Object.assign(result, {\n                kind: ReflectionKind.indexSignature,\n                index: serialize(type.index, state),\n                type: serialize(type.type, state),\n            } as SerializedTypeIndexSignature);\n            break;\n        }\n        case ReflectionKind.enum: {\n            Object.assign(result, {\n                kind: ReflectionKind.enum,\n                enum: type.enum,\n                values: type.values,\n                indexType: serialize(type.indexType, state),\n            } as SerializedTypeEnum);\n            break;\n        }\n    }\n\n    return index;\n}\n\n/**\n * Converts a (possibly circular/nested) type into a JSON.stringify'able structure suited to be transmitted over the wire and deserialized back to the correct Type object.\n */\nexport function serializeType(type: Type, state: Partial<SerializerState> = {}): SerializedTypes {\n    const types: SerializedTypes = [];\n    const serializedState: SerializerState = { types, refs: new Map, ...state };\n    serialize(type, serializedState);\n    return types;\n}\n\ninterface DeserializeState {\n    types: SerializedTypes;\n    disableReuse?: boolean, //disable entity reuse from entities registered via @entity.name()\n    deserialized: { [index: number]: { type: Type, refs: Type[], active: boolean } };\n}\n\n/**\n * @reflection never\n */\nfunction deserialize(type: SerializedType | SerializedTypeReference, state: DeserializeState, parent?: Type): Type {\n    if ('number' === typeof type) {\n        if (!state.types[type]) return { kind: ReflectionKind.unknown };\n        const typeState = state.deserialized[type];\n        let result: Type = { kind: ReflectionKind.unknown };\n\n        if (typeState) {\n            if (typeState.active) {\n                typeState.refs.push(result);\n            } else {\n                result = typeState.type;\n            }\n        } else {\n            const typeState = { type: result as Type, refs: [], active: true };\n            state.deserialized[type] = typeState;\n            typeState.type = deserialize(state.types[type], state);\n            typeState.active = false;\n            for (const ref of typeState.refs) Object.assign(ref, typeState.type);\n            result = typeState.type;\n        }\n        if (parent) return Object.assign(result, { parent });\n\n        return result;\n    }\n    const result: Type = { kind: type.kind } as Type;\n\n    if (type.typeName) result.typeName = type.typeName;\n    if (type.typeArguments) result.typeArguments = type.typeArguments.map(v => deserialize(v, state)) as Type[];\n    if (type.indexAccessOrigin) result.indexAccessOrigin = {\n        index: deserialize(type.indexAccessOrigin.index, state) as Type,\n        container: deserialize(type.indexAccessOrigin.container, state) as TypeClass | TypeObjectLiteral\n    };\n\n    switch (type.kind) {\n        case ReflectionKind.objectLiteral: {\n            Object.assign(result, {\n                kind: ReflectionKind.objectLiteral,\n                types: type.types.map(v => deserialize(v, state, result))\n            } as TypeObjectLiteral);\n            assignEntityOptions(result as TypeObjectLiteral, type);\n            break;\n        }\n        case ReflectionKind.class: {\n            if (!state.disableReuse && type.name) {\n                const existing = typeSettings.registeredEntities[type.name];\n                if (existing) {\n                    Object.assign(result, ReflectionClass.from(existing).type);\n                    break;\n                }\n            }\n\n            const newClass = !type.globalObject && state.disableReuse === true || (!type.name || !typeSettings.registeredEntities[type.name]);\n\n            const args = type.arguments ? type.arguments.map(v => deserialize(v, state, result)) : undefined;\n            const extendsArguments = type.extendsArguments ? type.extendsArguments.map(v => deserialize(v, state, result)) : undefined;\n            const types = type.types.map(v => deserialize(v, state, result));\n            const constructor = findMember('constructor', types);\n            const initialize: { name: string, index: number }[] = [];\n            if (constructor && constructor.kind === ReflectionKind.method) {\n                for (let i = 0; i < constructor.parameters.length; i++) {\n                    if (constructor.parameters[i].visibility !== undefined) {\n                        initialize.push({ name: constructor.parameters[i].name, index: i });\n                    }\n                }\n            }\n\n            const classType = type.globalObject ? envGlobal[type.classType] : newClass\n                ? (type.superClass ? class extends (deserialize(type.superClass, state) as TypeClass).classType {\n                    constructor(...args: any[]) {\n                        super(...args);\n                        for (const init of initialize) {\n                            this[init.name] = args[init.index];\n                        }\n                    }\n                } : class {\n                    constructor(...args: any[]) {\n                        for (const init of initialize) {\n                            (this as any)[init.name] = args[init.index];\n                        }\n                    }\n                }) : typeSettings.registeredEntities[type.name!];\n\n            if (newClass && !type.globalObject) {\n                Object.defineProperty(classType, 'name', { value: type.classType, writable: true, enumerable: false });\n                if (!classType.__type) {\n                    classType.__type = [];\n                    classType.__type.__type = result;\n                }\n            }\n\n            Object.assign(result, {\n                kind: ReflectionKind.class,\n                classType,\n                arguments: args,\n                extendsArguments,\n                types,\n            } as TypeClass);\n            assignEntityOptions(result as TypeClass, type);\n            break;\n        }\n        case ReflectionKind.literal: {\n            Object.assign(result, {\n                kind: ReflectionKind.literal,\n                literal: 'string' === typeof type.literal ? type.literal : 'number' === typeof type.literal ? type.literal : 'boolean' === typeof type.literal ? type.literal :\n                    'symbol' === type.literal.type ? Symbol(type.literal.name) : 'bigint' === type.literal.type ? BigInt(type.literal.value) : 'regex' === type.literal.type ? regExpFromString(type.literal.regex) : false\n            } as TypeLiteral);\n            break;\n        }\n        case ReflectionKind.tuple: {\n            Object.assign(result, {\n                kind: ReflectionKind.tuple,\n                types: []\n            } as TypeTuple);\n            for (const member of type.types) {\n                const deserializedMember: TypeTupleMember = {\n                    ...member,\n                    typeArguments: undefined,\n                    indexAccessOrigin: undefined,\n                    decorators: undefined,\n                    parent: result as TypeTuple,\n                    type: { kind: ReflectionKind.unknown }\n                };\n                deserializedMember.type = deserialize(member.type, state, deserializedMember);\n                (result as TypeTuple).types.push(deserializedMember);\n            }\n            break;\n        }\n        case ReflectionKind.templateLiteral:\n        case ReflectionKind.intersection:\n        case ReflectionKind.union: {\n            Object.assign(result, {\n                kind: type.kind,\n                types: type.types.map(member => deserialize(member, state, result))\n            });\n            break;\n        }\n        case ReflectionKind.string:\n        case ReflectionKind.number:\n        case ReflectionKind.bigint:\n        case ReflectionKind.symbol:\n        case ReflectionKind.regexp:\n        case ReflectionKind.boolean: {\n            result.kind = type.kind;\n            if (type.origin) {\n                Object.assign(result, {\n                    origin: deserialize(type.origin, state, result)\n                });\n            }\n            break;\n        }\n        case ReflectionKind.any:\n        case ReflectionKind.unknown:\n        case ReflectionKind.void:\n        case ReflectionKind.undefined:\n        case ReflectionKind.null: {\n            //nothing to do\n            break;\n        }\n        case ReflectionKind.methodSignature:\n        case ReflectionKind.method:\n        case ReflectionKind.function: {\n            const parameters: TypeParameter[] = [];\n            for (const p of type.parameters) {\n                const parameter: TypeParameter = {\n                    ...p,\n                    typeArguments: undefined,\n                    indexAccessOrigin: undefined,\n                    decorators: undefined,\n                    parent: result as TypeFunction,\n                    default: p.default ? () => undefined : undefined,\n                    type: { kind: ReflectionKind.unknown }\n                };\n                parameter.type = deserialize(p.type, state, parameter) as Type;\n                parameters.push(parameter);\n            }\n            Object.assign(result, {\n                name: type.name,\n                parameters,\n                return: deserialize(type.return, state, result)\n            } as TypeFunction);\n            break;\n        }\n        case ReflectionKind.property:\n        case ReflectionKind.propertySignature: {\n            Object.assign(result, {\n                ...type,\n                default: type.kind === ReflectionKind.property ? type.default ? () => undefined : undefined : undefined,\n                type: deserialize(type.type, state, result),\n            } as TypeProperty);\n            break;\n        }\n        case ReflectionKind.array:\n        case ReflectionKind.promise:\n        case ReflectionKind.rest: {\n            Object.assign(result, {\n                type: deserialize(type.type, state, result)\n            } as TypeArray | TypeProperty | TypeRest);\n            break;\n        }\n        case ReflectionKind.indexSignature: {\n            Object.assign(result, {\n                index: deserialize(type.index, state, result),\n                type: deserialize(type.type, state, result)\n            } as TypeIndexSignature);\n            break;\n        }\n        case ReflectionKind.enum: {\n            Object.assign(result, {\n                enum: type.enum,\n                values: type.values,\n                indexType: deserialize(type.indexType, state, result),\n            } as TypeEnum);\n            break;\n        }\n    }\n\n    if (isWithSerializedAnnotations(type) && isWithAnnotations(result) && type.decorators) {\n        result.annotations ||= {};\n        for (const scheduledDecorator of type.decorators) {\n            for (const decorator of typeDecorators) {\n                const dec = deserialize(scheduledDecorator, state) as TypeObjectLiteral;\n                decorator(result.annotations, dec);\n            }\n        }\n    }\n    return result;\n}\n\nexport function deserializeType(types?: SerializedTypes, state: Partial<DeserializeState> = {}): Type {\n    if (!types || types.length === 0) return { kind: ReflectionKind.unknown };\n    return deserialize(types[0], { ...state, deserialized: {}, types });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9283, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9289, "column": 0}, "map": {"version":3,"file":"reflection.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/reflection/reflection.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport {\n    assertType,\n    autoIncrementAnnotation,\n    BackReferenceOptionsResolved,\n    clearTypeJitContainer,\n    copyAndSetParent,\n    dataAnnotation,\n    databaseAnnotation,\n    DatabaseFieldOptions,\n    embeddedAnnotation,\n    entityAnnotation,\n    EntityOptions,\n    excludedAnnotation,\n    getBackReferenceType,\n    getClassType,\n    getReferenceType,\n    getTypeJitContainer,\n    groupAnnotation,\n    hasMember,\n    indexAnnotation,\n    IndexOptions,\n    isBackReferenceType,\n    isReferenceType,\n    isType,\n    memberNameToString,\n    primaryKeyAnnotation,\n    ReferenceOptions,\n    ReflectionKind,\n    ReflectionVisibility,\n    stringifyResolvedType,\n    stringifyType,\n    Type,\n    TypeClass,\n    TypeFunction,\n    TypeMethod,\n    TypeMethodSignature,\n    TypeObjectLiteral,\n    TypeParameter,\n    TypeProperty,\n    TypePropertySignature,\n    TypeTemplateLiteral,\n} from './type.js';\nimport {\n    AbstractClassType,\n    arrayRemoveItem,\n    ClassType,\n    getClassName,\n    isArray,\n    isClass,\n    isFunction,\n    isGlobalClass,\n    isPrototypeOfBase,\n    stringifyValueWithType,\n} from '@deepkit/core';\nimport { Packed, resolvePacked, resolveRuntimeType } from './processor.js';\nimport { NoTypeReceived } from '../utils.js';\nimport { findCommonLiteral } from '../inheritance.js';\nimport type { ValidateFunction } from '../validator.js';\nimport { isWithDeferredDecorators } from '../decorator.js';\nimport { SerializedTypes, serializeType } from '../type-serialization.js';\n\n/**\n * Receives the runtime type of template argument.\n *\n * Use\n *\n * ```typescript\n *\n * function f<T>(type?: ReceiveType<T>): Type {\n *     return resolveReceiveType(type);\n * }\n *\n * ```\n */\nexport type ReceiveType<T> = Packed | Type | ClassType<T>;\n\nexport function resolveReceiveType(type?: Packed | Type | ClassType | AbstractClassType | ReflectionClass<any>): Type {\n    if (!type) throw new NoTypeReceived();\n    let typeFn: Function | undefined = undefined;\n\n    if (isArray(type)) {\n        if (type.__type) return type.__type;\n        // this is fast path for simple references to a type, e.g. cast<User>(), so that User is directly handled\n        // instead of running the VM to resolve to User first.\n        if (type[type.length - 1] === 'n!' || type[type.length - 1] === 'P7!') {\n            //n! represents a simple inline: [Op.inline, 0]\n            //P7! represents a class reference: [Op.Frame, Op.classReference, 0] (Op.Frame seems unnecessary)\n            typeFn = (type as any)[0] as Function | any;\n            type = (isFunction(typeFn) ? typeFn() : typeFn) as Packed | Type | ClassType | AbstractClassType | ReflectionClass<any> | undefined;\n            if (!type) {\n                throw new Error(`No type resolved for ${String(typeFn)}. Circular import or no runtime type available.`);\n            }\n        }\n    }\n\n    if (type instanceof ReflectionClass) return type.type;\n    if (isArray(type) && type.__type) return type.__type;\n    if (isType(type)) return type as Type;\n    if (isClass(type) || isGlobalClass(type)) {\n        if (!('__type' in type)) {\n            if ((type as any).__cached_type) return (type as any).__cached_type;\n            // disabled reflection for this class, so we return shallow TypeClass\n            return (type as any).__cached_type = {\n                kind: ReflectionKind.class,\n                classType: type as any,\n                types: [],\n            } as any;\n        }\n        return resolveRuntimeType(type) as Type;\n    }\n    return resolvePacked(type, undefined, { reuseCached: true });\n}\n\nexport function reflect(o: any, ...args: any[]): Type {\n    return resolveRuntimeType(o, args) as Type;\n}\n\nexport function reflectOrUndefined(o: any, ...args: any[]): Type | undefined {\n    try {\n        return resolveRuntimeType(o, args) as Type;\n    } catch (error: any) {\n        return undefined;\n    }\n}\n\nexport function valuesOf<T>(args: any[] = [], p?: ReceiveType<T>): (string | number | symbol | Type)[] {\n    const type = typeOf(args, p);\n    if (type.kind === ReflectionKind.union) {\n        return type.types.map(v => {\n            if (v.kind === ReflectionKind.literal) return v.literal;\n            return v;\n        }) as (string | number | symbol | Type)[];\n    }\n    if (type.kind === ReflectionKind.objectLiteral || type.kind === ReflectionKind.class) {\n        return type.types.map(v => {\n            if (v.kind === ReflectionKind.method) return v;\n            if (v.kind === ReflectionKind.property) return v.type;\n            if (v.kind === ReflectionKind.propertySignature) return v.type;\n            if (v.kind === ReflectionKind.methodSignature) return v;\n            return v;\n        }) as (string | number | symbol | Type)[];\n    }\n    return [];\n}\n\nexport function propertiesOf<T>(args: any[] = [], p?: ReceiveType<T>): (string | number | symbol | Type)[] {\n    const type = typeOf(args, p);\n    if (type.kind === ReflectionKind.objectLiteral || type.kind === ReflectionKind.class) {\n        return type.types.map(v => {\n            if (v.kind === ReflectionKind.method) return v.name;\n            if (v.kind === ReflectionKind.property) return v.name;\n            if (v.kind === ReflectionKind.propertySignature) return v.name;\n            if (v.kind === ReflectionKind.methodSignature) return v.name;\n            return v;\n        }) as (string | number | symbol | Type)[];\n    }\n    return [];\n}\n\nexport function getNominalId<T>(args: any[] = [], p?: ReceiveType<T>): number | undefined {\n    const t = typeOf(args, p);\n    if (t.kind === ReflectionKind.class || t.kind === ReflectionKind.objectLiteral) return t.id;\n    return;\n}\n\nexport function typeOf<T>(args: any[] = [], p?: ReceiveType<T>): Type {\n    if (p) {\n        return args.length > 0 ? resolveRuntimeType(p, args) : resolveReceiveType(p) as Type;\n    }\n\n    throw new Error('No type given');\n}\n\nexport function removeTypeName<T extends Type>(type: T): T {\n    const o = { ...type };\n    o.id = undefined;\n    o.typeName = undefined;\n    o.typeArguments = undefined;\n    return o;\n}\n\nexport function removeNominal<T extends Type | undefined | Type[]>(type: T): T {\n    if (!type) return type;\n    if (isArray(type)) {\n        return type.map(v => removeNominal(v)) as T;\n    } else {\n        if (type.kind === ReflectionKind.class || type.kind === ReflectionKind.objectLiteral) {\n            return { ...type, id: undefined };\n        }\n    }\n    return type;\n}\n\nexport function getProperty(type: TypeObjectLiteral | TypeClass, memberName: number | string | symbol): TypeProperty | TypePropertySignature | undefined {\n    for (const t of type.types) {\n        if ((t.kind === ReflectionKind.property || t.kind === ReflectionKind.propertySignature) && t.name === memberName) return t;\n    }\n    return;\n}\n\nexport function toSignature(type: TypeProperty | TypeMethod | TypePropertySignature | TypeMethodSignature): TypePropertySignature | TypeMethodSignature {\n    if (type.kind === ReflectionKind.propertySignature || type.kind === ReflectionKind.methodSignature) return type;\n    if (type.kind === ReflectionKind.property) {\n        return { ...type, parent: type.parent as any, kind: ReflectionKind.propertySignature };\n    }\n\n    return { ...type, parent: type.parent as any, kind: ReflectionKind.methodSignature };\n}\n\nexport function hasCircularReference(type: Type) {\n    const jit = getTypeJitContainer(type);\n    if (jit.hasCircularReference !== undefined) return jit.hasCircularReference;\n\n    let hasCircular = false;\n    visit(type, () => undefined, () => {\n        hasCircular = true;\n    });\n\n    return jit.hasCircularReference = hasCircular;\n}\n\nlet visitStackId: number = 0;\n\nfunction extendPath(path: string, member: Type): string {\n    let name: string | number | symbol | undefined = '';\n    if ('name' in member) {\n        name = member.name;\n    }\n    if (name === '' || name === undefined) return path;\n    if (path) return path + '.' + String(name);\n    return String(name);\n}\n\nexport function visit(type: Type, visitor: (type: Type, path: string) => false | void, onCircular?: () => void): void {\n    const stack: { type: Type, depth: number, path: string }[] = [];\n    stack.push({ type, depth: 0, path: '' });\n    const stackId: number = visitStackId++;\n\n    while (stack.length) {\n        const entry = stack.shift();\n        if (!entry) break;\n        const type = entry.type;\n\n        const jit = getTypeJitContainer(type);\n        if (jit.visitStack && jit.visitStack.id === stackId && jit.visitStack.depth < entry.depth) {\n            if (onCircular) onCircular();\n            return;\n        }\n        jit.visitStack = { id: stackId, depth: entry.depth };\n        if (visitor(type, entry.path) === false) return;\n\n        switch (type.kind) {\n            case ReflectionKind.objectLiteral:\n            case ReflectionKind.tuple:\n            case ReflectionKind.union:\n            case ReflectionKind.class:\n            case ReflectionKind.intersection:\n            case ReflectionKind.templateLiteral:\n                for (const member of type.types) stack.push({\n                    type: member,\n                    depth: entry.depth + 1,\n                    path: extendPath(entry.path, member),\n                });\n                break;\n            case ReflectionKind.string:\n            case ReflectionKind.number:\n            case ReflectionKind.bigint:\n            case ReflectionKind.symbol:\n            case ReflectionKind.regexp:\n            case ReflectionKind.boolean:\n                if (type.origin) stack.push({ type: type.origin, depth: entry.depth + 1, path: entry.path });\n                break;\n            case ReflectionKind.function:\n            case ReflectionKind.method:\n            case ReflectionKind.methodSignature:\n                stack.push({ type: type.return, depth: entry.depth + 1, path: entry.path });\n                for (const member of type.parameters) stack.push({\n                    type: member,\n                    depth: entry.depth + 1,\n                    path: extendPath(entry.path, member),\n                });\n                break;\n            case ReflectionKind.propertySignature:\n            case ReflectionKind.property:\n            case ReflectionKind.array:\n            case ReflectionKind.promise:\n            case ReflectionKind.parameter:\n            case ReflectionKind.tupleMember:\n            case ReflectionKind.rest:\n                stack.push({ type: type.type, depth: entry.depth + 1, path: entry.path });\n                break;\n            case ReflectionKind.indexSignature:\n                stack.push({ type: type.index, depth: entry.depth + 1, path: entry.path });\n                stack.push({ type: type.type, depth: entry.depth + 1, path: entry.path });\n                break;\n        }\n    }\n}\n\nfunction hasFunctionExpression(fn: Function): boolean {\n    let code = fn.toString();\n    if (code.startsWith('() => ')) code = code.slice('() => '.length);\n    if (code.startsWith('function () { return ')) {\n        code = code.slice('function () { return '.length);\n        if (code.endsWith('; }')) code = code.slice(0, -3);\n    }\n    if (code.startsWith('function() { return ')) {\n        code = code.slice('function() { return '.length);\n        if (code.endsWith('; }')) code = code.slice(0, -3);\n    }\n    if (code[0] === '\\'' && code[code.length - 1] === '\\'') return false;\n    if (code[0] === '\"' && code[code.length - 1] === '\"') return false;\n    if (code[0] === '`' && code[code.length - 1] === '`') return false;\n    return code.includes('(');\n}\n\n/**\n * @reflection never\n */\nexport class ReflectionParameter {\n    type: Type;\n\n    constructor(\n        public readonly parameter: TypeParameter,\n        public readonly reflectionFunction: ReflectionMethod | ReflectionFunction,\n    ) {\n        this.type = this.parameter.type;\n    }\n\n    getType(): Type {\n        return this.type;\n    }\n\n    getName(): string {\n        return this.parameter.name;\n    }\n\n    get name(): string {\n        return this.parameter.name;\n    }\n\n    isOptional(): boolean {\n        return this.parameter.optional === true;\n    }\n\n    hasDefault(): boolean {\n        return this.parameter.default !== undefined;\n    }\n\n    isValueRequired(): boolean {\n        if (this.hasDefault()) return false;\n\n        return !this.isOptional();\n    }\n\n    getDefaultValue(): any {\n        if (this.parameter.default !== undefined) {\n            return this.parameter.default();\n        }\n    }\n\n    hasDefaultFunctionExpression(): boolean {\n        return !!(this.parameter.default && hasFunctionExpression(this.parameter.default));\n    }\n\n    applyDecorator(t: TData) {\n        if (t.type) {\n            this.type = resolveReceiveType(t.type);\n            if (this.getVisibility() !== undefined && this.reflectionFunction instanceof ReflectionMethod) {\n                this.reflectionFunction.reflectionClass.getProperty(this.getName())!.setType(this.type);\n            }\n        }\n    }\n\n    getVisibility(): ReflectionVisibility | undefined {\n        return this.parameter.visibility;\n    }\n\n    isPublic(): boolean {\n        return this.parameter.visibility === ReflectionVisibility.public;\n    }\n\n    isProtected(): boolean {\n        return this.parameter.visibility === ReflectionVisibility.protected;\n    }\n\n    isPrivate(): boolean {\n        return this.parameter.visibility === ReflectionVisibility.private;\n    }\n\n    isReadonly(): boolean {\n        return this.parameter.readonly === true;\n    }\n\n    /**\n     * True if the parameter becomes a property in the class.\n     * This is the case for parameters in constructors with visibility or readonly.\n     *\n     * ```typescript\n     * class User {\n     *    constructor(public name: string) {}\n     * }\n     */\n    isProperty(): boolean {\n        return this.parameter.readonly === true || this.parameter.visibility !== undefined;\n    }\n}\n\n/**\n * @reflection never\n */\nexport class ReflectionFunction {\n    parameters: ReflectionParameter[] = [];\n    description: string = '';\n\n    constructor(\n        public readonly type: TypeMethod | TypeMethodSignature | TypeFunction,\n    ) {\n        for (const p of this.type.parameters) {\n            this.parameters.push(new ReflectionParameter(p, this));\n        }\n        if (this.type.description) this.description = this.type.description;\n    }\n\n    static from(fn: Function): ReflectionFunction {\n        //todo: cache it\n\n        if (!('__type' in fn)) {\n            //functions without any types have no __type attached\n            return new ReflectionFunction({\n                kind: ReflectionKind.function,\n                function: fn,\n                return: { kind: ReflectionKind.any },\n                parameters: [],\n            });\n        }\n\n        const type = reflect(fn);\n        if (type.kind !== ReflectionKind.function) {\n            throw new Error(`Given object is not a function ${fn}`);\n        }\n        return new ReflectionFunction(type);\n    }\n\n    getParameterNames(): (string)[] {\n        return this.getParameters().map(v => v.getName());\n    }\n\n    hasParameter(name: string | number | symbol): boolean {\n        return !!this.getParameterOrUndefined(name);\n    }\n\n    getParameterOrUndefined(name: string | number | symbol): ReflectionParameter | undefined {\n        for (const property of this.getParameters()) {\n            if (property.getName() === name) return property;\n        }\n        return;\n    }\n\n    getParameter(name: string | number | symbol): ReflectionParameter {\n        const property = this.getParameterOrUndefined(name);\n        if (!property) throw new Error(`No parameter ${String(name)} in method ${this.name} found.`);\n        return property;\n    }\n\n    getParameterType(name: string | number | symbol): Type | undefined {\n        const parameter = this.getParameter(name);\n        if (parameter) return parameter.getType();\n        return;\n    }\n\n    getParameters(): ReflectionParameter[] {\n        return this.parameters;\n    }\n\n    getReturnType(): Type {\n        return this.type.return;\n    }\n\n    getName(): number | string | symbol {\n        return this.type.name || 'anonymous';\n    }\n\n    getDescription(): string {\n        return this.description;\n    }\n\n    get name(): string {\n        return memberNameToString(this.getName());\n    }\n}\n\n/**\n * @reflection never\n */\nexport class ReflectionMethod extends ReflectionFunction {\n    /**\n     * Whether this method acts as validator.\n     */\n    validator: boolean = false;\n\n    constructor(\n        public type: TypeMethod | TypeMethodSignature,\n        public reflectionClass: ReflectionClass<any>,\n    ) {\n        super(type);\n    }\n\n    setType(method: TypeMethod | TypeMethodSignature) {\n        this.type = method;\n        this.parameters = [];\n        for (const p of this.type.parameters) {\n            this.parameters.push(new ReflectionParameter(p, this));\n        }\n    }\n\n    applyDecorator(data: TData) {\n        this.validator = data.validator;\n        if (this.validator) {\n            this.reflectionClass.validationMethod = this.getName();\n        }\n    }\n\n    clone(reflectionClass?: ReflectionClass<any>, method?: TypeMethod | TypeMethodSignature): ReflectionMethod {\n        const c = new ReflectionMethod(method || this.type, reflectionClass || this.reflectionClass);\n        //todo, clone parameter\n        return c;\n    }\n\n    isOptional(): boolean {\n        return this.type.optional === true;\n    }\n}\n\nexport function resolveForeignReflectionClass(property: ReflectionProperty): ReflectionClass<any> {\n    if (property.isReference()) return property.getResolvedReflectionClass();\n    if (property.isBackReference()) {\n        if (property.isArray()) {\n            return resolveClassType(property.getSubType());\n        }\n        return property.getResolvedReflectionClass();\n    }\n\n    throw new Error(`Property ${property.name} is neither a Reference nor a BackReference.`);\n}\n\n/**\n * Resolved the class/object ReflectionClass of the given TypeClass|TypeObjectLiteral\n */\nexport function resolveClassType(type: Type): ReflectionClass<any> {\n    if (type.kind !== ReflectionKind.class && type.kind !== ReflectionKind.objectLiteral) {\n        throw new Error(`Cant resolve ReflectionClass of type ${type.kind} since its not a class or object literal`);\n    }\n\n    return ReflectionClass.from(type);\n}\n\n/**\n * @reflection never\n */\nexport class ReflectionProperty {\n    //is this really necessary?\n    jsonType?: Type;\n\n    serializer?: SerializerFn;\n    deserializer?: SerializerFn;\n\n    data: { [name: string]: any } = {};\n\n    /**\n     * The type of the property, not the property itself.\n     *\n     * Note: If the property is optional via `property?: T`, this information\n     * is not available here. It's on `property`.\n     * Use `isOptional()` instead, which handles this case plus the case\n     * where optionality is given via union of T and undefined.\n     */\n    type: Type;\n\n    symbol: symbol;\n\n    protected cachedResolvedReflectionClass?: ReflectionClass<any>;\n\n    constructor(\n        public property: TypeProperty | TypePropertySignature,\n        public reflectionClass: ReflectionClass<any>,\n    ) {\n        this.type = property.type;\n        this.setType(this.type);\n        this.symbol = Symbol(memberNameToString(this.getName()));\n    }\n\n    setType(type: Type) {\n        this.type = type;\n    }\n\n    isPrimaryKey(): boolean {\n        return primaryKeyAnnotation.isPrimaryKey(this.getType());\n    }\n\n    isEmbedded(): boolean {\n        return !!embeddedAnnotation.getFirst(this.getType());\n    }\n\n    /**\n     * Returns the sub type if available (for arrays for example).\n     *\n     * @throws Error if the property type does not support sub types.\n     */\n    getSubType(): Type {\n        if (this.type.kind === ReflectionKind.array) return this.type.type as Type;\n\n        throw new Error(`Type ${this.type.kind} does not support sub types`);\n    }\n\n    /**\n     * If undefined, it's not an embedded class.\n     */\n    getEmbedded(): { prefix?: string } | undefined {\n        return embeddedAnnotation.getFirst(this.getType());\n    }\n\n    isBackReference(): boolean {\n        return isBackReferenceType(this.getType());\n    }\n\n    isDatabaseSkipped(database: string): boolean {\n        return databaseAnnotation.getDatabase(this.getType(), database)?.skip === true;\n    }\n\n    isDatabaseMigrationSkipped(database: string): boolean {\n        return this.isDatabaseSkipped(database) || databaseAnnotation.getDatabase(this.getType(), database)?.skipMigration === true;\n    }\n\n    getBackReference(): BackReferenceOptionsResolved {\n        return getBackReferenceType(this.getType());\n    }\n\n    isAutoIncrement(): boolean {\n        return autoIncrementAnnotation.getFirst(this.getType()) === true;\n    }\n\n    isReference(): boolean {\n        return isReferenceType(this.getType());\n    }\n\n    isArray(): boolean {\n        return this.type.kind === ReflectionKind.array;\n    }\n\n    isDate(): boolean {\n        return this.type.kind === ReflectionKind.class && this.type.classType === Date;\n    }\n\n    isNumber(): boolean {\n        return this.type.kind === ReflectionKind.number || this.type.kind === ReflectionKind.bigint;\n    }\n\n    getForeignKeyName(): string {\n        return this.getNameAsString();\n    }\n\n    getReference(): ReferenceOptions | undefined {\n        return getReferenceType(this.getType());\n    }\n\n    getGroups(): string[] {\n        return groupAnnotation.getAnnotations(this.getType());\n    }\n\n    isInGroup(...group: string[]): boolean {\n        return this.getGroups().some(v => group.includes(v));\n    }\n\n    getExcluded(): string[] {\n        return excludedAnnotation.getAnnotations(this.getType());\n    }\n\n    isSerializerExcluded(name: string): boolean {\n        return excludedAnnotation.isExcluded(this.getType(), name);\n    }\n\n    getData(): { [name: string]: any } {\n        return dataAnnotation.getFirst(this.getType()) || {};\n    }\n\n    /**\n     * Returns the ReflectionClass of the reference class/object literal.\n     *\n     * @throws Error if the property is not from type TypeClass or TypeObjectLiteral\n     */\n    getResolvedReflectionClass(): ReflectionClass<any> {\n        if (this.type.kind !== ReflectionKind.class && this.type.kind !== ReflectionKind.objectLiteral) {\n            throw new Error(`Could not resolve reflection class since ${this.name} is not a class|object but of type ${stringifyType(this.type)}`);\n        }\n        return this.cachedResolvedReflectionClass ||= resolveClassType(this.getType());\n    }\n\n    /**\n     * If undefined the property is not an index.\n     * A unique property is defined as index with IndexOptions.unique=true.\n     */\n    getIndex(): IndexOptions | undefined {\n        return indexAnnotation.getFirst(this.getType());\n    }\n\n    /**\n     * Returns database specific options, if defined\n     *\n     * ```typescript\n     * interface User {\n     *     logins: number & DatabaseField<{type: 'integer(8)'}>;\n     *\n     *     //of for a specific db engine\n     *     logins: number & Sqlite<{type: 'integer(8)'}>;\n     * }\n     *\n     * ```\n     */\n    getDatabase<T extends DatabaseFieldOptions>(name: string): T | undefined {\n        return databaseAnnotation.getDatabase<T>(this.getType(), name);\n    }\n\n    clone(reflectionClass?: ReflectionClass<any>, property?: TypeProperty | TypePropertySignature): ReflectionProperty {\n        const c = new ReflectionProperty(copyAndSetParent(property || this.property), reflectionClass || this.reflectionClass);\n        c.jsonType = this.jsonType;\n        c.serializer = this.serializer;\n        c.deserializer = this.deserializer;\n        return c;\n    }\n\n    applyDecorator(data: TData) {\n        this.serializer = data.serializer;\n        this.deserializer = data.deserializer;\n        Object.assign(this.data, data.data);\n\n        //note: data.validators is already applied in Processor\n    }\n\n    getName(): number | string | symbol {\n        return this.property.name;\n    }\n\n    getNameAsString(): string {\n        return memberNameToString(this.property.name);\n    }\n\n    get name(): string {\n        return memberNameToString(this.property.name);\n    }\n\n    getKind(): ReflectionKind {\n        return this.type.kind;\n    }\n\n    getType(): Type {\n        return this.type as Type;\n    }\n\n    getDescription(): string {\n        return this.property.description || '';\n    }\n\n    /**\n     * Whether a value is required from serialization point of view.\n     * If this property has for example a default value (set via constructor or manually via t.default),\n     * then the value is not required to instantiate the property value.\n     */\n    isValueRequired(): boolean {\n        if (this.hasDefault()) return false;\n\n        return !this.isOptional();\n    }\n\n    /**\n     * Returns true when `undefined` or a missing value is allowed at the class itself.\n     * This is now only true when `optional` is set, but also when type is `any`.\n     */\n    isActualOptional(): boolean {\n        return this.isOptional() || this.type.kind === ReflectionKind.any;\n    }\n\n    /**\n     * If the property is actual optional or is an union with undefined in it.\n     */\n    isOptional(): boolean {\n        return this.property.optional === true || (this.type.kind === ReflectionKind.union && this.type.types.some(v => v.kind === ReflectionKind.undefined));\n    }\n\n    setOptional(v: boolean): void {\n        this.property.optional = v ? true : undefined;\n    }\n\n    isNullable(): boolean {\n        return (this.type.kind === ReflectionKind.union && this.type.types.some(v => v.kind === ReflectionKind.null));\n    }\n\n    isReadonly(): boolean {\n        return this.property.readonly === true;\n    }\n\n    isAbstract(): boolean {\n        return this.property.kind === ReflectionKind.property && this.property.abstract === true;\n    }\n\n    hasDefault(): boolean {\n        return this.property.kind === ReflectionKind.property && this.property.default !== undefined;\n    }\n\n    getDefaultValue(): any {\n        if (this.property.kind === ReflectionKind.property && this.property.default !== undefined) {\n            try {\n                return this.property.default();\n            } catch {\n                return;\n            }\n        }\n    }\n\n    hasDefaultFunctionExpression(): boolean {\n        return this.property.kind === ReflectionKind.property && !!this.property.default && hasFunctionExpression(this.property.default);\n    }\n\n    getDefaultValueFunction(): (() => any) | undefined {\n        if (this.property.kind === ReflectionKind.property && this.property.default !== undefined) {\n            return this.property.default;\n        }\n        return;\n    }\n\n    getVisibility(): ReflectionVisibility | undefined {\n        return this.property.kind === ReflectionKind.property ? this.property.visibility : undefined;\n    }\n\n    isPublic(): boolean {\n        return this.property.kind === ReflectionKind.property ? this.property.visibility === ReflectionVisibility.public : true;\n    }\n\n    isProtected(): boolean {\n        return this.property.kind === ReflectionKind.property ? this.property.visibility === ReflectionVisibility.protected : false;\n    }\n\n    isPrivate(): boolean {\n        return this.property.kind === ReflectionKind.property ? this.property.visibility === ReflectionVisibility.private : false;\n    }\n}\n\nexport const reflectionClassSymbol = Symbol('reflectionClass');\n\nexport interface SerializerFn {\n    (value: any, property: ReflectionProperty): any;\n}\n\nexport class TData {\n    validator: boolean = false;\n    validators: ValidateFunction[] = [];\n    type?: Packed | Type | ClassType;\n    data: { [name: string]: any } = {};\n    serializer?: SerializerFn;\n    deserializer?: SerializerFn;\n}\n\nexport class EntityData {\n    name?: string;\n    collectionName?: string;\n    databaseSchemaName?: string;\n    disableConstructor: boolean = false;\n    data: { [name: string]: any } = {};\n    indexes: { names: string[], options: IndexOptions }[] = [];\n    singleTableInheritance?: true;\n}\n\nfunction applyEntityOptions(reflection: ReflectionClass<any>, entityOptions: EntityOptions) {\n    if (entityOptions.name !== undefined) reflection.name = entityOptions.name;\n    if (entityOptions.description !== undefined) reflection.description = entityOptions.description;\n    if (entityOptions.collection !== undefined) reflection.collectionName = entityOptions.collection;\n    if (entityOptions.database !== undefined) reflection.databaseSchemaName = entityOptions.database;\n    if (entityOptions.singleTableInheritance !== undefined) reflection.singleTableInheritance = entityOptions.singleTableInheritance;\n    if (entityOptions.indexes !== undefined) reflection.indexes = entityOptions.indexes;\n}\n\n/**\n * @reflection never\n */\nexport class ReflectionClass<T> {\n    /**\n     * The description, extracted from the class JSDoc @description.\n     */\n    description: string = '';\n\n    /**\n     * A place where arbitrary data is stored, usually set via decorator t.data.\n     */\n    data: { [name: string]: any } = {};\n\n    /**\n     * The unique entity name.\n     *\n     * ```typescript\n     * @entity.name('user')\n     * class User {\n     *\n     * }\n     * ```\n     */\n    name?: string;\n\n    databaseSchemaName?: string;\n\n    disableConstructor: boolean = false;\n\n    /**\n     * The collection name, used in database context (also known as table name).\n     *\n     * Usually, if this is not set, `name` will be used.\n     *\n     * ```typescript\n     * @entity.collection('users').name('user')\n     * class User {\n     *\n     * }\n     * ```\n     */\n    collectionName?: string;\n\n    /**\n     * True when @entity.singleTableInheritance was set.\n     */\n    singleTableInheritance: boolean = false;\n\n    /**\n     * Contains all indexed, multi-field using entity.index and all indexes from properties.\n     *\n     * ```typescript\n     * @entity\n     *    .collection('users')\n     *    .name('user')\n     *    .index(['username', 'email'])\n     *    .index(['email', 'region'], {unique: true})\n     * class User {\n     *     username: string;\n     *     email: string;\n     * }\n     * ```\n     */\n    indexes: { names: string[], options: IndexOptions }[] = [];\n\n    protected propertyNames: string[] = [];\n    protected methodNames: string[] = [];\n    protected properties: ReflectionProperty[] = [];\n    protected methods: ReflectionMethod[] = [];\n\n    /**\n     * References and back references.\n     */\n    protected references: ReflectionProperty[] = [];\n\n    protected primaries: ReflectionProperty[] = [];\n\n    protected autoIncrements: ReflectionProperty[] = [];\n\n    /**\n     * If a custom validator method was set via @t.validator, then this is the method name.\n     */\n    public validationMethod?: string | symbol | number | TypeTemplateLiteral;\n\n    /**\n     * A class using @t.singleTableInheritance registers itself in this array in its super class.\n     */\n    public subClasses: ReflectionClass<any>[] = [];\n\n    constructor(public readonly type: TypeClass | TypeObjectLiteral, public readonly parent?: ReflectionClass<any>) {\n        if (type.kind !== ReflectionKind.class && type.kind !== ReflectionKind.objectLiteral) throw new Error('Only class, interface, or object literal type possible');\n\n        if (parent) {\n            this.name = parent.name;\n            this.collectionName = parent.collectionName;\n            this.databaseSchemaName = parent.databaseSchemaName;\n            this.description = parent.description;\n\n            for (const member of parent.getProperties()) {\n                this.registerProperty(member.clone(this));\n            }\n            for (const member of parent.getMethods()) {\n                this.registerMethod(member.clone(this));\n            }\n        }\n\n        for (const member of type.types) {\n            this.add(member);\n        }\n\n        const entityOptions = entityAnnotation.getFirst(this.type);\n        if (entityOptions) {\n            applyEntityOptions(this, entityOptions);\n        }\n        this.description = this.type.description || this.description;\n\n        //apply decorators\n        if (type.kind === ReflectionKind.class && isWithDeferredDecorators(type.classType)) {\n            for (const decorator of type.classType.__decorators) {\n                if (decorator.target !== type.classType) continue;\n                const { data, property, parameterIndexOrDescriptor } = decorator;\n                if (property === undefined && parameterIndexOrDescriptor === undefined) {\n                    this.applyDecorator(data);\n                } else if (property !== undefined && parameterIndexOrDescriptor === undefined) {\n                    const reflectionProperty = this.getPropertyOrUndefined(property);\n                    if (reflectionProperty) reflectionProperty.applyDecorator(data);\n\n                    const reflectionMethod = this.getMethodOrUndefined(property);\n                    if (reflectionMethod) reflectionMethod.applyDecorator(data);\n\n                } else if (parameterIndexOrDescriptor !== undefined) {\n                    const reflectionMethod = this.getMethodOrUndefined(property || 'constructor');\n                    if (reflectionMethod) {\n                        const params = reflectionMethod.getParameters();\n                        const param = params[parameterIndexOrDescriptor];\n                        if (param) param.applyDecorator(data);\n                    }\n                }\n            }\n        }\n    }\n\n    clone(): ReflectionClass<any> {\n        const reflection = new ReflectionClass(copyAndSetParent(this.type), this.parent);\n        reflection.name = this.name;\n        reflection.collectionName = this.collectionName;\n        reflection.databaseSchemaName = this.databaseSchemaName;\n        reflection.singleTableInheritance = this.singleTableInheritance;\n        reflection.indexes = this.indexes.slice();\n        reflection.subClasses = this.subClasses.slice();\n        reflection.data = { ...this.data };\n        reflection.description = this.description;\n\n        return reflection;\n    }\n\n    toString(): string {\n        return stringifyResolvedType(this.type);\n    }\n\n    getPropertiesDeclaredInConstructor(): ReflectionProperty[] {\n        const constructor = this.getMethod('constructor');\n        if (!constructor) return [];\n        const propertyNames = constructor.parameters.filter(v => v.getVisibility() !== undefined).map(v => v.getName());\n        return this.properties.filter(v => propertyNames.includes(memberNameToString(v.getName())));\n    }\n\n    clearJitContainer() {\n        clearTypeJitContainer(this.type);\n    }\n\n    getJitContainer() {\n        return getTypeJitContainer(this.type);\n    }\n\n    getClassType(): ClassType {\n        return this.type.kind === ReflectionKind.class ? this.type.classType : Object;\n    }\n\n    getClassName(): string {\n        return this.type.kind === ReflectionKind.class ? this.type.typeName || getClassName(this.getClassType()) : this.type.typeName || 'Object';\n    }\n\n    createDefaultObject(): object {\n        try {\n            return new (this.getClassType());\n        } catch {\n            return {};\n        }\n    }\n\n    getName(): string {\n        return this.name || this.getClassName();\n    }\n\n    getDescription(): string {\n        return this.description;\n    }\n\n    getCollectionName(): string {\n        return this.collectionName || this.getName();\n    }\n\n    hasProperty(name: string | symbol | number): boolean {\n        return this.propertyNames.includes(memberNameToString(name));\n    }\n\n    hasMethod(name: string | symbol | number): boolean {\n        return this.methodNames.includes(memberNameToString(name));\n    }\n\n    getPrimary(): ReflectionProperty {\n        if (!this.primaries.length) {\n            throw new Error(`Class ${this.getClassName()} has no primary key.`);\n        }\n        return this.primaries[0];\n    }\n\n    getAutoIncrement(): ReflectionProperty | undefined {\n        return this.autoIncrements[0];\n    }\n\n    public isSchemaOf(classType: ClassType): boolean {\n        return isPrototypeOfBase(this.getClassType(), classType);\n    }\n\n    hasPrimary(): boolean {\n        return this.primaries.length > 0;\n    }\n\n    getPrimaries(): ReflectionProperty[] {\n        return this.primaries;\n    }\n\n    /**\n     * Returns the ReflectionClass object from parent/super class, if available.\n     */\n    getSuperReflectionClass(): ReflectionClass<any> | undefined {\n        return this.parent;\n    }\n\n    removeProperty(name: string | number | symbol) {\n        const property = this.properties.find(v => v.getName() === name);\n        if (!property) throw new Error(`Property ${String(name)} not known in ${this.getClassName()}`);\n\n        const stringName = memberNameToString(name);\n        arrayRemoveItem(this.propertyNames, stringName);\n\n        const indexType = this.type.types.findIndex(v => (v.kind === ReflectionKind.property || v.kind === ReflectionKind.propertySignature) && v.name === name);\n        if (indexType !== -1) this.type.types.splice(indexType, 1);\n\n        arrayRemoveItem(this.properties, property);\n\n        if (property.isReference() || property.isBackReference()) {\n            arrayRemoveItem(this.references, property);\n        }\n\n        if (property.isPrimaryKey()) arrayRemoveItem(this.primaries, property);\n        if (property.isAutoIncrement()) arrayRemoveItem(this.autoIncrements, property);\n\n        const index = property.getIndex();\n        if (index) {\n            const indexFound = this.indexes.findIndex(v => v.names.length === 0 && v.names[0] === property.name);\n            if (indexFound !== -1) this.indexes.splice(indexFound, 1);\n        }\n    }\n\n    registerProperty(property: ReflectionProperty) {\n        if (this.propertyNames.includes(property.name)) {\n            this.removeProperty(property.getName());\n        }\n\n        if (!hasMember(this.type, property.getName())) {\n            this.type.types.push(property.property as any);\n        }\n\n        property.property.parent = this.type;\n        this.properties.push(property);\n        this.propertyNames.push(property.name);\n        if (property.isReference() || property.isBackReference()) {\n            this.references.push(property);\n        }\n\n        if (property.isPrimaryKey()) this.primaries.push(property);\n        if (property.isAutoIncrement()) this.autoIncrements.push(property);\n\n        const index = property.getIndex();\n        if (index) {\n            this.indexes.push({ names: [property.name], options: index });\n        }\n\n        this.getJitContainer();\n    }\n\n    addProperty(prop: {\n        name: number | string | symbol;\n        optional?: true;\n        readonly?: true;\n        description?: string;\n        visibility?: ReflectionVisibility\n        type: Type;\n    }): ReflectionProperty {\n        const type = {\n            kind: this.type.kind === ReflectionKind.class ? ReflectionKind.property : ReflectionKind.propertySignature,\n            parent: this.type,\n            ...prop,\n        } as TypeProperty | TypePropertySignature;\n        if (type.kind === ReflectionKind.property) {\n            type.visibility = prop.visibility ?? ReflectionVisibility.public;\n        }\n\n        const property = new ReflectionProperty(type, this);\n        this.registerProperty(property);\n\n        return property;\n    }\n\n    registerMethod(method: ReflectionMethod) {\n        if (this.methodNames.includes(method.name)) return;\n\n        this.methods.push(method);\n        this.methodNames.push(method.name);\n    }\n\n    add(member: Type) {\n        if (member.kind === ReflectionKind.property || member.kind === ReflectionKind.propertySignature) {\n            const existing = this.getPropertyOrUndefined(member.name);\n            if (existing) {\n                existing.setType(member.type);\n            } else {\n                this.registerProperty(new ReflectionProperty(member, this));\n            }\n        }\n\n        if (member.kind === ReflectionKind.method || member.kind === ReflectionKind.methodSignature) {\n            const existing = this.getMethodOrUndefined(member.name);\n            if (existing) {\n                existing.setType(member);\n            } else {\n                this.registerMethod(new ReflectionMethod(member, this));\n            }\n        }\n    }\n\n    public assignedSingleTableInheritanceSubClassesByIdentifier?: { [id: string]: ReflectionClass<any> };\n\n    getAssignedSingleTableInheritanceSubClassesByIdentifier(): { [id: string]: ReflectionClass<any> } | undefined {\n        if (!this.subClasses.length) return;\n        if (this.assignedSingleTableInheritanceSubClassesByIdentifier) return this.assignedSingleTableInheritanceSubClassesByIdentifier;\n\n        let isBaseOfSingleTableEntity = false;\n        for (const schema of this.subClasses) {\n            if (schema.singleTableInheritance) {\n                isBaseOfSingleTableEntity = true;\n                break;\n            }\n        }\n\n        if (!isBaseOfSingleTableEntity) return;\n\n        const discriminant = this.getSingleTableInheritanceDiscriminantName();\n\n        for (const schema of this.subClasses) {\n            if (schema.singleTableInheritance) {\n                if (!this.assignedSingleTableInheritanceSubClassesByIdentifier) this.assignedSingleTableInheritanceSubClassesByIdentifier = {};\n                const property = schema.getProperty(discriminant);\n                assertType(property.type, ReflectionKind.literal);\n                this.assignedSingleTableInheritanceSubClassesByIdentifier[property.type.literal as string] = schema;\n            }\n        }\n        return this.assignedSingleTableInheritanceSubClassesByIdentifier;\n    }\n\n    hasSingleTableInheritanceSubClasses(): boolean {\n        return this.getAssignedSingleTableInheritanceSubClassesByIdentifier() !== undefined;\n    }\n\n    getSingleTableInheritanceDiscriminantName(): string {\n        if (!this.data.singleTableInheritanceProperty) {\n\n            // let discriminant = findCommonDiscriminant(this.subClasses);\n\n            //when no discriminator was found, find a common literal\n            const discriminant = findCommonLiteral(this.subClasses);\n\n            if (!discriminant) {\n                throw new Error(`Sub classes of ${this.getClassName()} single-table inheritance [${this.subClasses.map(v => v.getClassName())}] have no common discriminant or common literal. Please define one.`);\n            }\n            this.data.singleTableInheritanceProperty = this.getProperty(discriminant);\n        }\n\n        return (this.data.singleTableInheritanceProperty as ReflectionProperty).name;\n    }\n\n    applyDecorator(data: EntityData) {\n        Object.assign(this.data, data.data);\n        if (data.name !== undefined) this.name = data.name;\n        if (data.collectionName !== undefined) this.collectionName = data.collectionName;\n        if (data.databaseSchemaName !== undefined) this.databaseSchemaName = data.databaseSchemaName;\n        this.disableConstructor = data.disableConstructor;\n\n        this.indexes.push(...data.indexes);\n        if (data.singleTableInheritance) {\n            this.singleTableInheritance = true;\n            if (this.parent) {\n                //the subclass is only added when really needed (e.g. for tracking childs of a single table inheritance setup) otherwise it's a memory leak when a lot of classes\n                //are dynamically created.\n                this.parent.subClasses.push(this);\n            }\n        }\n    }\n\n    static from<T>(classTypeIn?: ReceiveType<T> | AbstractClassType<T> | TypeClass | TypeObjectLiteral | ReflectionClass<any>, args: any[] = []): ReflectionClass<T> {\n        if (!classTypeIn) throw new Error(`No type given in ReflectionClass.from<T>`);\n        if (isArray(classTypeIn)) classTypeIn = resolveReceiveType(classTypeIn);\n\n        if (classTypeIn instanceof ReflectionClass) return classTypeIn;\n        if (isType(classTypeIn)) {\n            if (classTypeIn.kind === ReflectionKind.objectLiteral || (classTypeIn.kind === ReflectionKind.class && classTypeIn.typeArguments)) {\n                const jit = getTypeJitContainer(classTypeIn);\n                if (jit.reflectionClass) return jit.reflectionClass;\n                return jit.reflectionClass = new ReflectionClass<T>(classTypeIn);\n            }\n            if (classTypeIn.kind !== ReflectionKind.class) throw new Error(`TypeClass or TypeObjectLiteral expected, not ${ReflectionKind[classTypeIn.kind]}`);\n        }\n\n        const classType = isType(classTypeIn) ? (classTypeIn as TypeClass).classType : (classTypeIn as any)['prototype'] ? classTypeIn as ClassType<T> : classTypeIn.constructor as ClassType<T>;\n\n        if (!classType.prototype.hasOwnProperty(reflectionClassSymbol)) {\n            Object.defineProperty(classType.prototype, reflectionClassSymbol, { writable: true, enumerable: false });\n        }\n\n        if (classType.prototype[reflectionClassSymbol] && args.length === 0) {\n            return classType.prototype[reflectionClassSymbol];\n        }\n\n        const type = isType(classTypeIn) ? classTypeIn as TypeClass : ('__type' in classType ? resolveRuntimeType(classType, args) : {\n            kind: ReflectionKind.class,\n            classType,\n            types: [],\n        } as TypeClass);\n\n        if (type.kind !== ReflectionKind.class) {\n            throw new Error(`Given class is not a class but kind ${ReflectionKind[type.kind]}. classType: ${stringifyValueWithType(classType)}`);\n        }\n\n        const parentProto = Object.getPrototypeOf(classType.prototype);\n        const parentReflectionClass: ReflectionClass<T> | undefined = parentProto && parentProto.constructor !== Object ? ReflectionClass.from(parentProto, type.extendsArguments) : undefined;\n\n        const reflectionClass = new ReflectionClass(type, parentReflectionClass);\n        if (args.length === 0) {\n            classType.prototype[reflectionClassSymbol] = reflectionClass;\n            return reflectionClass;\n        } else {\n            return reflectionClass;\n        }\n    }\n\n    getIndexSignatures() {\n        throw new Error('todo');\n    }\n\n    getPropertyNames(): (string | number | symbol)[] {\n        return this.propertyNames;\n    }\n\n    getProperties(): ReflectionProperty[] {\n        return this.properties;\n    }\n\n    getPropertiesInGroup(...group: string[]): ReflectionProperty[] {\n        return this.properties.filter(v => v.isInGroup(...group));\n    }\n\n    getMethodNames(): (string | number | symbol)[] {\n        return this.methodNames;\n    }\n\n    getMethods(): ReflectionMethod[] {\n        return this.methods;\n    }\n\n    /**\n     * Returns references and back references.\n     */\n    getReferences(): ReflectionProperty[] {\n        return this.references;\n    }\n\n    getConstructorOrUndefined(): ReflectionMethod | undefined {\n        return this.getMethodOrUndefined('constructor');\n    }\n\n    getPropertyOrUndefined(name: string | number | symbol | TypeTemplateLiteral): ReflectionProperty | undefined {\n        for (const property of this.getProperties()) {\n            if (property.getName() === name) return property;\n        }\n        return;\n    }\n\n    getProperty(name: string | number | symbol): ReflectionProperty {\n        const property = this.getPropertyOrUndefined(name);\n        if (!property) throw new Error(`No property ${memberNameToString(name)} found in ${this.getClassName()}`);\n        return property;\n    }\n\n    getMethodParameters(name: string | number | symbol): ReflectionParameter[] {\n        const method = this.getMethodOrUndefined(name);\n        return method ? method.getParameters() : [];\n    }\n\n    getMethodOrUndefined(name: string | number | symbol | TypeTemplateLiteral): ReflectionMethod | undefined {\n        for (const method of this.getMethods()) {\n            if (method.getName() === name) return method;\n        }\n        return;\n    }\n\n    getMethod(name: string | number | symbol): ReflectionMethod {\n        const method = this.getMethodOrUndefined(name);\n        if (!method) throw new Error(`No method ${memberNameToString(name)} found in ${this.getClassName()}`);\n        return method;\n    }\n\n    public hasCircularReference(): boolean {\n        return hasCircularReference(this.type);\n    }\n\n    serializeType(): SerializedTypes {\n        return serializeType(this.type);\n    }\n\n    /**\n     * All references have a counter-part. This methods finds it and errors if not possible.\n     *\n     * If the given reference is a owning reference it finds the correct backReference,\n     *    which can be found by checking all reference options.mappedBy.\n     *\n     * If the given reference is a back reference it finds the owning reference,\n     *    which can be found by using its options.mappedBy.\n     *\n     * Alternatively we simply check for resolvedClassType to be given `classType`, and if only one\n     * found, we return it. When more than one found, we throw an error saying the user he\n     * should make its relation mapping not ambiguous.\n     */\n    public findReverseReference(toClassType: ClassType, fromReference: ReflectionProperty): ReflectionProperty {\n        if (fromReference.isBackReference() && fromReference.getBackReference().mappedBy) {\n            if (resolveForeignReflectionClass(fromReference).getClassType() === this.getClassType()) {\n                return this.getProperty(fromReference.getBackReference().mappedBy as string);\n            }\n        }\n\n        const candidates: ReflectionProperty[] = [];\n        for (const backRef of this.references) {\n            if (backRef === fromReference) continue;\n\n            //backRef points to something completely different\n            if (!backRef.isArray() && resolveForeignReflectionClass(backRef).getClassType() !== toClassType) continue;\n            if (backRef.isArray() && getClassType(backRef.getSubType()) !== toClassType) continue;\n\n            //we found the perfect match, manually annotated\n            if (backRef.isBackReference() && backRef.getBackReference().mappedBy) {\n                if (backRef.getBackReference().mappedBy === fromReference.name) {\n                    return backRef;\n                }\n                continue;\n            }\n\n            if (fromReference.isBackReference() && fromReference.getBackReference().mappedBy && !fromReference.getBackReference().via) {\n                if (fromReference.getBackReference().mappedBy === backRef.name) {\n                    //perfect match\n                    return backRef;\n                }\n                continue;\n            }\n\n            //add to candidates if possible\n            if (fromReference.isBackReference() && fromReference.getBackReference().via && backRef.isBackReference() && backRef.getBackReference().via) {\n                if (fromReference.getBackReference().via === backRef.getBackReference().via) {\n                    candidates.push(backRef);\n                }\n                continue;\n            }\n\n            if (fromReference.isBackReference() && fromReference.isArray() && !fromReference.getBackReference().via) {\n                //other side must be non-array\n                if (backRef.isArray()) continue;\n            }\n\n            candidates.push(backRef);\n        }\n\n        if (candidates.length > 1) {\n            throw new Error(`Class ${this.getClassName()} has multiple potential reverse references [${candidates.map(v => v.name).join(', ')}] for ${fromReference.name} to class ${getClassName(toClassType)}. ` +\n                `Please specify each back reference by using 'mappedBy', e.g. @t.backReference({mappedBy: 'fieldNameOnTheOtherSide'} so its not ambiguous anymore.`);\n        }\n\n        if (candidates.length === 1) return candidates[0];\n\n        throw new Error(`Class ${this.getClassName()} has no reference to class ${getClassName(toClassType)} defined.`);\n    }\n\n    public extractPrimaryKey(item: object): Partial<T> {\n        const primaryKey: Partial<T> = {};\n        for (const pk of this.getPrimaries()) {\n            (primaryKey as any)[pk.name] = (item as any)[pk.name];\n        }\n\n        return primaryKey;\n    }\n}\n\n\n// old function to decorate an interface\n// export function decorate<T>(decorate: { [P in keyof T]?: FreeDecoratorFn<any> }, p?: ReceiveType<T>): ReflectionClass<T> {\n//     const type = typeOf([], p);\n//     if (type.kind === ReflectionKind.objectLiteral) {\n//         const classType = class {\n//         };\n//         const reflection = new ReflectionClass({ kind: ReflectionKind.class, classType, types: type.types });\n//         (classType as any).prototype[reflectionClassSymbol] = reflection;\n//\n//         for (const [p, fn] of Object.entries(decorate)) {\n//             (fn as FreeDecoratorFn<any>)(classType, p);\n//         }\n//\n//         return reflection;\n//     }\n//     throw new Error('Decorate is only possible on object literal/interfaces.');\n// }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 10711, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10717, "column": 0}, "map": {"version":3,"file":"decorator-builder.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/decorator-builder.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport { AbstractClassType, ClassType, getClassName } from '@deepkit/core';\n\nexport type ClassDecoratorFn = (classType: AbstractClassType, property?: string, parameterIndexOrDescriptor?: any) => void;\nexport type PropertyDecoratorFn = (prototype: object, property?: number | string | symbol, parameterIndexOrDescriptor?: any) => void;\n\nexport type FluidDecorator<T, D extends Function> = {\n    [name in keyof T]: T[name] extends (...args: infer K) => any ? (...args: K) => D & FluidDecorator<T, D>\n        : D & FluidDecorator<T, D>\n        & { _data: ExtractApiDataType<T> };\n};\n\nexport function createFluidDecorator<API extends APIClass<any> | APIProperty<any>, D extends Function>\n(\n    api: API,\n    modifier: { name: string, args?: any, ?: any }[],\n    collapse: (modifier: { name: string, args?: any }[], target: any, property?: string, parameterIndexOrDescriptor?: any) => void,\n    returnCollapse: boolean = false,\n    fluidFunctionSymbol?: symbol\n): FluidDecorator<ExtractClass<API>, D> {\n    const fn = function (target: object, property?: string, parameterIndexOrDescriptor?: any) {\n        const res = collapse(modifier, target, property, parameterIndexOrDescriptor);\n        if (returnCollapse || target === Object) return res;\n    };\n    Object.defineProperty(fn, 'name', { value: undefined });\n    Object.defineProperty(fn, '_data', {\n        get: () => {\n            return collapse(modifier, Object);\n        }\n    });\n\n    const methods: string[] = [];\n    Object.defineProperty(fn, '_methods', { value: methods });\n    if (fluidFunctionSymbol) Object.defineProperty(fn, fluidFunctionSymbol, { value: true });\n\n    let current = api;\n    while (current.prototype) {\n        let proto = current.prototype;\n        for (const name of Object.getOwnPropertyNames(proto)) {\n            if (name === 'constructor') continue;\n            if (name === 'onDecorator') continue;\n\n            const descriptor = Object.getOwnPropertyDescriptor(proto, name);\n            methods.push(name);\n            if (descriptor && descriptor.get) {\n                //its a magic shizzle\n                Object.defineProperty(fn, name, {\n                    configurable: true,\n                    enumerable: false,\n                    get: () => {\n                        return createFluidDecorator(api, [...modifier, { name }], collapse, returnCollapse, fluidFunctionSymbol);\n                    }\n                });\n            } else {\n                //regular method\n                Object.defineProperty(fn, name, {\n                    configurable: true,\n                    enumerable: false,\n                    value: function fn(...args: any[]) {\n                        return createFluidDecorator(api, [...modifier, { name, args, : (fn as any). }], collapse, returnCollapse, fluidFunctionSymbol);\n                    }\n                });\n            }\n        }\n\n        //resolve parent\n        current = Object.getPrototypeOf(current);\n    }\n\n    return fn as any;\n}\n\nexport type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\nexport type Merge<U> = { [K in keyof U]: U[K] extends ((...a: infer A) => infer R) ? R extends DualDecorator ? (...a: A) => PropertyDecoratorFn & R & U : (...a: A) => R : never };\n\n/**\n * A dual decorator is a decorator that can be used on a class and class property.\n */\nexport type DualDecorator = void & { __DualDecorator?: true };\n\nexport function mergeDecorator<T extends any[]>(...args: T): Merge<Omit<UnionToIntersection<T[number]>, '_fetch' | 't'>> {\n    const res: any = {};\n\n    //dual decorator are decorators that share the same name for class decorators and class property decorator\n    //and need a special runtime check when collapsed.\n    const tracked: string[] = [];\n    const dualDecorator: string[] = [];\n\n    for (const arg of args) {\n        for (const method of arg._methods) {\n            if (tracked.includes(method)) {\n                if (!dualDecorator.includes(method)) dualDecorator.push(method);\n                continue;\n            }\n            tracked.push(method);\n        }\n    }\n\n    for (const arg of args) {\n        for (const method of arg._methods) {\n            if (!dualDecorator.includes(method)) {\n                Object.defineProperty(res, method, {\n                    get() {\n                        return arg[method];\n                    }\n                });\n            }\n        }\n    }\n\n    function fluid(\n        modifier: { name: string, args?: any, ?: any }[],\n        collapse: (modifier: { name: string, args?: any }[], target: any, property?: string, parameterIndexOrDescriptor?: any) => void,\n    ): any {\n        const fn = function (target: object, property?: string, parameterIndexOrDescriptor?: any) {\n            const res = collapse(modifier, target, property, parameterIndexOrDescriptor);\n            if (target === Object) return res;\n        };\n        Object.defineProperty(fn, 'name', { value: undefined });\n\n        for (const name of tracked) {\n            const decorator = args.find(v => v[name]);\n            if (!decorator) continue;\n            const descriptor = Object.getOwnPropertyDescriptor(decorator, name);\n            if (descriptor && descriptor.get) {\n                //its a magic shizzle\n                Object.defineProperty(fn, name, {\n                    configurable: true,\n                    enumerable: false,\n                    get: () => {\n                        return fluid([...modifier, { name }], collapse);\n                    }\n                });\n            } else {\n                //regular method\n                Object.defineProperty(fn, name, {\n                    configurable: true,\n                    enumerable: false,\n                    value: function fn(...args: any[]) {\n                        return fluid([...modifier, { name, args, : (fn as any). }], collapse);\n                    }\n                });\n            }\n        }\n        return fn;\n    }\n\n    function collapse(modifier: { name: string, args?: any, ?: any }[], target: object, property?: string, parameterIndexOrDescriptor?: any) {\n        const results: any[] = [];\n        if (property) {\n            loop:\n                for (const mod of modifier) {\n                    for (const decorator of args) {\n                        if (decorator._type === 'propertyDecorator' && decorator[mod.name]) {\n                            if (mod.args) {\n                                (decorator[mod.name] as any). = mod.;\n                                results.push(decorator[mod.name](...mod.args)(target, property, parameterIndexOrDescriptor));\n                            } else {\n                                results.push(decorator[mod.name](target, property, parameterIndexOrDescriptor));\n                            }\n                            continue loop;\n                        }\n                    }\n                    throw new Error(`Decorator '${mod.name}' can not be used on class property ${getClassName(target)}.${property}`);\n                }\n        } else {\n            loop:\n                for (const mod of modifier) {\n                    for (const decorator of args) {\n                        if (decorator._type === 'classDecorator' && decorator[mod.name]) {\n                            if (mod.args) {\n                                (decorator[mod.name] as any). = mod.;\n                                results.push(decorator[mod.name](...mod.args)(target));\n                            } else {\n                                results.push(decorator[mod.name](target));\n                            }\n                            continue loop;\n                        }\n                    }\n\n                    throw new Error(`Decorator '${mod.name}' can not be used on class ${getClassName(target)}`);\n                }\n        }\n        return results;\n    }\n\n    return fluid([], collapse);\n}\n\nexport interface ClassApiTypeInterface<T> {\n    t: T,\n    onDecorator?: (classType: ClassType, property?: string, parameterIndexOrDescriptor?: any) => void\n}\n\nexport type APIClass<T> = ClassType<ClassApiTypeInterface<T>>;\nexport type ExtractClass<T> = T extends ClassType<infer K> ? K : never;\nexport type ExtractApiDataType<T> = T extends AbstractClassType<infer K> ? K extends { t: infer P } ? P : never : (T extends { t: infer P } ? P : never);\n\nexport type ClassDecoratorResult<API extends APIClass<any>> = FluidDecorator<ExtractClass<API>, ClassDecoratorFn> & DecoratorAndFetchSignature<API, ClassDecoratorFn>;\n\nexport function createClassDecoratorContext<API extends APIClass<any>, T = ExtractApiDataType<API>>(\n    apiType: API\n): ClassDecoratorResult<API> {\n    const map = new Map<object, ClassApiTypeInterface<any>>();\n\n    function collapse(modifier: { name: string, args?: any, ?: any }[], target: ClassType): any {\n        const api: ClassApiTypeInterface<any> = map.get(target) ?? new apiType(target);\n\n        for (const fn of modifier) {\n            if (fn.args) {\n                const f = (api as any)[fn.name];\n                f. = fn.;\n                f.call(api, ...fn.args);\n            } else {\n                //just call the getter\n                (api as any)[fn.name];\n            }\n        }\n\n        if (api.onDecorator) api.onDecorator(target);\n\n        map.set(target, api);\n        if (target === Object) return api.t;\n    }\n\n    const fn = createFluidDecorator(apiType, [], collapse);\n\n    Object.defineProperty(fn, '_fetch', {\n        configurable: true,\n        enumerable: false,\n        get: () => {\n            return (target: object) => {\n                const api = map.get(target);\n                return api ? api.t : undefined;\n            };\n        }\n    });\n\n    (fn as any)._type = 'classDecorator';\n    return fn as any;\n}\n\nexport interface PropertyApiTypeInterface<T> {\n    t: T,\n    onDecorator?: (target: ClassType, property: string | undefined, parameterIndexOrDescriptor?: any) => void\n}\n\nexport type APIProperty<T> = ClassType<PropertyApiTypeInterface<T>>;\n\nexport type DecoratorAndFetchSignature<API extends APIProperty<any>, FN extends (...args: any[]) => any> = & FN\n    & { _fetch: (...args: Parameters<FN>) => ExtractApiDataType<API> | undefined };\n\nexport type PropertyDecoratorResult<API extends APIProperty<any>> = FluidDecorator<ExtractClass<API>, PropertyDecoratorFn> & DecoratorAndFetchSignature<API, PropertyDecoratorFn>;\n\nexport function createPropertyDecoratorContext<API extends APIProperty<any>>(\n    apiType: API\n): PropertyDecoratorResult<API> {\n    const targetMap = new Map<object, Map<any, PropertyApiTypeInterface<any>>>();\n\n    function collapse(modifier: { name: string, args?: any, ?: any }[], target: object, property?: string, parameterIndexOrDescriptor?: any): any {\n        if (property === undefined && parameterIndexOrDescriptor === undefined) throw new Error('Property decorators can only be used on class properties');\n\n        target = target === Object ? target : (target as any)['constructor']; //property decorators get the prototype instead of the class.\n        let map = targetMap.get(target);\n        if (!map) {\n            map = new Map();\n            targetMap.set(target, map);\n        }\n        const secondIndex = ('number' === typeof parameterIndexOrDescriptor ? parameterIndexOrDescriptor : '');\n        const index = (property || 'constructor') + '$$' + secondIndex;\n        const api: PropertyApiTypeInterface<any> = map.get(index) ?? new apiType(target, property || 'constructor');\n\n        for (const fn of modifier) {\n            if (fn.args) {\n                const f = (api as any)[fn.name];\n                f. = fn.;\n                f.call(api, ...fn.args);\n            } else {\n                //just call the getter\n                (api as any)[fn.name];\n            }\n        }\n\n        if (api.onDecorator) api.onDecorator(target as ClassType, property, ('number' === typeof parameterIndexOrDescriptor ? parameterIndexOrDescriptor : undefined));\n\n        map.set(index, api);\n        if (target === Object) return api.t;\n    }\n\n    const fn = createFluidDecorator(apiType, [], collapse);\n\n    Object.defineProperty(fn, '_fetch', {\n        configurable: true,\n        enumerable: false,\n        get: () => {\n            return (target: object, property?: string, parameterIndexOrDescriptor?: any) => {\n                const map = targetMap.get(target);\n                const secondIndex = ('number' === typeof parameterIndexOrDescriptor ? parameterIndexOrDescriptor : '');\n                const index = property + '$$' + secondIndex;\n                const api = map ? map.get(index) : undefined;\n                return api ? api.t : undefined;\n            };\n        }\n    });\n\n    (fn as any)._type = 'propertyDecorator';\n    return fn as any;\n}\n\nexport type FreeDecoratorFn<API> =\n    { (target?: any, property?: number | string | symbol, parameterIndexOrDescriptor?: any): ExtractApiDataType<API> }\n    & { _data: ExtractApiDataType<API> };\n\nexport type FreeFluidDecorator<API> = {\n    [name in keyof ExtractClass<API>]: ExtractClass<API>[name] extends (...args: infer K) => any\n        ? (...args: K) => FreeFluidDecorator<API>\n        : FreeFluidDecorator<API>\n} & FreeDecoratorFn<API>;\n\nexport type FreeDecoratorResult<API extends APIClass<any>> = FreeFluidDecorator<API> & { _fluidFunctionSymbol: symbol };\n\nexport function createFreeDecoratorContext<API extends APIClass<any>, T = ExtractApiDataType<API>>(\n    apiType: API\n): FreeDecoratorResult<API> {\n    function collapse(modifier: { name: string, args?: any, ?: any }[], target?: any, property?: string, parameterIndexOrDescriptor?: any) {\n        const api = new apiType;\n\n        for (const fn of modifier) {\n            if (fn.args) {\n                const f = (api as any)[fn.name];\n                f. = fn.;\n                f.call(api, ...fn.args);\n            } else {\n                //just call the getter\n                (api as any)[fn.name];\n            }\n        }\n\n        if (api.onDecorator && target) api.onDecorator(target, property, parameterIndexOrDescriptor);\n\n        return api.t;\n    }\n\n    const fluidFunctionSymbol = Symbol('fluidFunctionSymbol');\n\n    const fn = createFluidDecorator(apiType, [], collapse, true, fluidFunctionSymbol);\n\n    Object.defineProperty(fn, '_fluidFunctionSymbol', {\n        configurable: true,\n        enumerable: false,\n        value: fluidFunctionSymbol\n    });\n\n    return fn as any;\n}\n\nexport function isDecoratorContext<API extends APIClass<any>>(context: FreeDecoratorResult<API>, fn: Function): fn is FreeFluidDecorator<API> {\n    const symbol = context._fluidFunctionSymbol;\n\n    if (Object.getOwnPropertyDescriptor(fn, symbol)) return true;\n\n    return false;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 11405, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11411, "column": 0}, "map": {"version":3,"file":"decorator.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/decorator.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport { ClassDecoratorResult, createClassDecoratorContext, createPropertyDecoratorContext } from './decorator-builder.js';\nimport { EntityData, ReceiveType, SerializerFn, TData } from './reflection/reflection.js';\nimport { ClassType, isArray } from '@deepkit/core';\nimport { IndexOptions } from './reflection/type.js';\nimport type { ValidateFunction } from './validator.js';\nimport { typeSettings } from './core.js';\n\nclass TDecorator {\n    t = new TData();\n\n    onDecorator(target: any, property?: string, parameterIndexOrDescriptor?: any) {\n        if (undefined === target) return;\n\n        addDeferredDecorator(this.t, target, property, parameterIndexOrDescriptor);\n    }\n\n    type<T>(type: ReceiveType<T> | ClassType) {\n        this.t.type = type;\n    }\n\n    /**\n     * Marks the method as validator. Is executed for each is/validate call.\n     *\n     * ```typescript\n     *\n     * class MyClass {\n     *     field1: string;\n     *     field2: string;\n     *\n     *     @t.validator\n     *     validate(): ValidatorError | undefined {\n     *          return new ValidatorError('invalid', 'MyClass is invalid');\n     *     }\n     * }\n     *\n     * ```\n     */\n    get validator() {\n        this.t.validator = true;\n        return;\n    }\n\n    validate(...validators: ValidateFunction[]) {\n        this.t.validators.push(...validators);\n    }\n\n    serialize(serializer: SerializerFn) {\n        this.t.serializer = serializer;\n    }\n\n    deserialize(deserializer: SerializerFn) {\n        this.t.deserializer = deserializer;\n    }\n\n    data(name: string, value: any) {\n        this.t.data[name] = value;\n    }\n}\n\nexport const t = createPropertyDecoratorContext(TDecorator);\n\nclass EntityDecorator {\n    t = new EntityData();\n\n    onDecorator(target: any) {\n        if (undefined === target) return;\n        if (this.t.name) typeSettings.registeredEntities[this.t.name] = target;\n        addDeferredDecorator(this.t, target);\n    }\n\n    name(name: string) {\n        this.t.name = name;\n    }\n\n    collection(name: string) {\n        this.t.collectionName = name;\n    }\n\n    /**\n     * Disables calling the constructor when deserializing.\n     */\n    disableConstructor() {\n        this.t.disableConstructor = true;\n    }\n\n    databaseSchema(name: string) {\n        this.t.databaseSchemaName = name;\n    }\n\n    index(names: string[], options: IndexOptions = {}) {\n        this.t.indexes.push({ names, options });\n    }\n\n    singleTableInheritance() {\n        this.t.singleTableInheritance = true;\n    }\n\n    data(name: string, value: any) {\n        this.t.data[name] = value;\n    }\n\n    /**\n     * Exclude this entity from database migrations.\n     */\n    excludeMigration() {\n        this.t.data['excludeMigration'] = true;\n    }\n}\n\nexport const entity: ClassDecoratorResult<typeof EntityDecorator> = createClassDecoratorContext(EntityDecorator);\n\ninterface DeferredDecorator {\n    data: any;\n    target: any;\n    property?: string;\n    parameterIndexOrDescriptor?: any;\n}\n\nexport function isWithDeferredDecorators(obj: any): obj is { __decorators: DeferredDecorator[] } {\n    return obj && '__decorators' in obj && isArray(obj.__decorators);\n}\n\nfunction addDeferredDecorator(data: any, target: any, property?: string, parameterIndexOrDescriptor?: any) {\n    if (!target) return;\n    if (!target.__decorators) target.__decorators = [];\n    target.__decorators.push({ target, property, parameterIndexOrDescriptor, data });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 11600, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11606, "column": 0}, "map": {"version":3,"file":"reference.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/reference.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport { ClassType, isObject } from '@deepkit/core';\nimport { ReflectionClass, reflectionClassSymbol } from './reflection/reflection.js';\nimport { typeSettings, UnpopulatedCheck, unpopulatedSymbol } from './core.js';\nimport { ReflectionKind, Type } from './reflection/type.js';\n\nexport function isReferenceInstance(obj: any): boolean {\n    return isObject(obj) && referenceSymbol in obj;\n}\n\nexport function getReferenceInfo<T>(obj: T): ReferenceInfo<T> | undefined {\n    return (obj as any)[referenceSymbol] as ReferenceInfo<T>;\n}\n\nexport function getReferenceItemInfo<T>(obj: T): ReferenceItemInfo<T> | undefined {\n    return (obj as any)[referenceItemSymbol] as ReferenceItemInfo<T>;\n}\n\nexport function getOrCreateReferenceItemInfo<T>(obj: T): ReferenceItemInfo<T> {\n    if (!(obj as any)[referenceItemSymbol]) (obj as any)[referenceItemSymbol] = { hydrated: false };\n    return (obj as any)[referenceItemSymbol] as ReferenceItemInfo<T>;\n}\n\nexport function isReferenceHydrated(obj: any): boolean {\n    if (!(referenceItemSymbol in obj)) return false;\n    const info = getReferenceItemInfo(obj);\n    return info ? info.hydrated : false;\n}\n\nexport function markAsHydrated(item: any) {\n    getOrCreateReferenceItemInfo(item).hydrated = true;\n}\n\nexport interface ReferenceInfo<T> {\n    hydrator?: (item: T) => Promise<void>;\n}\n\nexport interface ReferenceItemInfo<T> {\n    hydrated: boolean,\n}\n\nexport const referenceSymbol = Symbol('reference');\nexport const referenceItemSymbol = Symbol('reference/item');\n\nexport function createReference<T>(type: ClassType<T> | Type | ReflectionClass<any>, pk: { [name: string]: any }): T {\n    const reflection = ReflectionClass.from(type);\n\n    const reflectionClass = createReferenceClass(reflection);\n\n    const old = typeSettings.unpopulatedCheck;\n    typeSettings.unpopulatedCheck = UnpopulatedCheck.None;\n\n    try {\n        return Object.assign(Object.create(reflectionClass.prototype), pk);\n    } finally {\n        typeSettings.unpopulatedCheck = old;\n    }\n}\n\nexport function createReferenceClass<T>(\n    reflection: ReflectionClass<any>,\n): ClassType<T> {\n    if (reflection.data.referenceClass) return reflection.data.referenceClass;\n\n    const Reference = reflection.type.kind === ReflectionKind.class ? class extends reflection.type.classType {\n    } : class {\n    };\n\n    Object.defineProperty(Reference.prototype, referenceSymbol, { value: { hydrator: undefined }, enumerable: false });\n    Object.defineProperty(Reference.prototype, referenceItemSymbol, { value: null, writable: true, enumerable: false });\n    Object.defineProperty(Reference.prototype, reflectionClassSymbol, { writable: true, enumerable: false, value: reflection });\n\n    Object.defineProperty(Reference, 'name', {\n        value: reflection.getClassName() + 'Reference'\n    });\n\n    reflection.data.referenceClass = Reference;\n\n    for (const property of reflection.getProperties()) {\n        if (property.isPrimaryKey()) continue;\n\n        // we can not exclude default or optional properties, since we tell serializer/validator/change-detector with\n        // returning `unpopulatedSymbol` that this property is not loaded. Returning the wrong default/undefined leads to wrong results.\n\n        const name = String(property.getName());\n\n        const message = property.isReference() || property.isBackReference() ?\n            `Reference ${reflection.getClassName()}.${name} was not loaded. Use joinWith(), useJoinWith(), etc to populate the reference.`\n            :\n            `Can not access ${reflection.getClassName()}.${name} since class was not completely hydrated. Use 'await hydrateEntity(${reflection.getClassName()})' to completely load it.`;\n\n        Object.defineProperty(Reference.prototype, property.name, {\n            enumerable: true,\n            configurable: true,\n            get() {\n                if (this.hasOwnProperty(property.symbol)) {\n                    return this[property.symbol];\n                }\n\n                if (typeSettings.unpopulatedCheck === UnpopulatedCheck.Throw) {\n                    throw new Error(message);\n                }\n\n                if (typeSettings.unpopulatedCheck === UnpopulatedCheck.ReturnSymbol) {\n                    return unpopulatedSymbol;\n                }\n            },\n            set(v) {\n                if (typeSettings.unpopulatedCheck === UnpopulatedCheck.None) {\n                    //when this check is off, this item is being constructed so we ignore initial set operations\n                    return;\n                }\n\n                // when we set value, we just accept it and treat all\n                // properties accessors that don't throw the Error above as \"updated\"\n                Object.defineProperty(this, property.symbol, {\n                    enumerable: false,\n                    writable: true,\n                    value: v\n                });\n            }\n        });\n    }\n\n    return Reference as ClassType<T>;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 11810, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11816, "column": 0}, "map": {"version":3,"file":"typeguard.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/typeguard.ts"],"sourcesContent":["import { ReceiveType, resolveReceiveType } from './reflection/reflection.js';\nimport { createTypeGuardFunction, Guard, serializer, Serializer, TemplateState } from './serializer.js';\nimport { NoTypeReceived } from './utils.js';\nimport { ValidationError, ValidationErrorItem } from './validator.js';\nimport { getTypeJitContainer } from './reflection/type.js';\n\n/**\n * ```typescript\n * const validator = getValidatorFunction<MyType>();\n *\n * const errors: ValidationErrorItem[] = [];\n * const valid = validator(data, {errors})\n *\n * if (errors.length) console.log(errors); //validation failed if not empty\n * ```\n */\nexport function getValidatorFunction<T>(serializerToUse: Serializer = serializer, receiveType?: ReceiveType<T>): Guard<T> {\n    if (!receiveType) throw new NoTypeReceived();\n    const type = resolveReceiveType(receiveType);\n    const jit = getTypeJitContainer(type);\n    if (jit.__is) {\n        return jit.__is;\n    }\n    const fn = createTypeGuardFunction(type, {\n        validation: 'strict'\n    }, serializerToUse) || (() => undefined);\n    jit.__is = fn;\n    return fn as Guard<T>;\n}\n\nexport function is<T>(data: any, serializerToUse: Serializer = serializer, errors: ValidationErrorItem[] = [], receiveType?: ReceiveType<T>): data is T {\n    //`errors` is passed to `is` to trigger type validations as well\n    const fn = getValidatorFunction(serializerToUse, receiveType);\n    return fn(data, { errors }) as boolean;\n}\n\nexport function guard<T>(serializerToUse: Serializer = serializer, receiveType?: ReceiveType<T>): Guard<T> {\n    const fn = getValidatorFunction(serializerToUse, receiveType);\n    return ((data: any) => fn(data, { errors: [] })) as Guard<T>;\n}\n\n/**\n * @throws ValidationError when type is invalid.\n */\nexport function assert<T>(data: any, serializerToUse: Serializer = serializer, receiveType?: ReceiveType<T>): asserts data is T {\n    const errors: ValidationErrorItem[] = [];\n    is(data, serializerToUse, errors, receiveType);\n    if (errors.length) {\n        throw new ValidationError(errors, resolveReceiveType(receiveType));\n    }\n}\n"],"names":[],"mappings":";;;;;;+BAAgD,4BAA4B;wCACU,iBAAiB;AACvG,OAAO,EAAE,cAAc,EAAE,MAAM,YAAY,CAAC;AAC5C,OAAO,EAAE,eAAe,EAAE,mBAAmB,EAAE,MAAM,gBAAgB,CAAC;AACtE,OAAO,EAAE,mBAAmB,EAAE,MAAM,sBAAsB,CAAC;;;;;;;;;;;;AAYrD,SAAU,oBAAoB,CAAI,wLAA8B,aAAU,EAAE,cAAlE,oBAAoB,CAAA,CAAA,EAAA,CAAA,EAA0E;IAA9F,oBAAoB,CAAA,CAAA,GAAA;IAChC,IAAI,CAAC,WAAW,EAAE,MAAM,qKAAI,iBAAc,EAAE,CAAC;IAC7C,MAAM,IAAI,2LAAG,qBAAA,AAAkB,EAAC,WAAW,CAAC,CAAC;IAC7C,MAAM,GAAG,GAAG,wMAAA,AAAmB,EAAC,IAAI,CAAC,CAAC;IACtC,IAAI,GAAG,CAAC,IAAI,EAAE,CAAC;QACX,OAAO,GAAG,CAAC,IAAI,CAAC;IACpB,CAAC;IACD,MAAM,EAAE,OAAG,gMAAA,AAAuB,EAAC,IAAI,EAAE;QACrC,UAAU,EAAE,QAAQ;KACvB,EAAE,eAAe,CAAC,IAAI,CAAC,GAAG,CAAG,CAAD,QAAU,CAAC,CAAC;IACzC,GAAG,CAAC,IAAI,GAAG,EAAE,CAAC;IACd,OAAO,EAAc,CAAC;CACzB;;;;;;;;;;;AAEK,SAAU,EAAE,CAAI,IAAS,EAAE,wLAA8B,aAAU,EAAE,SAAgC,EAAE,EAAE,cAA/F,EAAE,CAAA,CAAA,EAAA,CAAA,EAAyH;IAA3H,EAAE,CAAA,CAAA,GAAA;IACd,gEAAgE;IAChE,MAAM,EAAE,GAAG,oBAAoB,CAAC,eAAe,EAAE,WAAW,CAAC,CAAC;IAC9D,OAAO,EAAE,CAAC,IAAI,EAAE;QAAE,MAAM;IAAA,CAAE,CAAY,CAAC;CAC1C;;;;;;;;;;;;;;AAEK,SAAU,KAAK,CAAI,wLAA8B,aAAU,EAAE,cAAnD,KAAK,CAAA,CAAA,EAAA,CAAA,EAA0E;IAA/E,KAAK,CAAA,CAAA,GAAA;IACjB,MAAM,EAAE,GAAG,oBAAoB,CAAC,eAAe,EAAE,WAAW,CAAC,CAAC;IAC9D,OAAO,aAAC,CAAC,IAAS,EAAE,CAAG,CAAD,CAAG,CAAC,IAAI,EAAE;YAAE,MAAM,EAAE,EAAE;QAAA,CAAE,CAAC,EAAA;QAAA;QAAA;QAAA;KAAA,EAAa,CAAC;CAChE;;;;;;;;;;;AAKK,SAAU,MAAM,CAAI,IAAS,EAAE,uLAA8B,cAAU,EAAE,cAA/D,MAAM,CAAA,CAAA,EAAA,CAAA,EAAqF;IAA3F,MAAM,CAAA,CAAA,GAAA;IAClB,MAAM,MAAM,GAA0B,EAAE,CAAC;IACzC,EAAE,CAAC,IAAI,EAAE,eAAe,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;IAC/C,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC;QAChB,MAAM,yKAAI,kBAAe,CAAC,MAAM,0LAAE,qBAAA,AAAkB,EAAC,WAAW,CAAC,CAAC,CAAC;IACvE,CAAC;CACJ"}},
    {"offset": {"line": 11922, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11928, "column": 0}, "map": {"version":3,"file":"validator.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/validator.ts"],"sourcesContent":["import { ReceiveType } from './reflection/reflection.js';\nimport { getValidatorFunction, is } from './typeguard.js';\nimport { CustomError } from '@deepkit/core';\nimport { stringifyType, Type } from './reflection/type.js';\nimport { entity } from './decorator.js';\nimport { serializer, Serializer } from './serializer.js';\n\nexport type ValidatorMeta<Name extends string, Args extends [...args: any[]] = []> = { __meta?: never & ['validator', Name, Args] }\n\nexport type ValidateFunction = (value: any, type: Type, options: any) => ValidatorError | void;\nexport type Validate<T extends ValidateFunction, Options extends Parameters<T>[2] = unknown> = ValidatorMeta<'function', [T, Options]>;\nexport type Pattern<T extends RegExp> = ValidatorMeta<'pattern', [T]>;\nexport type Alpha = ValidatorMeta<'alpha'>;\nexport type Alphanumeric = ValidatorMeta<'alphanumeric'>;\nexport type Ascii = ValidatorMeta<'ascii'>;\nexport type Decimal<MinDigits extends number = 1, MaxDigits extends number = 100> = ValidatorMeta<'decimal', [MinDigits, MaxDigits]>;\nexport type MultipleOf<Num extends number> = ValidatorMeta<'multipleOf', [Num]>;\nexport type MinLength<Length extends number> = ValidatorMeta<'minLength', [Length]>;\nexport type MaxLength<Length extends number> = ValidatorMeta<'maxLength', [Length]>;\n\nexport type Includes<T extends string | number | boolean> = ValidatorMeta<'includes', [T]>;\nexport type Excludes<T extends string | number | boolean> = ValidatorMeta<'excludes', [T]>;\n\nexport type Minimum<T extends number | bigint> = ValidatorMeta<'minimum', [T]>;\nexport type Maximum<T extends number | bigint> = ValidatorMeta<'maximum', [T]>;\n\n/**\n Includes 0. Use PositiveNoZero to exclude 0.\n */\nexport type Positive = ValidatorMeta<'positive', unknown & [true]>;\n\n/**\n * Includes 0. Use NegativeNoZero to exclude 0.\n */\nexport type Negative = ValidatorMeta<'negative', [true]>;\n\nexport type PositiveNoZero = ValidatorMeta<'positive', [false]>;\nexport type NegativeNoZero = ValidatorMeta<'negative', [false]>;\n\nexport type ExclusiveMinimum<T extends number | bigint> = ValidatorMeta<'exclusiveMinimum', [T]>;\nexport type ExclusiveMaximum<T extends number | bigint> = ValidatorMeta<'exclusiveMaximum', [T]>;\n\nexport type BeforeDate<T extends number> = ValidatorMeta<'beforeDate', [T]>;\nexport type AfterDate<T extends number> = ValidatorMeta<'afterDate', [T]>;\nexport type BeforeNow = ValidatorMeta<'beforeNow'>;\nexport type AfterNow = ValidatorMeta<'afterNow'>;\n\nexport const EMAIL_REGEX = /^\\S+@\\S+$/;\nexport type Email = string & Pattern<typeof EMAIL_REGEX>;\n\n/**\n * Used in validator functions.\n */\nexport class ValidatorError {\n    constructor(\n        public readonly code: string,\n        public readonly message: string,\n        public readonly path?: string,\n    ) {\n    }\n}\n\n/**\n * The structure of a validation error.\n *\n * Path defines the shallow or deep path (using dots).\n * Message is an arbitrary message in english.\n *\n * In validators please use and return `new ValidatorError('code', 'message')` instead.\n */\nexport class ValidationErrorItem {\n    constructor(\n        /**\n         * The path to the property. Might be a deep path separated by dot.\n         */\n        public readonly path: string,\n        /**\n         * A lower cased error code that can be used to identify this error and translate.\n         */\n        public readonly code: string,\n        /**\n         * Free text of the error.\n         */\n        public readonly message: string,\n        /**\n         * Optional value that caused the error.\n         */\n        public readonly value?: any,\n    ) {\n        this.path = path && path[0] === '.' ? path.slice(1) : path;\n    }\n\n    toString(prefix: string = '') {\n        let messagedCausedBy = '';\n        if (this.value !== undefined) {\n            //serialise the value and trim to 100 chars max\n            let serialisedValue = JSON.stringify(this.value);\n            if (serialisedValue.length > 100) serialisedValue = serialisedValue.slice(0, 100) + '...';\n            messagedCausedBy = ` caused by value ${serialisedValue}`;\n        }\n\n        return `${(prefix ? prefix + '.' : '') + this.path}(${this.code}): ${this.message}${messagedCausedBy}`;\n    }\n}\n\n@entity.name('@error:validation')\nexport class ValidationError extends CustomError {\n    constructor(\n        public readonly errors: ValidationErrorItem[],\n        type?: Type,\n    ) {\n        super(`Validation error${type ? ` for type ${stringifyType(type)}` : ''}:\\n${errors.map(v => v.toString()).join(',\\n')}`);\n    }\n\n    static from(errors: { path: string, message: string, code?: string, value?: any }[]) {\n        return new ValidationError(errors.map(v => new ValidationErrorItem(v.path, v.code || '', v.message, v.value)));\n    }\n}\n\n/**\n * Returns empty array when valid, or ValidationErrorItem[] with detailed error messages if not valid.\n *\n * Returns validation error items when failed. If successful returns an empty array.\n */\nexport function validate<T>(data: any, type?: ReceiveType<T>): ValidationErrorItem[] {\n    const errors: ValidationErrorItem[] = [];\n    is(data, undefined, errors, type);\n    return errors;\n}\n\nexport function validateFunction<T>(serializerToUse: Serializer = serializer, type?: ReceiveType<T>): (data: T) => ValidationErrorItem[] {\n    const fn = getValidatorFunction(serializerToUse, type);\n    return (data: T) => {\n        const errors: ValidationErrorItem[] = [];\n        fn(data, { errors });\n        return errors;\n    };\n}\n\n/**\n * Returns true when valid, and false if not.\n */\nexport function validates<T>(data: any, type?: ReceiveType<T>): boolean {\n    const errors = validate(data, type);\n    return errors.length === 0;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12349, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12355, "column": 0}, "map": {"version":3,"file":"validators.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/validators.ts"],"sourcesContent":["import { isArray } from '@deepkit/core';\nimport { ValidatorError } from './validator.js';\nimport { TypeLiteral } from './reflection/type.js';\n\nexport const validators: { [name in string]?: (...args: any[]) => (value: any) => ValidatorError | undefined } = {\n    pattern(type: TypeLiteral) {\n        return (value: any) => {\n            if ('string' !== typeof value) return;\n            if (type.literal instanceof RegExp) {\n                if (type.literal.exec(value)) return;\n                return new ValidatorError('pattern', `Pattern ${type.literal.source} does not match`);\n            }\n            return;\n        };\n    },\n\n    alpha() {\n        return (value: any) => {\n            if ('string' !== typeof value) return;\n            if (value.length === 0) return;\n            if (/^[A-Z]+$/i.test(value)) return;\n            return new ValidatorError('alpha', 'Not alpha');\n        };\n    },\n\n    alphanumeric() {\n        return (value: any) => {\n            if ('string' !== typeof value) return;\n            if (value.length === 0) return;\n            if (/^[0-9A-Z]+$/i.test(value)) return;\n            return new ValidatorError('alphanumeric', 'Not alphanumeric');\n        };\n    },\n\n    ascii() {\n        return (value: any) => {\n            if ('string' !== typeof value) return;\n            if (value.length === 0) return;\n            if (/^[\\x00-\\x7F]+$/.test(value)) return;\n            return new ValidatorError('ascii', 'Not ASCII');\n        };\n    },\n\n    dataURI() {\n        return (value: any) => {\n            if ('string' !== typeof value) return;\n            if (/^(data:)([\\w\\/\\+-]*)(;charset=[\\w-]+|;base64){0,1},(.*)/gi.test(value)) return;\n            return new ValidatorError('dataURI', 'Not a data URI');\n        };\n    },\n\n    decimal(minDigits: TypeLiteral & { literal: number }, maxDigits: TypeLiteral & { literal: number }) {\n        const regexp = new RegExp('^-?\\\\d+\\\\.\\\\d{' + minDigits.literal + ',' + maxDigits.literal + '}$');\n        return (value: any) => {\n            if ('string' !== typeof value) return;\n            if (regexp.test(value)) return;\n            return new ValidatorError('decimal', `Not a decimal(x.${minDigits.literal}-${maxDigits.literal})`);\n        };\n    },\n\n    multipleOf(num: TypeLiteral & { literal: number }) {\n        return (value: any) => {\n            if ('number' !== typeof value) return;\n            if (value % num.literal === 0) return;\n            return new ValidatorError('multipleOf', 'Not a multiple of ' + num.literal);\n        };\n    },\n\n    minLength(length: TypeLiteral & { literal: number }) {\n        return (value: any) => {\n            if ('string' !== typeof value && !isArray(value)) return;\n            if (value.length >= length.literal) return;\n\n            return new ValidatorError('minLength', 'Min length is ' + length.literal);\n        };\n    },\n\n    maxLength(length: TypeLiteral & { literal: number }) {\n        return (value: any) => {\n            if ('string' !== typeof value && !isArray(value)) return;\n            if (value.length <= length.literal) return;\n\n            return new ValidatorError('maxLength', 'Max length is ' + length.literal);\n        };\n    },\n\n    includes(include: TypeLiteral) {\n        return (value: any) => {\n            if ('string' !== typeof value && !isArray(value)) return;\n            if (value.includes(include.literal as any)) return;\n\n            return new ValidatorError('includes', `Needs to include '${String(include.literal)}'`);\n        };\n    },\n\n    excludes(excludes: TypeLiteral) {\n        return (value: any) => {\n            if ('string' !== typeof value && !isArray(value)) return;\n            if (!value.includes(excludes.literal as any)) return;\n            return new ValidatorError('excludes', `Needs to exclude '${String(excludes.literal)}'`);\n        };\n    },\n\n    minimum(min: TypeLiteral & { literal: number | bigint }) {\n        return (value: any) => {\n            if ('number' !== typeof value && 'bigint' !== typeof value) return;\n            if (value < min.literal) return new ValidatorError('minimum', 'Number needs to be greater than or equal to ' + min.literal);\n            return;\n        };\n    },\n\n    exclusiveMinimum(min: TypeLiteral & { literal: number | bigint }) {\n        return (value: any) => {\n            if ('number' !== typeof value && 'bigint' !== typeof value) return;\n            if (value <= min.literal) return new ValidatorError('minimum', 'Number needs to be greater than ' + min.literal);\n            return;\n        };\n    },\n\n    maximum(max: TypeLiteral & { literal: number | bigint }) {\n        return (value: any) => {\n            if ('number' !== typeof value && 'bigint' !== typeof value) return;\n            if (value > max.literal) return new ValidatorError('maximum', 'Number needs to be smaller than or equal to ' + max.literal);\n            return;\n        };\n    },\n\n    exclusiveMaximum(max: TypeLiteral & { literal: number | bigint }) {\n        return (value: any) => {\n            if ('number' !== typeof value && 'bigint' !== typeof value) return;\n            if (value >= max.literal) return new ValidatorError('maximum', 'Number needs to be smaller than ' + max.literal);\n            return;\n        };\n    },\n\n    positive(includingZero: TypeLiteral & { literal: boolean }) {\n        return (value: any) => {\n            if ('number' !== typeof value && 'bigint' !== typeof value) return;\n            if (value > 0) return;\n            if (includingZero.literal && value === 0) return;\n\n            return new ValidatorError('positive', 'Number needs to be positive');\n        };\n    },\n\n    negative(includingZero: TypeLiteral & { literal: boolean }) {\n        return (value: any) => {\n            if ('number' !== typeof value && 'bigint' !== typeof value) return;\n            if (value < 0) return;\n            if (includingZero.literal && value === 0) return;\n\n            return new ValidatorError('negative', 'Number needs to be negative');\n        };\n    },\n\n    beforeDate(date: TypeLiteral & { literal: number }) {\n        return (value: any) => {\n            if (!(value instanceof Date)) return;\n            if (value.getTime() < date.literal) return;\n\n            return new ValidatorError('beforeDate', `Dates needs to be before ${date.literal}`);\n        };\n    },\n\n    afterDate(date: TypeLiteral & { literal: number }) {\n        return (value: any) => {\n            if (!(value instanceof Date)) return;\n            if (value.getTime() > date.literal) return;\n\n            return new ValidatorError('beforeDate', `Dates needs to be after ${date.literal}`);\n        };\n    },\n\n    beforeNow() {\n        return (value: any) => {\n            if (!(value instanceof Date)) return;\n            if (value.getTime() < Date.now()) return;\n\n            return new ValidatorError('beforeDate', `Dates needs to be in the past`);\n        };\n    },\n\n    afterNow() {\n        return (value: any) => {\n            if (!(value instanceof Date)) return;\n            if (value.getTime() > Date.now()) return;\n\n            return new ValidatorError('beforeDate', `Dates needs to be in the future`);\n        };\n    },\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12609, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12615, "column": 0}, "map": {"version":3,"file":"serializer.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/serializer.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport {\n    ClassType,\n    CompilerContext,\n    CustomError,\n    getObjectKeysSize,\n    hasProperty,\n    isArray,\n    isFunction,\n    isInteger,\n    isIterable,\n    isNumeric,\n    isObject,\n    isObjectLiteral,\n    iterableSize,\n    stringifyValueWithType,\n    toFastProperties,\n} from '@deepkit/core';\nimport {\n    AnnotationDefinition,\n    assertType,\n    binaryBigIntAnnotation,\n    BinaryBigIntType,\n    binaryTypes,\n    copyAndSetParent,\n    embeddedAnnotation,\n    EmbeddedOptions,\n    excludedAnnotation,\n    FindType,\n    getConstructorProperties,\n    getDeepConstructorProperties,\n    getEnumValueIndexMatcher,\n    getTypeJitContainer,\n    getTypeObjectLiteralFromTypeClass,\n    groupAnnotation,\n    hasDefaultValue,\n    hasEmbedded,\n    isBackReferenceType,\n    isCustomTypeClass,\n    isMongoIdType,\n    isNullable,\n    isOptional,\n    isPropertyMemberType,\n    isReferenceType,\n    isType,\n    isUUIDType,\n    mapNameAnnotation,\n    memberNameToString,\n    referenceAnnotation,\n    ReflectionKind,\n    resolveTypeMembers,\n    stringifyResolvedType,\n    stringifyType,\n    Type,\n    TypeArray,\n    TypeClass,\n    TypeIndexSignature,\n    TypeObjectLiteral,\n    TypeParameter,\n    TypeProperty,\n    TypePropertySignature,\n    typeToObject,\n    TypeTuple,\n    TypeUnion,\n    validationAnnotation,\n} from './reflection/type.js';\nimport { TypeNumberBrand } from '@deepkit/type-spec';\nimport { hasCircularReference, ReflectionClass, ReflectionProperty } from './reflection/reflection.js';\nimport { extendTemplateLiteral, isExtendable } from './reflection/extends.js';\nimport { resolveRuntimeType } from './reflection/processor.js';\nimport { createReference, isReferenceHydrated, isReferenceInstance } from './reference.js';\nimport { validate, ValidationError, ValidationErrorItem } from './validator.js';\nimport { validators } from './validators.js';\nimport {\n    arrayBufferToBase64,\n    base64ToArrayBuffer,\n    base64ToTypedArray,\n    typedArrayToBase64,\n    typeSettings,\n    UnpopulatedCheck,\n    unpopulatedSymbol,\n} from './core.js';\n\n/**\n * Make sure to change the id when a custom naming strategy is implemented, since caches are based on it.\n */\nexport class NamingStrategy {\n    constructor(public id: string = 'default') {\n    }\n\n    getPropertyName(type: TypeProperty | TypePropertySignature, forSerializer: string): string | undefined {\n        for (const mapName of mapNameAnnotation.getAnnotations(type.type)) {\n            if (!mapName.serializer || mapName.serializer === forSerializer) return mapName.name;\n        }\n\n        return memberNameToString(type.name);\n    }\n}\n\nexport const underscoreNamingStrategy = new class extends NamingStrategy {\n    constructor() {\n        super('underscore');\n    }\n\n    getPropertyName(type: TypeProperty | TypePropertySignature, forSerializer: string): string | undefined {\n        const name = super.getPropertyName(type, forSerializer);\n        if (!name) return name;\n        return name.replace(/([A-Z])/g, '_$1').toLowerCase();\n    }\n};\n\n/**\n * Options that can be passed to the serialization/deserialization functions\n * and change the behavior in runtime (not embedded in JIT).\n */\nexport interface SerializationOptions {\n    /**\n     * Which groups to include. If a property is not assigned to\n     * a given group, it will be excluded.\n     * Use an empty array to include only non-grouped properties.\n     */\n    groups?: string[];\n\n    /**\n     * Which groups to exclude. If a property is assigned to at least\n     * one given group, it will be excluded. Basically the opposite of\n     * `groups`, but you can combine both.\n     * Use an empty array to exclude only non-grouped properties.\n     */\n    groupsExclude?: string[];\n\n    /**\n     * Allows more loosely data for certain types. e.g.\n     *\n     * - '1', '0', 'true', 'false' will be converted to true|false for boolean type.\n     * - '1' will be converted to number for number type.\n     * - 1 will be converted to string for string type.\n     *\n     * This will activate all registered type guards with negative specifically.\n     *\n     * This is enabled by default.\n     */\n    loosely?: boolean;\n}\n\nfunction isGroupAllowed(options: SerializationOptions, groupNames: string[]): boolean {\n    if (!options.groups && !options.groupsExclude) return true;\n\n    if (options.groupsExclude) {\n        if (options.groupsExclude.length === 0 && groupNames.length === 0) {\n            return false;\n        }\n        for (const group of options.groupsExclude) {\n            if (groupNames.includes(group)) {\n                return false;\n            }\n        }\n    }\n\n    if (options.groups) {\n        if (options.groups.length === 0 && groupNames.length === 0) {\n            return true;\n        }\n        for (const group of options.groups) {\n            if (groupNames.includes(group)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    return true;\n}\n\n\nexport type SerializeFunction<T = any, R = any> = (data: T, state?: SerializationOptions) => R;\n\nexport function getPartialType(type: TypeClass | TypeObjectLiteral) {\n    const jitContainer = getTypeJitContainer(type);\n    if (jitContainer.partialType) return jitContainer.partialType;\n    type = copyAndSetParent(type);\n    const reflection = ReflectionClass.from(type);\n    type.types = reflection.type.types.map(v => ({ ...v })) as any;\n    for (const member of type.types) {\n        if (member.kind === ReflectionKind.propertySignature || member.kind === ReflectionKind.property) {\n            member.optional = true;\n        }\n    }\n    return jitContainer.partialType = getTypeObjectLiteralFromTypeClass(type);\n}\n\n/**\n * Creates a (cached) Partial<T> of the given type and returns a (cached) serializer function for the given registry (serialize or deserialize).\n */\nexport function getPartialSerializeFunction(type: TypeClass | TypeObjectLiteral, registry: TemplateRegistry, namingStrategy: NamingStrategy = new NamingStrategy()) {\n    return getSerializeFunction(getPartialType(type), registry, namingStrategy);\n}\n\n/**\n * Returns a (cached) serializer function for the given registry (serialize or deserialize).\n */\nexport function getSerializeFunction(type: Type, registry: TemplateRegistry, namingStrategy: NamingStrategy = new NamingStrategy(), path: string = '', jitStack = new JitStack()): SerializeFunction {\n    const jit = getTypeJitContainer(type);\n    const id = registry.id + '_' + namingStrategy.id + '_' + path;\n    if (jit[id]) return jit[id];\n\n    jit[id] = createSerializeFunction(type, registry, namingStrategy, path, jitStack);\n    toFastProperties(jit);\n\n    return jit[id];\n}\n\nexport function createSerializeFunction(type: Type, registry: TemplateRegistry, namingStrategy: NamingStrategy = new NamingStrategy(), path: string | RuntimeCode | (string | RuntimeCode)[] = '', jitStack = new JitStack()): SerializeFunction {\n    const compiler = new CompilerContext();\n\n    const state = new TemplateState('result', 'data', compiler, registry, namingStrategy, jitStack, isArray(path) ? path : path ? [path] : []);\n    if (state.registry === state.registry.serializer.deserializeRegistry) {\n        state.target = 'deserialize';\n    }\n\n    //set unpopulatedCheck to ReturnSymbol to jump over those properties\n    compiler.context.set('typeSettings', typeSettings);\n    compiler.context.set('UnpopulatedCheck', UnpopulatedCheck);\n    compiler.context.set('UnpopulatedCheckReturnSymbol', UnpopulatedCheck.ReturnSymbol);\n    compiler.context.set('SerializationError', SerializationError);\n    compiler.context.set('ValidationErrorItem', ValidationErrorItem);\n\n    const code = `\n        var result;\n        state = state ? state : {};\n        var oldUnpopulatedCheck = typeSettings.unpopulatedCheck;\n        typeSettings.unpopulatedCheck = UnpopulatedCheckReturnSymbol;\n        ${executeTemplates(state, type)}\n        typeSettings.unpopulatedCheck = oldUnpopulatedCheck;\n        return result;\n    `;\n\n    return compiler.build(code, 'data', 'state');\n}\n\nexport type Guard<T> = (data: any, state?: { errors?: ValidationErrorItem[] }) => data is T;\n\nexport function createTypeGuardFunction(type: Type, stateIn?: Partial<TemplateState>, serializerToUse?: Serializer, withLoose = true): undefined | Guard<any> {\n    const compiler = new CompilerContext();\n\n    let state: TemplateState;\n    if (stateIn instanceof TemplateState) {\n        state = stateIn.fork('result');\n        state.compilerContext = compiler;\n    } else {\n        state = new TemplateState('result', 'data', compiler, (serializerToUse || serializer).typeGuards.getRegistry(1));\n        if (stateIn) Object.assign(state, stateIn);\n    }\n    state.path = [new RuntimeCode('_path')];\n    state.setterDisabled = false;\n\n    const templates = state.registry.get(type);\n    if (!templates.length) return undefined;\n\n    executeTemplates(state, type, withLoose);\n\n    compiler.context.set('typeSettings', typeSettings);\n    //set unpopulatedCheck to ReturnSymbol to jump over those properties\n    compiler.context.set('UnpopulatedCheckReturnSymbol', UnpopulatedCheck.ReturnSymbol);\n\n    const code = `\n        var result;\n        if (_path === undefined) _path = '';\n        state = state ? state : {};\n        var oldUnpopulatedCheck = typeSettings.unpopulatedCheck;\n        typeSettings.unpopulatedCheck = UnpopulatedCheckReturnSymbol;\n        ${state.template}\n        typeSettings.unpopulatedCheck = oldUnpopulatedCheck;\n        return result === true;\n    `;\n    return compiler.build(code, 'data', 'state', '_path', 'property');\n}\n\nexport class SerializationError extends CustomError {\n    constructor(public originalMessage: string, public code: string = '', public path: string = '') {\n        super(`Serialization failed. ${!path ? '' : (path && path.startsWith('.') ? path.slice(1) : path) + ': '}` + originalMessage);\n    }\n}\n\nexport class RuntimeCode {\n    constructor(public code: string) {\n    }\n}\n\nexport function collapsePath(path: (string | RuntimeCode)[], prefix?: string): string {\n    return path.filter(v => !!v).map(v => v instanceof RuntimeCode ? v.code : JSON.stringify(v)).join(`+'.'+`) || `''`;\n}\n\nexport function getPropertyNameString(propertyName?: string | RuntimeCode) {\n    return propertyName ? collapsePath([propertyName]) : '';\n}\n\n/**\n * internal: The jit stack cache is used in both serializer and guards, so its cache key needs to be aware of it\n */\nexport class JitStack {\n    protected stacks: { registry?: TemplateRegistry, map: Map<Type, { fn: Function | undefined, id: number }> }[] = [];\n    protected id: number = 0;\n\n    getStack(registry?: TemplateRegistry) {\n        for (const stack of this.stacks) {\n            if (stack.registry === registry) return stack.map;\n        }\n        const map = new Map<Type, { fn: Function | undefined, id: number }>();\n        this.stacks.push({ registry, map });\n        return map;\n    }\n\n    has(registry: TemplateRegistry, type: Type): boolean {\n        return this.getStack(registry).has(type);\n    }\n\n    get(registry: TemplateRegistry, type: Type) {\n        return this.getStack(registry).get(type);\n    }\n\n    prepare(registry: TemplateRegistry, type: Type): { id: number, prepare: (fn: Function) => { fn: Function | undefined } } {\n        if (this.getStack(registry).has(type)) {\n            throw new Error('Circular jit building detected: ' + stringifyType(type));\n        }\n\n        const entry: { fn: Function | undefined, id: number } = { fn: undefined, id: this.id++ };\n        this.getStack(registry).set(type, entry);\n        return {\n            id: entry.id, prepare: (fn: Function) => {\n                entry.fn = fn;\n                return entry;\n            },\n        };\n    }\n\n    getOrCreate(registry: TemplateRegistry | undefined, type: Type, create: () => Function): { fn: Function | undefined, id: number } {\n        const stack = this.getStack(registry);\n        const existing = stack.get(type);\n        if (existing) return existing;\n\n        const entry: { fn: Function | undefined, id: number } = { fn: undefined, id: this.id++ };\n        stack.set(type, entry);\n        entry.fn = create();\n        return entry;\n    }\n}\n\nexport class ContainerAccessor {\n    constructor(public container: string | ContainerAccessor, public property: string) {\n    }\n\n    toString() {\n        return `${this.container}[${this.property}]`;\n    }\n}\n\nexport class TemplateState {\n    /**\n     * Before and after template content is rendered before/after all other templates.\n     * When a template is put into its own function, before/after templates are run outside of this function.\n     */\n    public template = '';\n\n    public ended = false;\n    public setter: string | ContainerAccessor = '';\n    public accessor: string | ContainerAccessor = '';\n\n    /**\n     * Strict means only use type guards of specificality of 1 (used for is()/validation()).\n     * For deserialization loose is used.\n     */\n    public validation?: 'strict' | 'loose';\n\n    /**\n     * When this is set all specificalities are used (used in union type guards to detect which member to pick).\n     */\n    public allSpecificalities?: TypeGuardRegistry;\n\n    public propertyName?: string | RuntimeCode;\n    public setterDisabled: boolean = false;\n\n    public parentTypes: Type[] = [];\n\n    public target: 'serialize' | 'deserialize' = 'serialize';\n\n    protected handledAnnotations: AnnotationDefinition[] = [];\n\n    constructor(\n        public originalSetter: string | ContainerAccessor,\n        public originalAccessor: string | ContainerAccessor,\n        public compilerContext: CompilerContext,\n        public registry: TemplateRegistry,\n        public namingStrategy: NamingStrategy = new NamingStrategy,\n        public jitStack: JitStack = new JitStack(),\n        public path: (string | RuntimeCode)[] = [],\n    ) {\n        this.setter = originalSetter;\n        this.accessor = originalAccessor;\n    }\n\n    isValidation(): boolean {\n        return !!this.validation;\n    }\n\n    withValidation(validation: this['validation']): this {\n        this.validation = validation;\n        return this;\n    }\n\n    includeAllSpecificalities(guardRegistry: TypeGuardRegistry): this {\n        this.allSpecificalities = guardRegistry;\n        return this;\n    }\n\n    replaceTemplate(template: string) {\n        this.template = template;\n    }\n\n    /**\n     * Forks as state, with an empty propertyName.\n     */\n    fork(setter?: string | ContainerAccessor, accessor?: string | ContainerAccessor, path?: (string | RuntimeCode)[]): TemplateState {\n        const state = new TemplateState(setter ?? this.setter, accessor ?? this.accessor, this.compilerContext, this.registry, this.namingStrategy, this.jitStack, path || this.path.slice(0));\n        state.validation = this.validation;\n        state.setterDisabled = this.setterDisabled;\n        state.target = this.target;\n        state.parentTypes = this.parentTypes;\n        state.allSpecificalities = this.allSpecificalities;\n        state.handledAnnotations = this.handledAnnotations.slice();\n        return state;\n    }\n\n    fullFork() {\n        return this.fork().forPropertyName(this.propertyName);\n    }\n\n    forRegistry(registry: TemplateRegistry) {\n        this.registry = registry;\n        return this;\n    }\n\n    forPropertyName(name?: string | number | symbol | RuntimeCode): this {\n        if (name === undefined) return this;\n        this.propertyName = name instanceof RuntimeCode ? name : String(name);\n        return this;\n    }\n\n    disableSetter(): this {\n        this.setterDisabled = true;\n        return this;\n    }\n\n    enableSetter(): this {\n        this.setterDisabled = true;\n        return this;\n    }\n\n    /**\n     * Can be used to track which annotation was already handled. Necessary to use with `isAnnotationHandled` to avoid infinite recursive loops\n     * when a serializer template issues sub calls depending on annotation data.\n     */\n    annotationHandled(annotation: AnnotationDefinition<any>): void {\n        this.handledAnnotations.push(annotation);\n    }\n\n    isAnnotationHandled(annotation: AnnotationDefinition<any>): boolean {\n        return this.handledAnnotations.includes(annotation);\n    }\n\n    get isSerialization(): boolean {\n        return this.target === 'serialize';\n    }\n\n    get isDeserialization(): boolean {\n        return this.target === 'deserialize';\n    }\n\n    extendPath(path: string | RuntimeCode | number | symbol): this {\n        this.path.push(path instanceof RuntimeCode ? path : String(path));\n        return this;\n    }\n\n    assignValidationError(code: string, message: string) {\n        this.setContext({ ValidationErrorItem: ValidationErrorItem });\n        return `if (state.errors) state.errors.push(new ValidationErrorItem(${collapsePath(this.path)}, ${JSON.stringify(code)}, ${JSON.stringify(message)}, ${this.originalAccessor}));`;\n    }\n\n    throwCode(type: Type | string, error?: string, accessor: string | ContainerAccessor = this.originalAccessor) {\n        this.setContext({ ValidationError, stringifyValueWithType });\n        const to = JSON.stringify(('string' === typeof type ? type : stringifyType(type)).replace(/\\n/g, '').replace(/\\s+/g, ' ').trim());\n        return `throw ValidationError.from([{code: 'type', path: ${collapsePath(this.path)}, message: 'Cannot convert ' + ${accessor} + ' to ' + ${to} ${error ? ` + '. ' + ${error}` : ''} }])`;\n    }\n\n    /**\n     * Adds template code for setting the `this.setter` variable. The expression evaluated in `code` is assigned to `this.setter`.\n     * `this.accessor` will point now to `this.setter`.\n     */\n    addSetter(code: string | { toString(): string }) {\n        this.template += `\\n${this.setter} = ${code};`;\n        this.accessor = String(this.setter);\n    }\n\n    addSetterAndReportErrorIfInvalid(errorCode: string, message: string, code: string) {\n        this.addSetter(code);\n        if (this.isValidation()) {\n            this.addCodeForSetter(`if (!${this.setter}) ${this.assignValidationError(errorCode, message)}`);\n        }\n    }\n\n    /**\n     * Adds a converter function that is executed on the current `this.accessor` value.\n     *\n     * @example\n     * ```typescript\n     * serializer.deserializeRegistry.registerClass(Date, (type, state) => {\n     *     // make sure to check `v` as it is any!\n     *     state.convert((v: any) => {\n     *         if ('number' !== typeof v) throw new SerializationError('Expected number');\n     *         return new Date(v);\n     *     });\n     * });\n     *\n     * serializer.serializeRegistry.registerClass(Date, (type, state) => {\n     *     // in serialization `v` is always the specific type\n     *     state.convert((v: Date) => v.getTime());\n     * });\n     * ```\n     */\n    convert(callback: (value: any) => any) {\n        const converter = this.setVariable('convert', callback);\n        this.addCodeForSetter(`\n        try {\n            ${this.setter} = ${converter}(${this.accessor});\n        } catch (error) {\n            if (error instanceof SerializationError) {\n                error.path = ${collapsePath(this.path)} + (error.path ? '.' + error.path : '');\n            }\n            ${this.throwCode('any', 'error.message', this.accessor)};\n        }\n        `);\n    }\n\n    /**\n     * Allows to add a custom code that is executed on the current `this.accessor` value.\n     *\n     * @example\n     * ```typescript\n     * serializer.deserializeRegistry.addDecorator(\n     *     isCustomTypeClass,\n     *     (type, state) => {\n     *         state.touch((value) => {\n     *              if ('onLoad' in value) value.onLoad();\n     *         });\n     *     }\n     * );\n     * ```\n     */\n    touch(callback: (value: any) => void) {\n        const touch = this.setVariable('touch', callback);\n        this.addCode(`${touch}(${this.setter});`);\n    }\n\n    /**\n     * Stop executing next templates.\n     */\n    stop() {\n        this.ended = true;\n    }\n\n    setVariable(name: string, value?: any): string {\n        return this.compilerContext.reserveVariable(name, value);\n    }\n\n    setContext(values: { [name: string]: any }) {\n        this.compilerContext.set(values);\n    }\n\n    addCode(code: string) {\n        this.template += '\\n' + code;\n    }\n\n    /**\n     * Adds template code for setting the `this.setter` variable manually, so use `${state.setter} = value`.\n     * `this.accessor` will point now to `this.setter`.\n     */\n    addCodeForSetter(code: string) {\n        this.template += '\\n' + code;\n        this.accessor = String(this.setter);\n    }\n\n    hasSetterCode(): boolean {\n        return !!this.template;\n    }\n}\n\nexport type Template<T extends Type> = (type: T, state: TemplateState) => void;\n\nexport type TemplateHook = (type: Type, state: TemplateState) => void;\n\n/**\n * Just sets the state.setter to state.accessor without any modification.\n */\nexport function noopTemplate(type: Type, state: TemplateState): void {\n    state.addSetter(state.accessor);\n}\n\ninterface TemplateDecorator {\n    predicate: (type: Type) => boolean,\n    template: Template<any>\n}\n\nexport class TemplateRegistry {\n    protected static ids: number = 0;\n    id: number = TemplateRegistry.ids++;\n\n    protected templates: { [kind in ReflectionKind]?: Template<any>[] } = {};\n    protected decorator: TemplateDecorator[] = [];\n\n    public preHooks: TemplateHook[] = [];\n    public postHooks: TemplateHook[] = [];\n\n    public classTemplates = new Map<ClassType, Template<any>[]>();\n\n    constructor(public serializer: Serializer = new EmptySerializer()) {\n    }\n\n    clear() {\n        this.templates = {};\n        this.classTemplates.clear();\n        this.preHooks = [];\n        this.postHooks = [];\n    }\n\n    get(type: Type): Template<Type>[] {\n        if (type.kind === ReflectionKind.class) {\n            const classTemplates = this.classTemplates.get(type.classType);\n            if (classTemplates && classTemplates.length) return classTemplates;\n            if (type.classType === Set || type.classType === Map || binaryTypes.includes(type.classType)) return [];\n        }\n        return this.templates[type.kind] ||= [];\n    }\n\n    getDecorator(type: Type): Template<Type>[] {\n        return this.decorator.filter(v => v.predicate(type)).map(v => v.template);\n    }\n\n    /**\n     * Registers a template for all binary classes: ArrayBuffer, Uint8Array, Int8Array, etc.\n     */\n    registerBinary(template: Template<TypeClass>) {\n        for (const classType of binaryTypes) this.registerClass(classType, template);\n    }\n\n    /**\n     * Registers a template for a given class type.\n     *\n     * As soon as a single template has registered for the given classType the template registry\n     * only returns templates for this particular classType and omits all general purpose ReflectionKind.class templates for this particular classType.\n     */\n    registerClass(classType: ClassType, template: Template<TypeClass>) {\n        this.classTemplates.set(classType, [template]);\n    }\n\n    prependClass(classType: ClassType, template: Template<TypeClass>) {\n        this.getClassTemplates(classType).unshift(template);\n    }\n\n    appendClass(classType: ClassType, template: Template<TypeClass>) {\n        this.getClassTemplates(classType).push(template);\n    }\n\n    protected getClassTemplates(classType: ClassType): Template<TypeClass>[] {\n        let templates = this.classTemplates.get(classType);\n        if (!templates) {\n            templates = [];\n            this.classTemplates.set(classType, templates);\n        }\n        return templates;\n    }\n\n    addPreHook(callback: TemplateHook) {\n        this.preHooks.push(callback);\n    }\n\n    addPostHook(callback: TemplateHook) {\n        this.postHooks.push(callback);\n    }\n\n    /**\n     * Removes all registered templates.\n     */\n    unregister(kind: ReflectionKind) {\n        this.templates[kind] = undefined;\n    }\n\n    /**\n     * Registers a new template and replaces all existing (added via register,prepend,append).\n     */\n    register<T extends ReflectionKind>(kind: T, template: Template<FindType<Type, T>>) {\n        this.templates[kind] = [template];\n    }\n\n    /**\n     * Registers additional templates that handle type decorators/annotations. The templates can safely assume that the given type in `state.accessor`\n     * is already type-checked to be `T`.\n     *\n     * Decorator templates run last (after normal templates and postHook).\n     *\n     * This split between register and registerForDecorator is made to have a distinction between native type templates and additional user-made templates.\n     * This allows to fetch only decorator templates and decide upon the result whether additional code is necessary or not. (this would not be possible\n     * if everything is added to the `register` call that does always the basic checks).\n     */\n    addDecorator(predicate: (type: Type) => boolean, template: Template<Type>) {\n        this.decorator.push({ predicate, template });\n    }\n\n    /**\n     * Removes all registered decorators for a certain type.\n     */\n    removeDecorator(type: Type) {\n        this.decorator = this.decorator.filter(v => !v.predicate(type));\n    }\n\n    prepend<T extends ReflectionKind>(kind: T, template: Template<FindType<Type, T>>) {\n        this.templates[kind] ||= [];\n        this.templates[kind]!.unshift(template);\n    }\n\n    append<T extends ReflectionKind>(kind: T, template: Template<FindType<Type, T>>) {\n        this.templates[kind] ||= [];\n        this.templates[kind]!.push(template);\n    }\n}\n\n/**\n * To avoid circular builds, class/object literal code is extract to its own function.\n * if this returns true, code is put into state to call an already existing function.\n */\nexport function callExtractedFunctionIfAvailable(state: TemplateState, type: Type): boolean {\n    const jit = state.jitStack.get(state.registry, type);\n    if (!jit) return false;\n    const withSetter = !state.setterDisabled && state.setter;\n    state.addCode(`\n    //call jit=${jit.id} for setter=\"${state.setter}\" via propertyName ${state.propertyName ? collapsePath([state.propertyName]) : ''}\n    ${withSetter ? `${state.setter} = ` : ''}${state.setVariable('jit', jit)}.fn(${state.accessor || 'undefined'}, state, ${collapsePath(state.path)});\n    `);\n    if (withSetter) state.accessor = state.setter;\n    return true;\n}\n\nexport function extractStateToFunctionAndCallIt(state: TemplateState, type: Type) {\n    const prepare = state.jitStack.prepare(state.registry, type);\n    callExtractedFunctionIfAvailable(state, type);\n    return { setFunction: prepare.prepare, id: prepare.id, state: state.fork('result', 'data', [new RuntimeCode('_path')]).forPropertyName(state.propertyName) };\n}\n\nexport function buildFunction(state: TemplateState, type: Type): Function {\n    let circularCheckBeginning = '';\n    let circularCheckEnd = '';\n    if (hasCircularReference(type)) {\n        circularCheckBeginning = `\n        if (data) {\n            if (state._stack) {\n                if (state._stack.includes(data)) return undefined;\n            } else {\n                state._stack = [];\n            }\n            state._stack.push(data);\n        }\n        `;\n        circularCheckEnd = `if (state._stack) state._stack.pop();`;\n    }\n    const code = `\n        var result;\n        if (_path === undefined) _path = '';\n        ${circularCheckBeginning}\n        state = state ? state : {};\n        ${state.template}\n\n        ${circularCheckEnd}\n\n        return result;\n    `;\n    return state.compilerContext.build(code, 'data', 'state', '_path');\n}\n\nexport function executeTemplates(\n    state: TemplateState,\n    type: Type,\n    withLoose: boolean = true,\n    withCache: boolean = true,\n): string {\n    state.parentTypes.push(type);\n\n    let originalState = state;\n\n    if (withLoose && state.validation === 'loose' && state.allSpecificalities) {\n        // check if the particular type has multiple specificalities\n        // if so, we need to generate a type guard that checks all specificalities.\n        // e.g. string supports `'string' === typeof' but as last resort also anything else.\n        // or Date supports `instanceof Date` but also `'string' === typeof` as last resort.\n        // This is not part of a union check. We have to do it for each type.\n        const typeGuards = state.allSpecificalities.getSortedTemplateRegistries();\n        const lines: string[] = [];\n        for (const [specificality, typeGuard] of typeGuards) {\n            const next = state.fork(undefined, 'data').forRegistry(typeGuard);\n            const fn = createTypeGuardFunction(type, next, undefined, false);\n            if (!fn) continue;\n            const guard = state.setVariable('guard_' + ReflectionKind[type.kind], fn);\n            const looseCheck = specificality <= 0 ? `state.loosely !== false && ` : '';\n\n            lines.push(`else if (${looseCheck}${guard}(${state.accessor})) {\n                //type = ${ReflectionKind[type.kind]}, specificality=${specificality}\n                ${state.setter} = true;\n            }`);\n        }\n\n        state.template = `\n            //type guard with multiple specificalities\n            if (false) {} ${lines.join(' ')}\n            else {\n                ${state.setter} = false;\n            }\n        `;\n    } else {\n        let setFunction: undefined | ((fn: Function) => void);\n        if (withCache && (type.kind === ReflectionKind.objectLiteral\n            || type.kind === ReflectionKind.array || type.kind === ReflectionKind.tuple\n            || (type.kind === ReflectionKind.class && (type.classType === Set || type.classType === Map))\n            || isCustomTypeClass(type)) && !embeddedAnnotation.getFirst(type)\n        ) {\n            //wrap circular check if necessary\n            if (callExtractedFunctionIfAvailable(state, type)) {\n                state.parentTypes.pop();\n                return state.template;\n            } else {\n                const extract = extractStateToFunctionAndCallIt(state, type);\n                state.replaceTemplate(`\n                    // extracted jit=${extract.id} function via state.propertyName=\"${getPropertyNameString(state.propertyName)}\"\n                    if (!state._stack || !state._stack.includes(${state.accessor})) {\n                        ${state.template}\n                    }\n                `);\n                state = extract.state;\n                setFunction = extract.setFunction;\n            }\n        }\n\n        const templates = state.registry.get(type);\n        for (const hook of state.registry.preHooks) hook(type, state);\n        for (const template of templates) {\n            template(type, state);\n            if (state.ended) break;\n        }\n        for (const hook of state.registry.postHooks) hook(type, state);\n        for (const template of state.registry.getDecorator(type)) template(type, state);\n\n        if (setFunction) {\n            setFunction(buildFunction(state, type));\n        }\n    }\n\n    state.parentTypes.pop();\n\n    return originalState.template;\n}\n\nexport function createConverterJSForMember(\n    property: ReflectionProperty | TypeProperty | TypePropertySignature | TypeIndexSignature,\n    state: TemplateState,\n    undefinedSetterCode: string = '',\n    nullSetterCode: string = '',\n): string {\n    const { registry, compilerContext, namingStrategy } = state;\n    const type = property instanceof ReflectionProperty ? property.type : property.type;\n    const p = property instanceof ReflectionProperty ? property.property : property;\n\n    state.parentTypes.push(p);\n\n    undefinedSetterCode = undefinedSetterCode || executeTemplates(state.fork(), { kind: ReflectionKind.undefined });\n    nullSetterCode = nullSetterCode || executeTemplates(state.fork(), { kind: ReflectionKind.null });\n\n    let convert = executeTemplates(state.fork(), type);\n    state.parentTypes.pop();\n\n    let postTransform = '';\n\n    const isSerialization = registry.serializer.serializeRegistry === registry;\n    const isDeserialization = registry.serializer.deserializeRegistry === registry;\n\n    if (property instanceof ReflectionProperty) {\n        if (isSerialization) {\n            if (property.serializer) {\n                const fnVar = compilerContext.reserveVariable('transformer', property.serializer);\n                postTransform = `${state.setter} = ${fnVar}(${state.setter}, ${compilerContext.reserveConst(property)})`;\n            }\n        }\n\n        if (isDeserialization) {\n            if (property.deserializer) {\n                const fnVar = compilerContext.reserveVariable('transformer', property.deserializer);\n                postTransform = `${state.setter} = ${fnVar}(${state.setter}, ${compilerContext.reserveConst(property)})`;\n            }\n        }\n    }\n\n    const setExplicitUndefined = registry.serializer.setExplicitUndefined(type, state) && isOptional(property instanceof ReflectionProperty ? property.property : property);\n    const nullable = isNullable(type);\n\n    // // since JSON does not support undefined, we emulate it via using null for serialization, and convert that back to undefined when deserialization happens.\n    // // note: When the value is not defined (property.name in object === false), then this code will never run.\n    // let defaultValue = isSerialization ? 'null' : 'undefined';\n\n    // // if (property.hasDefault()) {\n    // //     defaultValue = `${compilerContext.reserveVariable('defaultValueGetter', property.getDefaultValueFunction())}()`;\n    // // } else\n    // if (!optional && nullable) {\n    //     defaultValue = 'null';\n    // }\n\n    //todo: clean that up. Way too much code for that simple functionality\n\n    state.setContext({ unpopulatedSymbol });\n    //note: this code is only reached when ${accessor} was actually defined checked by the 'in' operator.\n    return `\n        if (${state.accessor} === undefined) {\n            if (${setExplicitUndefined}) {\n                ${undefinedSetterCode}\n            }\n        } else if (${state.accessor} === null) {\n            //null acts on transport layer as telling an explicitly set undefined\n            //this is to support actual undefined as value across a transport layer. Otherwise it\n            //would be impossible to set a already set value to undefined back or override default value (since JSON.stringify() omits that information)\n            if (${nullable}) {\n                ${nullSetterCode}\n            } else {\n                if (${setExplicitUndefined}) {\n                    ${undefinedSetterCode}\n                }\n            }\n        } else if (${state.accessor} !== unpopulatedSymbol)  {\n            ${convert}\n            ${postTransform}\n        }\n    `;\n}\n\nexport function inAccessor(accessor: ContainerAccessor | string): string {\n    if ('string' === typeof accessor) return `${accessor} !== undefined`;\n    return `'object' === typeof ${accessor.container} && ${accessor.property} in ${accessor.container}`;\n}\n\nexport function deserializeEmbedded(type: TypeClass | TypeObjectLiteral, state: TemplateState, container?: string): string {\n    const embedded = embeddedAnnotation.getFirst(type);\n    if (!embedded) return '';\n\n    const properties = resolveTypeMembers(type).filter(isPropertyMemberType);\n    const args: (ContainerAccessor | string)[] = [];\n    const assign: (ContainerAccessor | string)[] = [];\n    const loadArgs: string[] = [];\n    const setToUndefined = state.compilerContext.reserveName('setToUndefined');\n    const params = state.compilerContext.reserveName('params');\n    const requiredSet: string[] = ['true'];\n\n    function loadProperty(setter: ContainerAccessor, property: TypeProperty | TypePropertySignature) {\n        if (!isOptional(property) && !hasDefaultValue(property)) {\n            if (isNullable(property)) {\n                requiredSet.push(`${setter} !== undefined`);\n            } else {\n                requiredSet.push(`${setter} !== undefined && ${setter} !== null`);\n            }\n        }\n\n        const accessor = getEmbeddedAccessor(type, properties.length !== 1, state.accessor, state.registry.serializer, state.namingStrategy, property, embedded!, container);\n        const propertyState = state.fork(setter, accessor).extendPath(String(property.name));\n        if (hasEmbedded(property.type)) {\n            loadArgs.push(executeTemplates(propertyState, property.type));\n        } else {\n            if (accessor instanceof ContainerAccessor) {\n                const check = !containerProperty ? 'true' : isNullable(containerProperty) ? `${accessor} === undefined` : `(${accessor} === undefined || ${accessor} === null)`;\n                const setUndefined = containerProperty ? `if (${check}) { ${setToUndefined}++; }` : 'if (false) {} ';\n                loadArgs.push(`\n                    if (${inAccessor(accessor)}) {\n                        ${setUndefined} else {\n                            ${executeTemplates(propertyState, property.type)}\n                        }\n                    }`);\n            } else {\n                loadArgs.push(executeTemplates(propertyState, property.type));\n            }\n        }\n    }\n\n    const containerProperty = getEmbeddedProperty(type);\n    const constructorAssigned: string[] = [];\n    for (const property of getConstructorProperties(type).parameters) {\n        if ((property.kind == ReflectionKind.property || property.kind === ReflectionKind.propertySignature) && !excludedAnnotation.isExcluded(property.type, state.registry.serializer.name)) {\n            constructorAssigned.push(memberNameToString(property.name));\n            const setter = new ContainerAccessor(params, JSON.stringify(property.name));\n            loadProperty(setter, property);\n            args.push(setter);\n        } else {\n            args.push('undefined');\n        }\n    }\n\n    for (const property of properties) {\n        if ((property.kind == ReflectionKind.property || property.kind === ReflectionKind.propertySignature) && !excludedAnnotation.isExcluded(property.type, state.registry.serializer.name)) {\n            if (constructorAssigned.includes(memberNameToString(property.name))) continue;\n            const setter = new ContainerAccessor(params, JSON.stringify(property.name));\n            loadProperty(setter, property);\n            assign.push(`${new ContainerAccessor(state.setter, JSON.stringify(property.name))} = ` + setter);\n        }\n    }\n\n    const createObject = type.kind === ReflectionKind.objectLiteral ? `{}` : `new ${state.compilerContext.reserveConst(type.classType)}(${args.join(',')})`;\n\n    return `\n        const ${params} = {};\n        let ${setToUndefined} = 0;\n        ${loadArgs.join('\\n')}\n        if (${requiredSet.join(' && ')}) {\n            ${state.setter} = ${createObject};\n            ${assign.join(';\\n')}\n        } else if (${setToUndefined} === ${properties.length}) {\n            ${state.setter} = undefined;\n        }\n    `;\n}\n\nexport function getIndexCheck(context: CompilerContext, i: string, type: Type): string {\n    if (type.kind === ReflectionKind.number) {\n        context.set({ isNumeric: isNumeric });\n        return `isNumeric(${i})`;\n    } else if (type.kind === ReflectionKind.string || type.kind === ReflectionKind.any) {\n        return `'string' === typeof ${i}`;\n    } else if (type.kind === ReflectionKind.symbol) {\n        return `'symbol' === typeof ${i}`;\n    } else if (type.kind === ReflectionKind.templateLiteral) {\n        context.set({ extendTemplateLiteral: extendTemplateLiteral });\n        const typeVar = context.reserveVariable('type', type);\n        return `'string' === typeof ${i} && extendTemplateLiteral({kind: ${ReflectionKind.literal}, literal: ${i}}, ${typeVar})`;\n    } else if (type.kind === ReflectionKind.union) {\n        return '(' + type.types.map(v => getIndexCheck(context, i, v)).join(' || ') + ')';\n    }\n    return '';\n}\n\nfunction isLiteralType(t: TypeIndexSignature): boolean {\n    return t.index.kind === ReflectionKind.literal || (t.index.kind === ReflectionKind.union && t.index.types.some(v => v.kind === ReflectionKind.literal));\n}\n\nfunction isNumberType(t: TypeIndexSignature): boolean {\n    return t.index.kind === ReflectionKind.number || (t.index.kind === ReflectionKind.union && t.index.types.some(v => v.kind === ReflectionKind.number));\n}\n\n/**\n * Sort, so the order is literal, number, string, symbol.  literal comes first as its the most specific type.\n * We need to do that for numbers since all keys are string|symbol in runtime, and we need to check if a string is numeric first before falling back to string.\n */\nexport function sortSignatures(signatures: TypeIndexSignature[]) {\n    signatures.sort((a, b) => {\n        if (isLiteralType(a)) return -1;\n        if (isNumberType(a) && !isLiteralType(b)) return -1;\n        return +1;\n    });\n}\n\nexport function getStaticDefaultCodeForProperty(member: TypeProperty | TypePropertySignature, setter: string | ContainerAccessor, state: TemplateState) {\n    let staticDefault = ``;\n    if (!hasDefaultValue(member) && !isOptional(member)) {\n        if (member.type.kind === ReflectionKind.literal) {\n            staticDefault = `${setter} = ${state.compilerContext.reserveConst(member.type.literal)};`;\n        } else if (isNullable(member.type)) {\n            staticDefault = `${setter} = null;`;\n        }\n    }\n    return staticDefault;\n}\n\nexport function getEmbeddedProperty(type: TypeClass | TypeObjectLiteral): TypeProperty | TypePropertySignature | undefined {\n    if (!type.parent) return;\n    let resolved: Type = type.parent;\n    if (resolved.kind === ReflectionKind.union && resolved.parent) resolved = resolved.parent;\n    if (resolved.kind === ReflectionKind.propertySignature || resolved.kind === ReflectionKind.property) return resolved;\n    return;\n}\n\nfunction getEmbeddedAccessor(type: TypeClass | TypeObjectLiteral, autoPrefix: boolean, accessor: string | ContainerAccessor, serializer: Serializer, namingStrategy: NamingStrategy, property: TypeProperty | TypePropertySignature, embedded: EmbeddedOptions, container?: string): string | ContainerAccessor {\n    const containerProperty = getEmbeddedProperty(type);\n\n    let embeddedPropertyName = JSON.stringify(namingStrategy.getPropertyName(property, serializer.name));\n    if (embedded.prefix !== undefined) {\n        embeddedPropertyName = embedded.prefix ? JSON.stringify(embedded.prefix) + ' + ' + embeddedPropertyName : embeddedPropertyName;\n    } else if (!container && containerProperty) {\n        embeddedPropertyName = JSON.stringify(containerProperty.name) + ` + '_' + ` + embeddedPropertyName;\n    }\n\n    if (container) return new ContainerAccessor(container, embeddedPropertyName);\n\n    if ((autoPrefix || embedded.prefix !== undefined)) {\n        //if autoPrefix or a prefix is set the embeddedPropertyName is emitted in a container, either manually provided or from accessor.\n        if (accessor instanceof ContainerAccessor) return new ContainerAccessor(accessor.container, embeddedPropertyName);\n        if (autoPrefix) return new ContainerAccessor(accessor, embeddedPropertyName);\n        if (containerProperty) return new ContainerAccessor(accessor, embeddedPropertyName);\n    }\n\n    return accessor;\n}\n\nfunction groupFilter(type: Type): string {\n    const groupNames = groupAnnotation.getAnnotations(type);\n    return `(state.groups || state.groupsExclude ? isGroupAllowed(state, ${JSON.stringify(groupNames)}) : true)`;\n}\n\nexport function serializeObjectLiteral(type: TypeObjectLiteral | TypeClass, state: TemplateState) {\n    const embedded = embeddedAnnotation.getFirst(type);\n    if (embedded) {\n        if (state.isDeserialization) {\n            const embedded = deserializeEmbedded(type, state);\n            if (embedded) {\n                state.addCode(embedded);\n                return;\n            }\n        } else {\n            const properties = resolveTypeMembers(type).filter(isPropertyMemberType);\n\n            if (properties.length === 1) {\n                const first = properties[0];\n                let name = getNameExpression(state.namingStrategy.getPropertyName(first, state.registry.serializer.name), state);\n                const setter = getEmbeddedAccessor(type, false, state.setter, state.registry.serializer, state.namingStrategy, first, embedded);\n                state.addCode(`\n            if (${inAccessor(state.accessor)}) {\n                ${executeTemplates(state.fork(setter, new ContainerAccessor(state.accessor, name)), first.type, false, false)}\n            }`);\n            } else {\n                const lines: string[] = [];\n\n                let pre = '';\n                let post = '';\n                let container = '';\n                if (!(state.setter instanceof ContainerAccessor)) {\n                    //create own container\n                    container = state.compilerContext.reserveName('container');\n                    pre = `let ${container} = {}`;\n                    post = `${state.setter} = ${container}`;\n                }\n\n                for (const property of properties) {\n                    const setter = getEmbeddedAccessor(type, true, state.setter, state.registry.serializer, state.namingStrategy, property, embedded, container);\n                    lines.push(createConverterJSForMember(property, state.fork(setter, new ContainerAccessor(state.accessor, JSON.stringify(property.name)))));\n                }\n\n                state.addCode(`\n                if (${inAccessor(state.accessor)}) {\n                    ${pre}\n                    ${lines.join('\\n')}\n                    ${post}\n                }\n            `);\n            }\n        }\n        return;\n    }\n\n    state.setContext({ isGroupAllowed });\n\n    const v = state.compilerContext.reserveName('v');\n    const lines: string[] = [];\n\n    const signatures: TypeIndexSignature[] = [];\n    const existing: string[] = [];\n\n    const constructorArguments: string[] = [];\n    const handledPropertiesInConstructor: string[] = [];\n    const preLines: string[] = [];\n    if (state.isDeserialization && type.kind === ReflectionKind.class) {\n        const clazz = ReflectionClass.from(type.classType);\n        const constructor = clazz.getConstructorOrUndefined();\n        if (!clazz.disableConstructor && constructor) {\n            handledPropertiesInConstructor.push(...getDeepConstructorProperties(type).map(v => String(v.name)));\n            const parameters = constructor.getParameters();\n            for (const parameter of parameters) {\n                if (!parameter.isProperty()) {\n                    constructorArguments.push('undefined');\n                    continue;\n                }\n\n                const property = clazz.getProperty(parameter.getName());\n                if (!property) continue;\n\n                if (property.isSerializerExcluded(state.registry.serializer.name)) {\n                    continue;\n                }\n                const argumentName = state.compilerContext.reserveVariable('c_' + parameter.getName());\n\n                const readName = getNameExpression(state.namingStrategy.getPropertyName(property.property, state.registry.serializer.name), state);\n\n                const propertyState = state.fork(argumentName, new ContainerAccessor(state.accessor, readName)).extendPath(String(property.getName()));\n                const staticDefault = property.type.kind === ReflectionKind.literal && !property.isOptional() ? `${argumentName} = ${state.compilerContext.reserveConst(property.type.literal)};` : '';\n\n                const embedded = property.getEmbedded();\n                if (embedded) {\n                    preLines.push(executeTemplates(propertyState, property.type));\n                } else {\n                    preLines.push(`\n                    ${argumentName} = undefined;\n                    if (${inAccessor(propertyState.accessor as ContainerAccessor)} && ${groupFilter(parameter.type)}) {\n                        ${createConverterJSForMember(property, propertyState)}\n                    } else {\n                        ${staticDefault}\n                    }\n                `);\n                }\n\n                constructorArguments.push(argumentName);\n            }\n        }\n    }\n\n    for (const member of resolveTypeMembers(type)) {\n        if (member.kind === ReflectionKind.indexSignature) {\n            if (excludedAnnotation.isExcluded(member.type, state.registry.serializer.name)) continue;\n            signatures.push(member);\n        } else if (member.kind === ReflectionKind.propertySignature || member.kind === ReflectionKind.property) {\n            if (!isPropertyMemberType(member)) continue;\n            if (excludedAnnotation.isExcluded(member.type, state.registry.serializer.name)) continue;\n            if (handledPropertiesInConstructor.includes(memberNameToString(member.name))) continue;\n\n            const name = state.namingStrategy.getPropertyName(member, state.registry.serializer.name);\n            const readName = getNameExpression(state.isDeserialization ? name : memberNameToString(member.name), state);\n            existing.push(readName);\n            const writeName = getNameExpression(state.isDeserialization ? memberNameToString(member.name) : name, state);\n            const setter = new ContainerAccessor(v, writeName);\n            const propertyState = state.fork(setter, new ContainerAccessor(state.accessor, readName)).extendPath(String(member.name));\n\n            const staticDefault = getStaticDefaultCodeForProperty(member, setter, state);\n            if (hasEmbedded(member.type)) {\n                lines.push(executeTemplates(propertyState, member.type));\n            } else {\n                lines.push(`\n                if (${readName} in ${state.accessor} && ${groupFilter(member.type)}) {\n                    ${createConverterJSForMember(member, propertyState)}\n                } else { ${staticDefault} }\n            `);\n            }\n        }\n    }\n\n    if (signatures.length) {\n        const i = state.compilerContext.reserveName('i');\n        const existingCheck = existing.map(v => `${i} === ${v}`).join(' || ') || 'false';\n        const signatureLines: string[] = [];\n\n        sortSignatures(signatures);\n\n        for (const signature of signatures) {\n            signatureLines.push(`else if (${getIndexCheck(state.compilerContext, i, signature.index)} && ${groupFilter(signature.type)}) {\n                ${createConverterJSForMember(signature, state.fork(new ContainerAccessor(v, i), new ContainerAccessor(state.accessor, i)).extendPath(new RuntimeCode(i)))}\n            }`);\n        }\n\n        state.setContext({ hasProperty });\n        //the index signature type could be: string, number, symbol.\n        //or a literal when it was constructed by a mapped type.\n        lines.push(`\n        for (const ${i} in ${state.accessor}) {\n            if (!hasProperty(${state.accessor}, ${i})) continue;\n            if (${existingCheck}) continue;\n            if (false) {} ${signatureLines.join(' ')}\n        }\n        `);\n    }\n\n    let createObject = '{}';\n    const postLines: string[] = [];\n    if (state.isDeserialization && type.kind === ReflectionKind.class) {\n        const classType = state.compilerContext.reserveConst(type.classType);\n        const clazz = ReflectionClass.from(type.classType);\n        if (clazz.disableConstructor) {\n            createObject = `Object.create(${classType}.prototype);`;\n            for (const property of clazz.getProperties()) {\n                if (property.property.kind !== ReflectionKind.property || property.property.default === undefined) continue;\n                const defaultFn = state.compilerContext.reserveConst(property.property.default);\n                createObject += `\\n${v}.${memberNameToString(property.name)} = ${defaultFn}.apply(${v});`;\n            }\n        } else {\n            createObject = `new ${classType}(${constructorArguments.join(', ')})`;\n            preLines.push(`const oldCheck = typeSettings.unpopulatedCheck; typeSettings.unpopulatedCheck = UnpopulatedCheck.None;`);\n            postLines.push(`typeSettings.unpopulatedCheck = oldCheck;`);\n        }\n    }\n\n    state.addCode(`\n        if ('object' !== typeof ${state.accessor}) ${state.throwCode(type)}\n        ${preLines.join('\\n')}\n        let ${v} = ${createObject};\n        ${postLines.join('\\n')}\n        ${lines.join('\\n')}\n        ${state.setter} = ${v};\n    `);\n\n    if (referenceAnnotation.hasAnnotations(type) && !state.isAnnotationHandled(referenceAnnotation)) {\n        state.annotationHandled(referenceAnnotation);\n        state.setContext({ isObject, isReferenceInstance, isReferenceHydrated });\n        const reflection = ReflectionClass.from(type);\n        //the primary key is serialised for unhydrated references\n\n        //when in deserialization a referenced is passed as is\n        const keepReference = state.isDeserialization ? `if (isReferenceInstance(${state.accessor})) {${state.setter} = ${state.accessor};} else ` : '';\n\n        state.replaceTemplate(`\n        ${keepReference} if (isReferenceInstance(${state.accessor}) && !isReferenceHydrated(${state.accessor})) {\n            ${executeTemplates(state.fork(state.setter, new ContainerAccessor(state.accessor, JSON.stringify(reflection.getPrimary().getName()))), reflection.getPrimary().getType())}\n        } else {\n            ${state.template}\n        }\n        `);\n    }\n}\n\nexport function typeGuardEmbedded(type: TypeClass | TypeObjectLiteral, state: TemplateState, embedded: EmbeddedOptions) {\n    const properties = resolveTypeMembers(type).filter(isPropertyMemberType);\n    if (properties.length) {\n        for (const property of properties) {\n            if ((property.kind == ReflectionKind.property || property.kind === ReflectionKind.propertySignature) && !excludedAnnotation.isExcluded(property.type, state.registry.serializer.name)) {\n                //we pass 'data' as container, since type guards for TypeClass get their own function always and operate on `data` accessor.\n                const accessor = getEmbeddedAccessor(type, properties.length !== 1, state.accessor, state.registry.serializer, state.namingStrategy, property, embedded);\n                //note: withValidation('strict') fixes the test with current changes, but limits the use of Embedded (no new limitation added, but this made it obvious).\n                const propertyState = state.fork(state.setter, accessor).withValidation('strict').extendPath(String(property.name));\n                if (hasEmbedded(property.type)) {\n                    state.addCode(executeTemplates(propertyState, property.type));\n                } else {\n                    if (accessor instanceof ContainerAccessor) {\n                        state.addCode(`if (${inAccessor(accessor)}) {${createConverterJSForMember(property, propertyState)} }`);\n                    } else {\n                        state.addCode(createConverterJSForMember(property, propertyState));\n                    }\n                }\n            }\n        }\n    }\n}\n\nexport function typeGuardObjectLiteral(type: TypeObjectLiteral | TypeClass, state: TemplateState) {\n    //this function is used for both, serialize and deserialization. When serializing the type of `type` is strictly correct, so checking embedded fields would lead to wrong results.\n    //this embedded check is only necessary when checking types in deserializing.\n    if (state.target === 'deserialize') {\n        const embedded = embeddedAnnotation.getFirst(type);\n        if (embedded) {\n            state.addCode('//typeguard for embedded');\n            typeGuardEmbedded(type, state, embedded);\n            return;\n        }\n    }\n\n    const lines: string[] = [];\n    const signatures: TypeIndexSignature[] = [];\n    const existing: string[] = [];\n\n    //to resolve inheritance in TypeClass, use ReflectionClass\n    const reflection = ReflectionClass.from(type);\n\n    for (const member of reflection.type.types) {\n        if (member.kind === ReflectionKind.indexSignature) {\n            signatures.push(member);\n        } else if (member.kind === ReflectionKind.propertySignature || member.kind === ReflectionKind.property || member.kind === ReflectionKind.methodSignature || member.kind === ReflectionKind.method) {\n            if (member.kind === ReflectionKind.property || member.kind === ReflectionKind.method) {\n                if (member.abstract || member.static) continue;\n            }\n\n            if (member.name === 'constructor') continue;\n\n            if (state.target === 'deserialize' && (member.kind === ReflectionKind.method || member.kind === ReflectionKind.methodSignature)) {\n                // methods can not be part of serialized data, so we skip them.\n                continue;\n            }\n\n            const readName = member.kind === ReflectionKind.methodSignature || member.kind === ReflectionKind.method\n                ? getNameExpression(member.name, state)\n                : getNameExpression(state.isDeserialization ? state.namingStrategy.getPropertyName(member, state.registry.serializer.name) : memberNameToString(member.name), state);\n\n            const checkValid = state.compilerContext.reserveName('check');\n            const propertyAccessor = new ContainerAccessor(state.accessor, readName);\n            const propertyState = state.fork(checkValid, propertyAccessor).extendPath(String(member.name));\n\n            const isEmbedded = member.kind === ReflectionKind.property || member.kind === ReflectionKind.propertySignature\n                ? hasEmbedded(member.type) : undefined;\n\n            if (isEmbedded && (member.kind === ReflectionKind.property || member.kind === ReflectionKind.propertySignature)) {\n                const template = executeTemplates(propertyState, member.type);\n                if (!template) throw new Error(`No template found for ${member.type.kind}`);\n\n                lines.push(`let ${checkValid} = false;` + template);\n            } else {\n                const optionalCheck = member.optional\n                    ? `${propertyAccessor} !== undefined && ` + (!isNullable(member) ? `${propertyAccessor} !== null && ` : '')\n                    : '';\n                existing.push(readName);\n\n                state.setContext({ unpopulatedSymbol });\n                const forType: Type = member.kind === ReflectionKind.methodSignature || member.kind === ReflectionKind.method\n                    ? { kind: ReflectionKind.function, name: memberNameToString(member.name), return: member.return, parameters: member.parameters }\n                    : member.type;\n                const checkTemplate = executeTemplates(propertyState, forType).trim();\n                lines.push(`\n                if (${optionalCheck} ${propertyAccessor} !== unpopulatedSymbol) {\n                    let ${checkValid} = false;\n                    ${checkTemplate || `// no template found for member ${String(member.name)}.type.kind=${forType.kind}`}\n                    if (!${checkValid}) ${state.setter} = false;\n                }`);\n            }\n        }\n    }\n\n    if (signatures.length) {\n        const i = state.compilerContext.reserveName('i');\n        const existingCheck = existing.map(v => `${i} === ${v}`).join(' || ') || 'false';\n        const signatureLines: string[] = [];\n\n        sortSignatures(signatures);\n\n        for (const signature of signatures) {\n            const checkValid = state.compilerContext.reserveName('check');\n            const checkTemplate = executeTemplates(state.fork(checkValid, new ContainerAccessor(state.accessor, i)).extendPath(new RuntimeCode(i)), signature.type).trim();\n            signatureLines.push(`else if (${getIndexCheck(state.compilerContext, i, signature.index)}) {\n                let ${checkValid} = false;\n                ${checkTemplate || `// no template found for signature.type.kind=${signature.type.kind}`}\n                if (!${checkValid}) ${state.setter} = false;\n            }`);\n        }\n\n        state.setContext({ hasProperty });\n        //the index signature type could be: string, number, symbol.\n        //or a literal when it was constructed by a mapped type.\n        lines.push(`\n        for (const ${i} in ${state.accessor}) {\n            if (!hasProperty(${state.accessor}, ${i})) continue;\n            if (${existingCheck}) continue;\n            if (!${state.setter}) {\n                break;\n            } ${signatureLines.join(' ')}\n            else {\n                ${state.setter} = false;\n                break;\n            }\n        }\n        `);\n    }\n\n    let customValidatorCall = '';\n    if (type.kind === ReflectionKind.class) {\n        const reflection = ReflectionClass.from(type.classType);\n        if (reflection.validationMethod) {\n            const resVar = state.setVariable('validationResult');\n            const method = state.setVariable('method', reflection.validationMethod);\n            customValidatorCall = `\n            if (${state.setter}) {\n                ${resVar} = ${state.accessor}[${method}]();\n                if (${resVar} && state.errors) state.errors.push(new ValidationErrorItem(${resVar}.path || ${collapsePath(state.path)}, ${resVar}.code, ${resVar}.message));\n            }\n            `;\n        }\n    }\n\n    state.setContext({ isObjectLiteral });\n\n    state.addCodeForSetter(`\n        ${state.setter} = true;\n        if (${state.accessor} && isObjectLiteral(${state.accessor})) {\n            ${lines.join('\\n')}\n            ${customValidatorCall}\n        } else {\n            if (${state.isValidation()}) ${state.assignValidationError('type', 'Not an object')}\n            ${state.setter} = false;\n        }\n    `);\n}\n\nexport function serializeArray(type: TypeArray, state: TemplateState) {\n    state.setContext({ isIterable });\n    const v = state.compilerContext.reserveName('v');\n    const tempIterable = state.compilerContext.reserveName('tempIterable');\n    const i = state.compilerContext.reserveName('i');\n    const item = state.compilerContext.reserveName('item');\n\n    //we just use `a.length` to check whether its array-like, because Array.isArray() is way too slow.\n    state.addCodeForSetter(`\n         if (isIterable(${state.accessor})) {\n            const ${tempIterable} = ${state.accessor};\n            ${state.setter} = [];\n            let ${i} = 0;\n            for (const ${item} of ${tempIterable}) {\n                let ${v};\n                ${executeTemplates(state.fork(v, item).extendPath(new RuntimeCode(i)), type.type)}\n                ${state.setter}.push(${v});\n                ${i}++;\n            }\n         }\n    `);\n}\n\nexport function typeGuardArray(elementType: Type, state: TemplateState) {\n    state.setContext({ isIterable, iterableSize });\n    const v = state.compilerContext.reserveName('v');\n    const i = state.compilerContext.reserveName('i');\n    const item = state.compilerContext.reserveName('item');\n    //we just use `a.length` to check whether its array-like, because Array.isArray() is way too slow.\n    state.addCodeForSetter(`\n         let ${v} = false;\n         let ${i} = 0;\n         if (isIterable(${state.accessor})) {\n            ${v} = iterableSize(${state.accessor}) === 0;\n            for (const ${item} of ${state.accessor}) {\n                ${executeTemplates(state.fork(v, item).extendPath(new RuntimeCode(i)), elementType)}\n                ${i}++;\n            }\n         } else if (${state.isValidation()}) {\n            ${state.assignValidationError('type', 'Not an array')}\n         }\n         ${state.setter} = ${v};\n    `);\n}\n\nfunction serializeTuple(type: TypeTuple, state: TemplateState) {\n    //[string, number], easy\n    //[...string, number], easy\n    //[number, ...string], easy\n    //[number, ...string, number, string], medium\n    const lines: string[] = [];\n    let restEndOffset = 0;\n    const _ = state.compilerContext.reserveName('_');\n    const i = state.compilerContext.reserveName('i');\n\n    for (let i = 0; i < type.types.length; i++) {\n        if (type.types[i].type.kind === ReflectionKind.rest) {\n            restEndOffset = type.types.length - (i + 1);\n            break;\n        }\n    }\n\n    for (const member of type.types) {\n        if (member.type.kind === ReflectionKind.rest) {\n            lines.push(`\n            for (; ${i} < ${state.accessor}.length - ${restEndOffset}; ${i}++) {\n                ${_} = undefined;\n                ${executeTemplates(state.fork(_, new ContainerAccessor(state.accessor, i)).extendPath(member.name || new RuntimeCode(i)), member.type.type)}\n                if (${_} !== undefined) {\n                    ${state.setter}.push(${_});\n                } else if (${member.optional || isOptional(member.type)}) {\n                    ${state.setter}.push(undefined);\n                }\n            }\n            `);\n        } else {\n            lines.push(`\n            ${_} = undefined;\n            ${executeTemplates(state.fork(_, new ContainerAccessor(state.accessor, i)).extendPath(member.name || new RuntimeCode(i)), member.type)}\n            if (${_} !== undefined) {\n                ${state.setter}.push(${_});\n            } else if (${member.optional || isOptional(member.type)}) {\n                ${state.setter}.push(undefined);\n            }\n            ${i}++;\n            `);\n        }\n    }\n\n    state.addCodeForSetter(`\n        let ${_};\n        let ${i} = 0;\n        ${state.setter} = [];\n        ${lines.join('\\n')}\n    `);\n}\n\nfunction typeGuardTuple(type: TypeTuple, state: TemplateState) {\n    //[string, number], easy\n    //[...string, number], easy\n    //[number, ...string], easy\n    //[number, ...string, number, string], medium\n    const lines: string[] = [];\n    let restEndOffset = 0;\n    const v = state.compilerContext.reserveName('v');\n    const i = state.compilerContext.reserveName('i');\n\n    for (let i = 0; i < type.types.length; i++) {\n        if (type.types[i].type.kind === ReflectionKind.rest) {\n            restEndOffset = type.types.length - (i + 1);\n            break;\n        }\n    }\n\n    for (const member of type.types) {\n        if (member.type.kind === ReflectionKind.rest) {\n            lines.push(`\n            for (; ${v} && ${i} < ${state.accessor}.length - ${restEndOffset}; ${i}++) {\n                ${executeTemplates(state.fork(v, new ContainerAccessor(state.accessor, i)).extendPath(member.name || new RuntimeCode(i)), member.type.type)}\n                if (!${v}) {\n                    break;\n                }\n            }\n            `);\n        } else {\n            const optionalCheck = member.optional ? `${state.accessor}[${i}] !== undefined` : 'true';\n            lines.push(`\n            if (${v} && ${optionalCheck}) {\n                ${executeTemplates(state.fork(v, new ContainerAccessor(state.accessor, i)).extendPath(member.name || new RuntimeCode(i)), member.type)}\n                ${i}++;\n            }\n            `);\n        }\n    }\n\n    state.setContext({ isArray: isArray });\n    state.addCodeForSetter(`\n        if (isArray(${state.accessor})) {\n            let ${v} = true;\n            let ${i} = 0;\n            ${lines.join('\\n')}\n            ${state.setter} = ${v};\n        } else {\n            if (${state.isValidation()}) ${state.assignValidationError('type', 'Not an array')}\n            ${state.setter} = false;\n        }\n    `);\n}\n\nexport function getSetTypeToArray(type: TypeClass): TypeArray {\n    const jit = getTypeJitContainer(type);\n    if (jit.forwardSetToArray) return jit.forwardSetToArray;\n\n    const value = type.arguments?.[0] || { kind: ReflectionKind.any };\n\n    return jit.forwardSetToArray = {\n        kind: ReflectionKind.array, type: value,\n    } as TypeArray;\n}\n\nexport function getMapTypeToArray(type: TypeClass): TypeArray {\n    const jit = getTypeJitContainer(type);\n    if (jit.forwardMapToArray) return jit.forwardMapToArray;\n\n    const index = type.arguments?.[0] || { kind: ReflectionKind.any };\n    const value = type.arguments?.[1] || { kind: ReflectionKind.any };\n\n    jit.forwardMapToArray = {\n        kind: ReflectionKind.array, type: copyAndSetParent({\n            kind: ReflectionKind.tuple, types: [\n                { kind: ReflectionKind.tupleMember, name: 'key', type: index },\n                { kind: ReflectionKind.tupleMember, name: 'value', type: value },\n            ],\n        }),\n    };\n\n    return jit.forwardMapToArray;\n}\n\nexport function getNTypeToArray(type: TypeClass, n: number): TypeArray {\n    const jit = getTypeJitContainer(type);\n    const name = `forwardNTypeToArray${n}`;\n    if (jit[name]) return jit[name];\n\n    const value = type.arguments?.[n] || { kind: ReflectionKind.any };\n\n    return jit[name] = {\n        kind: ReflectionKind.array, type: value,\n    } as TypeArray;\n}\n\nexport function executeTypeArgumentAsArray(type: TypeClass, typeIndex: number, state: TemplateState) {\n    executeTemplates(state, getNTypeToArray(type, typeIndex), true, false);\n}\n\nexport function forwardSetToArray(type: TypeClass, state: TemplateState) {\n    executeTemplates(state, getSetTypeToArray(type), true, false);\n}\n\nexport function forwardMapToArray(type: TypeClass, state: TemplateState) {\n    executeTemplates(state, getMapTypeToArray(type), true, false);\n}\n\nexport function serializePropertyOrParameter(type: TypePropertySignature | TypeProperty | TypeParameter, state: TemplateState) {\n    if (isOptional(type)) {\n        const nullCheck = isNullable(type) ? `if (${state.accessor} === null) {\n                ${executeTemplates(state.fork(), { kind: ReflectionKind.null })}\n            } else ` : '';\n\n        state.addCode(`\n            ${nullCheck}\n            if (${state.accessor} === undefined || ${state.accessor} === null) {\n                ${executeTemplates(state.fork(), { kind: ReflectionKind.undefined })}\n            } else {\n                ${executeTemplates(state.fork(), type.type)}\n            }\n        `);\n        return;\n    }\n\n    state.addCode(executeTemplates(state.fork(), type.type));\n}\n\nexport function validatePropertyOrParameter(type: TypePropertySignature | TypeProperty | TypeParameter, state: TemplateState) {\n    const optional = isOptional(type)\n    const hasDefault = hasDefaultValue(type);\n\n    state.addCode(`\n        if (${state.accessor} === undefined) {\n            if (${!optional && !hasDefault && state.isValidation()}) ${state.assignValidationError('type', 'No value given')}\n        } else {\n            ${executeTemplates(state.fork(), type.type)}\n        }\n    `);\n}\n\nexport function handleUnion(type: TypeUnion, state: TemplateState) {\n    //detecting which serializer to use in union is a complex topic and allows a key feature: deserializing an encoding that is entirely based on strings (e.g. URL query string)\n    //to support for example numeric string, we need to have multiple guards being able to detect their 'loosely type' equivalence, for example\n    // - '1234' => number\n    // - 1234 => string\n    // - 1234 => Date\n    // whether one is picked over that strict equivalence (123 => number, '123' => string) depends on the union and whether 'loosely' is active.\n    //The order of the union members is not important, only the order in which the guards are registered.\n\n    //examples with loosely active:\n    //  number | string\n    // -> '1234' => number\n    // -> 1234 => number\n    // -> 1234abc => string\n\n    //examples with loosely active:\n    //  number | boolean\n    // -> '1234' => number\n    // -> 1234 => number\n    // -> 1 => boolean\n    // => 'true' => boolean\n\n    //examples with loosely active:\n    //  number | Date\n    // -> '1234' => number\n    // -> 1234 => number\n    // -> '2021-11-24T16:21:13.425Z' => Date\n\n    //This feature requires that each serializer can have multiple guards registered in different specificality. We use a convention that\n    //the specificality of 1 is the default JS guard (typeof), and anything greater than 2 is a fallback, like number => Date (which should only be used when no other guard tested positively for number).\n    //Withing specificality of 1 there are other nuances that further describe the specificality. For example `literal` is more specific than a `string`, so\n    //that the literal will always picked first in a type of `'a' | string`. e.g. literal=1.1, string 1.5; other examples\n    // Date < string,\n\n    //anything below 0 is a loose guard, for example a numeric string, or numbers as boolean. guards below 0 are only used when enabled manually.\n    //guards between 0 and 1 are standard loose types that are necessary to support JSON, e.g. '2021-11-24T16:21:13.425Z' => Date.\n    const lines: string[] = [];\n\n    //since there are type guards that require to access the container (for example Embedded), its necessary to pass the container (if available) to the type guard function\n    //and change accessor to point to `data` (argument of the type guard) + index name.\n    const property = state.accessor instanceof ContainerAccessor ? `${state.accessor.property}` : 'undefined';\n    const args = `${state.accessor instanceof ContainerAccessor ? state.accessor.container : state.accessor}, state, ${collapsePath(state.path)}, ${property}`;\n    const accessor = state.accessor instanceof ContainerAccessor ? new ContainerAccessor('data', 'property') : 'data';\n\n    const typeGuards = state.registry.serializer.typeGuards.getSortedTemplateRegistries();\n\n    for (const [specificality, typeGuard] of typeGuards) {\n        //loosely type guards are only used for deserialization\n        if (state.target === 'serialize' && specificality < 1) continue;\n\n        //when validation=true and not all specificalities are included, we only use 1, which is used for strict validation()/is().\n        if (state.validation === 'strict' && specificality !== 1) continue;\n\n        for (const t of type.types) {\n            const fn = createTypeGuardFunction(\n                t,\n                state.fork(undefined, accessor)\n                    .forRegistry(typeGuard)\n                    //if validation is not set, we are in deserialize mode, so we need to activate validation\n                    //for this state.\n                    .withValidation(!state.validation ? 'loose' : state.validation)\n                    .includeAllSpecificalities(state.registry.serializer.typeGuards),\n                undefined, false,\n            );\n            if (!fn) continue;\n            const guard = state.setVariable('guard_' + ReflectionKind[t.kind], fn);\n            const looseCheck = specificality <= 0 ? `state.loosely !== false && ` : '';\n\n            const action = state.isValidation() ? `${state.setter} = true;` : executeTemplates(state.fullFork(), t);\n            lines.push(`else if (${looseCheck}${guard}(${args})) {\n                //type = ${ReflectionKind[t.kind]}, specificality=${specificality}\n                ${action}\n            }`);\n        }\n    }\n\n    const handleErrors = state.setter ? `\n        if (state.errors) {\n            ${state.setter} = false;\n            state.errors = oldErrors;\n        }\n    ` : '';\n\n    state.addCodeForSetter(`\n        {\n            const oldErrors = state.errors;\n            if (state.errors) state.errors = [];\n\n            //type guard for union\n            if (false) {} ${lines.join(' ')}\n            else {\n                ${handleErrors}\n                ${state.assignValidationError('type', 'No valid union member found. Valid: ' + stringifyResolvedType(type))}\n            }\n            state.errors = oldErrors;\n        }\n    `);\n}\n\nexport function getNameExpression(name: string | number | symbol | undefined, state: TemplateState): string {\n    if (undefined === name) return 'undefined';\n    if ('string' === typeof name || 'number' === typeof name) return JSON.stringify(name);\n    if (isType(name)) return JSON.stringify(memberNameToString(name));\n    return state.compilerContext.reserveConst(name, 'symbolName');\n}\n\nexport class TypeGuardRegistry {\n    registry: { [specificality: number]: TemplateRegistry } = {};\n\n    protected sorted?: [specificality: number, registry: TemplateRegistry][];\n\n    /**\n     * Lowest specificality first\n     */\n    getSortedTemplateRegistries() {\n        if (!this.sorted) {\n            this.sorted = [];\n            const registries = Object.entries(this.registry);\n            registries.sort((a, b) => {\n                return Number(a[0]) - Number(b[0]);\n            });\n            for (const [spec, reg] of registries) {\n                this.sorted.push([Number(spec), reg]);\n            }\n        }\n        return this.sorted;\n    }\n\n    constructor(public serializer: Serializer) {\n    }\n\n    clear() {\n        this.registry = {};\n        this.sorted = undefined;\n    }\n\n    /**\n     *\n     * @see register() for specificality explanation.\n     */\n    getRegistry(specificality: number): TemplateRegistry {\n        this.sorted = undefined;\n        return this.registry[specificality] ||= new TemplateRegistry(this.serializer);\n    }\n\n    /**\n     * Registers a new template and replaces all existing (added via register,prepend,append).\n     *\n     * Specificality defines when the given template guard is executed.\n     *\n     * - 1 means its used for JS types - exact types. For example for type string `'string' ==== typeof v` is used. Same for number, bigint, and boolean.\n     *   Guards of this specificality are used for the `is()` function.\n     *\n     * - >1 means it acts as a fallback. For example in a union `number | Date`, when a string is given, the Date can allow `string` type as well, so it gets converted to a Date.\n     *\n     * - >0 && <1 means its acts as a priority guard. For example in a `string | Date`, a string of date-format is converted to a Date instead of a string. This is necessary\n     *   to support regular JSON.\n     *\n     * - <0, anything below 0 means it can optionally be used for loosely types. This is handy when data comes from a string-only encoding like URL query strings.\n     *   In this specificality a numeric string is converted to a number or bigint, a 1|0|true|false string converted to boolean .\n     */\n    register<T extends ReflectionKind>(specificality: number, kind: T, template: Template<FindType<Type, T>>) {\n        this.getRegistry(specificality).register(kind, template);\n    }\n\n    /**\n     * @see register\n     */\n    registerClass(specificality: number, classType: ClassType, template: Template<TypeClass>) {\n        this.getRegistry(specificality).registerClass(classType, template);\n    }\n\n    /**\n     * @see register\n     */\n    registerBinary(specificality: number, template: Template<TypeClass>) {\n        this.getRegistry(specificality).registerBinary(template);\n    }\n}\n\n/**\n * Default serializer that can convert JS data structures to the target type.\n * It coerces types, converts object literals to class instances, and has type guards for JS types.\n *\n * JSONSerializer has the same but for JSON data structures.\n */\nexport class Serializer {\n    serializeRegistry = new TemplateRegistry(this);\n    deserializeRegistry = new TemplateRegistry(this);\n    typeGuards = new TypeGuardRegistry(this);\n    validators = new TemplateRegistry(this);\n\n    constructor(public name: string = 'json') {\n        this.registerSerializers();\n        this.registerTypeGuards();\n        this.registerValidators();\n    }\n\n    public setExplicitUndefined(type: Type, state: TemplateState): boolean {\n        return true;\n    }\n\n    protected registerValidators() {\n    }\n\n    clear() {\n        this.serializeRegistry.clear();\n        this.deserializeRegistry.clear();\n        this.typeGuards.clear();\n        this.validators.clear();\n    }\n\n    protected registerSerializers() {\n        this.deserializeRegistry.register(ReflectionKind.any, (type, state) => state.addSetter(state.accessor));\n        this.serializeRegistry.register(ReflectionKind.any, (type, state) => state.addSetter(state.accessor));\n\n        this.deserializeRegistry.register(ReflectionKind.object, (type, state) => {\n            state.setContext({ isObject });\n            state.addSetter(`isObject(${state.accessor}) ? ${state.accessor} : {}`);\n        });\n        this.serializeRegistry.register(ReflectionKind.object, (type, state) => state.addSetter(state.accessor));\n\n        this.deserializeRegistry.register(ReflectionKind.class, serializeObjectLiteral);\n        this.serializeRegistry.register(ReflectionKind.class, serializeObjectLiteral);\n        this.deserializeRegistry.register(ReflectionKind.objectLiteral, serializeObjectLiteral);\n        this.serializeRegistry.register(ReflectionKind.objectLiteral, serializeObjectLiteral);\n\n        this.deserializeRegistry.register(ReflectionKind.array, serializeArray);\n        this.serializeRegistry.register(ReflectionKind.array, serializeArray);\n\n        this.deserializeRegistry.register(ReflectionKind.tuple, serializeTuple);\n        this.serializeRegistry.register(ReflectionKind.tuple, serializeTuple);\n\n        this.deserializeRegistry.register(ReflectionKind.union, handleUnion);\n        this.serializeRegistry.register(ReflectionKind.union, handleUnion);\n\n        this.deserializeRegistry.register(ReflectionKind.literal, (type, state) => state.addSetter(state.setVariable('v', type.literal)));\n        this.serializeRegistry.register(ReflectionKind.literal, (type, state) => state.addSetter(state.setVariable('v', type.literal)));\n\n        this.serializeRegistry.register(ReflectionKind.undefined, (type, state) => state.addSetter(`null`));\n        this.deserializeRegistry.register(ReflectionKind.undefined, (type, state) => state.addSetter(`undefined`));\n\n        this.serializeRegistry.register(ReflectionKind.null, (type, state) => state.addSetter(`null`));\n        this.deserializeRegistry.register(ReflectionKind.null, (type, state) => state.addSetter(`null`));\n\n        this.serializeRegistry.register(ReflectionKind.propertySignature, serializePropertyOrParameter);\n        this.serializeRegistry.register(ReflectionKind.property, serializePropertyOrParameter);\n        this.serializeRegistry.register(ReflectionKind.parameter, serializePropertyOrParameter);\n        this.deserializeRegistry.register(ReflectionKind.propertySignature, serializePropertyOrParameter);\n        this.deserializeRegistry.register(ReflectionKind.property, serializePropertyOrParameter);\n        this.deserializeRegistry.register(ReflectionKind.parameter, serializePropertyOrParameter);\n\n        this.deserializeRegistry.registerClass(Date, (type, state) => state.addSetter(`new Date(${state.accessor})`));\n        this.serializeRegistry.registerClass(Date, (type, state) => state.addSetter(`${state.accessor}.toJSON()`));\n\n        this.serializeRegistry.register(ReflectionKind.string, (type, state) => {\n            state.addSetter(`'string' === typeof ${state.accessor} ? ${state.accessor} : ''+ ${state.accessor}`);\n        });\n\n        this.deserializeRegistry.register(ReflectionKind.string, (type, state) => {\n            state.addSetter(`'string' !== typeof ${state.accessor} && state.loosely !== false && undefined !== ${state.accessor} && null !== ${state.accessor} ? ${state.accessor}+'' : ${state.accessor}`);\n        });\n\n        this.deserializeRegistry.addDecorator(isUUIDType, (type, state) => {\n            const v = state.accessor;\n            const check = `${v}.length === 36 && ${v}[23] === '-' && ${v}[18] === '-' && ${v}[13] === '-' && ${v}[8] === '-'`;\n            state.addCode(`\n                if (!(${check})) ${state.throwCode(type, JSON.stringify('Not a UUID'))}\n            `);\n        });\n\n        this.deserializeRegistry.addDecorator(isMongoIdType, (type, state) => {\n            const check = `${state.accessor}.length === 24 || ${state.accessor}.length === 0`;\n            state.addCode(`\n                if (!(${check})) ${state.throwCode(type, JSON.stringify('Not a MongoId (ObjectId)'))}\n            `);\n        });\n\n        this.serializeRegistry.register(ReflectionKind.templateLiteral, (type, state) => state.addSetter(state.accessor));\n        this.deserializeRegistry.register(ReflectionKind.templateLiteral, (type, state) => {\n            state.addSetter(`'string' !== typeof ${state.accessor} ? ${state.accessor}+'' : ${state.accessor}`);\n        });\n\n        this.serializeRegistry.register(ReflectionKind.boolean, (type, state) => state.addSetter(state.accessor));\n        this.deserializeRegistry.register(ReflectionKind.boolean, (type, state) => {\n            state.addSetter(`'boolean' !== typeof ${state.accessor} && state.loosely !== false ? ${state.accessor} == 1 || ${state.accessor} == 'true' : ${state.accessor}`);\n        });\n\n        this.serializeRegistry.register(ReflectionKind.promise, (type, state) => executeTemplates(state, type.type));\n        this.deserializeRegistry.register(ReflectionKind.promise, (type, state) => executeTemplates(state, type.type));\n\n        this.serializeRegistry.register(ReflectionKind.bigint, (type, state) => {\n            if (binaryBigIntAnnotation.getFirst(type) === BinaryBigIntType.unsigned) {\n                state.addSetter(`${state.accessor} >= 0 ? ${state.accessor}.toString() : '0'`);\n            } else {\n                state.addSetter(`${state.accessor}.toString()`);\n            }\n        });\n        this.deserializeRegistry.register(ReflectionKind.bigint, (type, state) => {\n            state.setContext({ BigInt });\n            if (binaryBigIntAnnotation.getFirst(type) === BinaryBigIntType.unsigned) {\n                state.addSetter(`'bigint' !== typeof ${state.accessor} ? BigInt(${state.accessor}) : ${state.accessor}`);\n                state.addSetter(`${state.accessor} < 0 ? BigInt(0) : ${state.accessor}`);\n            } else {\n                state.addSetter(`'bigint' !== typeof ${state.accessor} ? BigInt(${state.accessor}) : ${state.accessor}`);\n            }\n        });\n\n        this.serializeRegistry.register(ReflectionKind.enum, (type, state) => state.addSetter(state.accessor));\n        this.deserializeRegistry.register(ReflectionKind.enum, (type, state) => {\n            const valuesVar = state.setVariable('values', type.values);\n            const matcher = state.setVariable('enumMatcher', getEnumValueIndexMatcher(type));\n            state.addCodeForSetter(`\n                ${state.setter} = ${valuesVar}[${matcher}(${state.accessor})];\n                if (${valuesVar}.indexOf(${state.setter}) === -1) ${state.throwCode('enum', `'No valid value of ' + ${valuesVar}.join(', ')`)}\n            `);\n        });\n\n        this.serializeRegistry.register(ReflectionKind.regexp, (type, state) => state.addSetter(`${state.accessor}.toString()`));\n        this.deserializeRegistry.register(ReflectionKind.regexp, (type, state) => {\n            state.setContext({ RegExp });\n            state.addCodeForSetter(`\n\n            try {\n            ${state.setter} = 'string' === typeof ${state.accessor}\n                ? ${state.accessor}[0] === '/'\n                    ? new RegExp(${state.accessor}.slice(1, ${state.accessor}.lastIndexOf('/')), ${state.accessor}.slice(1 + ${state.accessor}.lastIndexOf('/')))\n                    : new RegExp(${state.accessor})\n                : ${state.accessor}\n            } catch (error) {\n                ${state.throwCode('regexp', 'error')}\n            }\n            `);\n        });\n\n        this.serializeRegistry.register(ReflectionKind.number, (type, state) => state.addSetter(state.accessor));\n        this.deserializeRegistry.register(ReflectionKind.number, (type, state) => {\n            if (type.brand !== undefined && type.brand < TypeNumberBrand.float) {\n                state.addSetter(`Math.trunc(${state.accessor})`);\n                if (type.brand === TypeNumberBrand.uint8) {\n                    state.addSetter(`${state.accessor} > 255 ? 255 : ${state.accessor} < 0 ? 0 : ${state.accessor}`);\n                } else if (type.brand === TypeNumberBrand.uint16) {\n                    state.addSetter(`${state.accessor} > 65535 ? 65535 : ${state.accessor} < 0 ? 0 : ${state.accessor}`);\n                } else if (type.brand === TypeNumberBrand.uint32) {\n                    state.addSetter(`${state.accessor} > 4294967295 ? 4294967295 : ${state.accessor} < 0 ? 0 : ${state.accessor}`);\n                } else if (type.brand === TypeNumberBrand.int8) {\n                    state.addSetter(`${state.accessor} > 127 ? 127 : ${state.accessor} < -128 ? -128 : ${state.accessor}`);\n                } else if (type.brand === TypeNumberBrand.int16) {\n                    state.addSetter(`${state.accessor} > 32767 ? 32767 : ${state.accessor} < -32768 ? -32768 : ${state.accessor}`);\n                } else if (type.brand === TypeNumberBrand.int32) {\n                    state.addSetter(`${state.accessor} > 2147483647 ? 2147483647 : ${state.accessor} < -2147483648 ? -2147483648 : ${state.accessor}`);\n                }\n            } else {\n                state.setContext({ Number });\n                state.addSetter(`'number' !== typeof ${state.accessor} && state.loosely !== false ? Number(${state.accessor}) : ${state.accessor}`);\n                if (type.brand === TypeNumberBrand.float32) {\n                    state.addSetter(`${state.accessor} > 3.40282347e+38 ? 3.40282347e+38 : ${state.accessor} < -3.40282347e+38 ? -3.40282347e+38 : ${state.accessor}`);\n                }\n            }\n\n            state.addCodeForSetter(`if (isNaN(${state.accessor})) ${state.throwCode(type)}`);\n        });\n\n        //convert binary to base64 (instead of hex, important for primary key hash)\n        this.serializeRegistry.registerBinary((type, state) => {\n            if (type.classType === ArrayBuffer) {\n                state.setContext({ arrayBufferToBase64 });\n                state.addSetter(`arrayBufferToBase64(${state.accessor})`);\n                return;\n            }\n            state.setContext({ typedArrayToBase64 });\n            state.addSetter(`typedArrayToBase64(${state.accessor})`);\n        });\n\n        this.deserializeRegistry.registerBinary((type, state) => {\n            if (type.classType === ArrayBuffer) {\n                state.setContext({ base64ToArrayBuffer });\n                state.addSetter(`${state.accessor} instanceof ArrayBuffer ? ${state.accessor} : base64ToArrayBuffer(${state.accessor})`);\n                return;\n            }\n\n            state.setContext({ base64ToTypedArray });\n            const typedArrayVar = state.setVariable('classType', type.classType);\n            state.addSetter(`${state.accessor} instanceof ${typedArrayVar} ? ${state.accessor} : base64ToTypedArray(${state.accessor}, ${typedArrayVar})`);\n        });\n\n        this.serializeRegistry.registerClass(Set, forwardSetToArray);\n        this.serializeRegistry.registerClass(Map, forwardMapToArray);\n\n        this.deserializeRegistry.registerClass(Set, (type, state) => {\n            forwardSetToArray(type, state);\n            state.addSetter(`new Set(${state.accessor})`);\n        });\n        this.deserializeRegistry.registerClass(Map, (type, state) => {\n            forwardMapToArray(type, state);\n            state.addSetter(`new Map(${state.accessor})`);\n        });\n\n        this.deserializeRegistry.addDecorator(\n            type => isReferenceType(type) || isBackReferenceType(type) || (type.parent !== undefined && isBackReferenceType(type.parent)),\n            (type, state) => {\n                if (type.kind !== ReflectionKind.class && type.kind !== ReflectionKind.objectLiteral) return;\n                state.annotationHandled(referenceAnnotation);\n                state.setContext({ isObject, createReference, isReferenceHydrated, isReferenceInstance, getObjectKeysSize });\n                const reflection = ReflectionClass.from(type);\n                const referenceClassTypeVar = state.setVariable('referenceClassType', type.kind === ReflectionKind.class ? type.classType : Object);\n\n                // when an object with primary key is given e.g. {id: 1} we treat it as\n                // reference and assign an instance of Reference to the property.\n                const l: string[] = [`${reflection.getPrimaries().length} > 0 && getObjectKeysSize(${state.accessor}) === ${reflection.getPrimaries().length}`];\n                for (const pk of reflection.getPrimaries()) {\n                    l.push(`${JSON.stringify(pk.name)} in ${state.accessor}`);\n                }\n                const checkIsPrimaryKeyOnly = l.join(' && ');\n\n                // in deserialization a reference is created when only the primary key is provided (no object given)\n                state.replaceTemplate(`\n                    if (isReferenceInstance(${state.accessor})) {\n                        ${state.setter} = ${state.accessor};\n                    } else if (isObject(${state.accessor}) && ${checkIsPrimaryKeyOnly}) {\n                        ${state.setter} = createReference(${referenceClassTypeVar}, ${state.accessor});\n                    } else if (isObject(${state.accessor})) {\n                        ${state.template}\n                    } else {\n                        let pk;\n                        ${executeTemplates(state.fork('pk').extendPath(String(reflection.getPrimary().getName())), reflection.getPrimary().getType())}\n                        ${state.setter} = createReference(${referenceClassTypeVar}, {${JSON.stringify(reflection.getPrimary().getName())}: pk});\n                    }\n                `);\n            });\n    }\n\n    protected registerTypeGuards() {\n        this.typeGuards.register(1, ReflectionKind.any, (type, state) => {\n            //if any is part of a union, we use register(20) below. otherwise it would match before anything else.\n            if (type.parent && type.parent.kind === ReflectionKind.union) {\n                return;\n            }\n            state.addSetter('true');\n        });\n        //if nothing else matches in a union, any matches anything\n        this.typeGuards.register(20, ReflectionKind.any, (type, state) => state.addSetter('true'));\n\n        this.typeGuards.register(1, ReflectionKind.object, (type, state) => {\n            state.setContext({ isObject });\n            state.addSetter(`isObject(${state.accessor})`);\n        });\n        this.typeGuards.register(1, ReflectionKind.objectLiteral, (type, state) => typeGuardObjectLiteral(type, state));\n        this.typeGuards.register(1, ReflectionKind.class, (type, state) => typeGuardObjectLiteral(type, state));\n\n        // //for deserialization type guards (specifically > 1) we check for embedded type sas well. this is because an embedded could have totally different field names.\n        // //and only if the property (where the embedded is placed) has no strict type guard do we look for other fields as well.\n        // this.typeGuards.register(2, ReflectionKind.class, (type, state) => typeCheckClassOrObjectLiteral(type, state, true));\n\n        this.typeGuards.register(1, ReflectionKind.string, (type, state) => {\n            state.addSetterAndReportErrorIfInvalid('type', 'Not a string', `'string' === typeof ${state.accessor}`);\n        });\n        this.typeGuards.getRegistry(1).addDecorator(isUUIDType, (type, state) => {\n            const v = state.originalAccessor;\n            const check = `${state.setter} && ${v}.length === 36 && ${v}[23] === '-' && ${v}[18] === '-' && ${v}[13] === '-' && ${v}[8] === '-'`;\n            state.addSetterAndReportErrorIfInvalid('type', 'Not a UUID', check);\n        });\n        this.typeGuards.getRegistry(1).addDecorator(isMongoIdType, (type, state) => {\n            state.addSetterAndReportErrorIfInvalid('type', 'Not a MongoId (ObjectId)', `${state.setter} && (${state.originalAccessor}.length === 24 || ${state.originalAccessor}.length === 0)`);\n        });\n        this.typeGuards.register(50, ReflectionKind.string, (type, state) => state.addSetter(`${state.accessor} !== undefined && ${state.accessor} !== null`)); //at the end, everything can be converted to string\n\n        this.typeGuards.register(1, ReflectionKind.templateLiteral, (type, state) => {\n            state.setContext({ extendTemplateLiteral: extendTemplateLiteral });\n            const typeVar = state.setVariable('type', type);\n            state.addSetterAndReportErrorIfInvalid('type', 'Invalid literal', `'string' === typeof ${state.accessor} && extendTemplateLiteral({kind: ${ReflectionKind.literal}, literal: ${state.accessor}}, ${typeVar})`);\n        });\n\n        this.typeGuards.register(1, ReflectionKind.undefined, (type, state) => state.addSetterAndReportErrorIfInvalid('type', 'Not undefined', `'undefined' === typeof ${state.accessor}`));\n        this.typeGuards.register(2, ReflectionKind.undefined, (type, state) => state.addSetter(`null === ${state.accessor}`));\n\n        this.typeGuards.register(1, ReflectionKind.null, (type, state) => state.addSetterAndReportErrorIfInvalid('type', 'Not null', `null === ${state.accessor}`));\n        this.typeGuards.register(2, ReflectionKind.null, (type, state) => state.addSetter(`'undefined' === typeof ${state.accessor}`));\n\n        this.typeGuards.register(1, ReflectionKind.propertySignature, validatePropertyOrParameter);\n        this.typeGuards.register(1, ReflectionKind.property, validatePropertyOrParameter);\n        this.typeGuards.register(1, ReflectionKind.parameter, validatePropertyOrParameter);\n\n        this.typeGuards.register(2, ReflectionKind.number, (type, state) => {\n            state.setContext({ isNumeric: isNumeric });\n            state.addSetter(`'bigint' === typeof ${state.accessor} || 'number' === typeof ${state.accessor} || ('string' === typeof ${state.accessor} && isNumeric(${state.accessor}))`);\n        });\n        this.typeGuards.register(-0.5, ReflectionKind.number, (type, state) => {\n            state.setContext({ isNumeric: isNumeric });\n            state.addSetter(`'string' === typeof ${state.accessor} && isNumeric(${state.accessor})`);\n        });\n        this.typeGuards.register(1, ReflectionKind.number, (type, state) => {\n            if (type.brand !== undefined && type.brand >= TypeNumberBrand.integer && type.brand <= TypeNumberBrand.uint32) {\n                state.setContext({ isInteger: isInteger });\n                let check = `'number' === typeof ${state.accessor} && isInteger(${state.accessor})`;\n\n                if (type.brand === TypeNumberBrand.uint8) {\n                    check += `&& ${state.accessor} <= 255 && ${state.accessor} >= 0`;\n                } else if (type.brand === TypeNumberBrand.uint16) {\n                    check += `&& ${state.accessor} <= 65535 && ${state.accessor} >= 0`;\n                } else if (type.brand === TypeNumberBrand.uint32) {\n                    check += `&& ${state.accessor} <= 4294967295 && ${state.accessor} >= 0`;\n                } else if (type.brand === TypeNumberBrand.int8) {\n                    check += `&& ${state.accessor} <= 127 && ${state.accessor} >= -128`;\n                } else if (type.brand === TypeNumberBrand.int16) {\n                    check += `&& ${state.accessor} <= 32767 && ${state.accessor} >= -32768`;\n                } else if (type.brand === TypeNumberBrand.int32) {\n                    check += `&& ${state.accessor} <= 2147483647 && ${state.accessor} >= -2147483648`;\n                }\n                state.addSetterAndReportErrorIfInvalid('type', `Not a ${type.brand === undefined ? 'number' : TypeNumberBrand[type.brand]}`, check);\n            } else {\n                let check = `'number' === typeof ${state.accessor}`;\n\n                if (type.brand === TypeNumberBrand.float32) {\n                    check += `&& ${state.accessor} <= 3.40282347e+38 && ${state.accessor} >= -3.40282347e+38`;\n                }\n\n                state.addSetterAndReportErrorIfInvalid('type', `Not a ${type.brand === undefined ? 'number' : TypeNumberBrand[type.brand]}`, check);\n            }\n        });\n\n        this.typeGuards.register(2, ReflectionKind.bigint, (type, state) => {\n            state.setContext({ isNumeric: isNumeric });\n            state.addSetter(`'number' === typeof ${state.accessor} || ('string' === typeof ${state.accessor} && isNumeric(${state.accessor}))`);\n        });\n        this.typeGuards.register(-0.5, ReflectionKind.bigint, (type, state) => {\n            state.setContext({ isNumeric: isNumeric });\n            state.addSetter(`'string' === typeof ${state.accessor} && isNumeric(${state.accessor})`);\n        });\n        this.typeGuards.register(1, ReflectionKind.bigint, (type, state) => state.addSetterAndReportErrorIfInvalid('type', 'Not a bigint', `'bigint' === typeof ${state.accessor}`));\n\n        this.typeGuards.register(1, ReflectionKind.boolean, (type, state) => state.addSetterAndReportErrorIfInvalid('type', 'Not a boolean', `'boolean' === typeof ${state.accessor}`));\n        this.typeGuards.register(-0.9, ReflectionKind.boolean, (type, state) => {\n            let handleNumeric = true;\n            if (type.parent && type.parent.kind === ReflectionKind.union && (type.parent.types.some(v => v.kind === ReflectionKind.number || v.kind === ReflectionKind.bigint))) {\n                handleNumeric = false;\n            }\n            if (handleNumeric) {\n                state.addSetter(`1 === ${state.accessor} || '1' === ${state.accessor} || 0 === ${state.accessor} || 'true' === ${state.accessor} || 'false' === ${state.accessor}`);\n            } else {\n                state.addSetter(`'true' === ${state.accessor} || 'false' === ${state.accessor}`);\n            }\n        });\n\n        this.typeGuards.register(1, ReflectionKind.promise, (type, state) => executeTemplates(state, type.type));\n        this.typeGuards.register(1, ReflectionKind.enum, (type, state) => {\n            const matcher = state.setVariable('enumMatcher', getEnumValueIndexMatcher(type));\n            state.addSetterAndReportErrorIfInvalid('type', 'Invalid enum member', `${matcher}(${state.accessor}) >= 0`);\n        });\n        this.typeGuards.register(1, ReflectionKind.array, (type, state) => typeGuardArray(type.type, state));\n        this.typeGuards.register(1, ReflectionKind.tuple, typeGuardTuple);\n        this.typeGuards.register(1, ReflectionKind.literal, (type, state) => {\n            state.addSetterAndReportErrorIfInvalid('type', 'Invalid literal', `${state.setVariable('v', type.literal)} === ${state.accessor}`);\n        });\n\n        this.typeGuards.register(-0.5, ReflectionKind.literal, (type, state) => {\n            //loosely only works for number/bigint/boolean, not for symbols/regexp/string\n            if (type.literal === null || type.literal === undefined || typeof type.literal === 'number' || typeof type.literal === 'bigint' || typeof type.literal === 'boolean') {\n                state.addSetter(`'string' === typeof ${state.accessor} && ${state.setVariable('v', String(type.literal))} === ${state.accessor}`);\n            }\n        });\n\n        this.typeGuards.register(1, ReflectionKind.regexp, ((type, state) => state.addSetterAndReportErrorIfInvalid('type', 'Not a RegExp', `${state.accessor} instanceof RegExp`)));\n        this.typeGuards.register(2, ReflectionKind.regexp, ((type, state) => state.addSetter(`'string' === typeof ${state.accessor}`)));\n        this.typeGuards.register(0.5, ReflectionKind.regexp, ((type, state) => state.addSetter(`'string' === typeof ${state.accessor} && ${state.accessor}[0] === '/'`)));\n\n\n        this.typeGuards.getRegistry(1).registerClass(Set, forwardSetToArray);\n        this.typeGuards.getRegistry(1).registerClass(Map, forwardMapToArray);\n        this.typeGuards.getRegistry(1).registerClass(Date, (type, state) => state.addSetterAndReportErrorIfInvalid('type', 'Not a Date', `${state.accessor} instanceof Date`));\n        this.typeGuards.getRegistry(0.5).registerClass(Date, (type, state) => {\n            state.addSetter(`'string' === typeof ${state.accessor} && new Date(${state.accessor}).toString() !== 'Invalid Date'`);\n        });\n\n        //if no type is found (>1), date supports also numbers\n        this.typeGuards.getRegistry(1.5).registerClass(Date, (type, state) => {\n            state.addSetter(`'number' === typeof ${state.accessor}`);\n        });\n\n        this.typeGuards.register(1, ReflectionKind.function, ((type, state) => {\n            state.setContext({ isFunction, isExtendable, resolveRuntimeType });\n            const t = state.setVariable('type', type);\n            state.addCodeForSetter(`\n                if (isFunction(${state.accessor})) {\n                    if ('__type' in ${state.accessor}) {\n                        ${state.setter} = isExtendable(resolveRuntimeType(${state.accessor}), ${t});\n                    } else {\n                        ${state.setter} = true;\n                    }\n                } else {\n                    if (${state.isValidation()}) ${state.assignValidationError('type', 'Not a function')}\n                    ${state.setter} = false;\n                }\n            `);\n        }));\n\n        this.typeGuards.register(1, ReflectionKind.regexp, (type, state) => state.addSetter(`${state.accessor} instanceof RegExp`));\n        this.typeGuards.register(2, ReflectionKind.regexp, (type, state) => state.addSetter(`'string' === typeof ${state.accessor}`));\n        this.typeGuards.getRegistry(1).addPostHook((type: Type, state: TemplateState) => {\n            for (const validation of validationAnnotation.getAnnotations(type)) {\n                const name = validation.name;\n                const args = validation.args;\n\n                if (name === 'function') {\n                    state.setContext({ ValidationErrorItem: ValidationErrorItem });\n                    assertType(args[0], ReflectionKind.function);\n                    const validatorVar = state.setVariable('validator', args[0].function);\n                    let optionVar: any = undefined;\n                    if (args[1]) {\n                        const optionParameter = args[0].parameters[2];\n                        if (optionParameter) {\n                            const option = typeToObject(args[1]);\n                            if (option === undefined && optionParameter.optional) {\n                            } else {\n                                const errors = validate(option, optionParameter.type);\n                                if (errors.length) {\n                                    throw new Error(`Invalid option value given to validator function ${String(args[0].name)}, expected ${stringifyType(optionParameter)}`);\n                                }\n                                optionVar = state.compilerContext.reserveConst(option);\n                            }\n                        }\n                    }\n                    state.addCode(`\n                        {\n                            let error = ${validatorVar}(${state.originalAccessor}, ${state.compilerContext.reserveConst(type, 'type')}, ${optionVar ? optionVar : 'undefined'});\n                            if (error) {\n                                ${state.setter} = false;\n                                if (state.errors) state.errors.push(new ValidationErrorItem(${collapsePath(state.path)}, error.code, error.message, ${state.originalAccessor}));\n                            }\n                        }\n                    `);\n                } else {\n                    const validator = validators[name];\n                    if (validator) {\n                        state.setContext({ ValidationErrorItem: ValidationErrorItem });\n                        const validatorVar = state.setVariable('validator', validator(...args));\n                        state.addCode(`\n                            {\n                                let error = ${validatorVar}(${state.originalAccessor}, ${state.compilerContext.reserveConst(type, 'type')});\n                                if (error) {\n                                    ${state.setter} = false;\n                                    if (state.errors) state.errors.push(new ValidationErrorItem(${collapsePath(state.path)}, error.code, error.message, ${state.originalAccessor}));\n                                }\n                            }\n                        `);\n                    }\n                }\n            }\n        });\n\n        this.typeGuards.register(1, ReflectionKind.union, handleUnion);\n        this.typeGuards.registerBinary(1, (type, state) => {\n            state.addSetter(`${state.accessor} instanceof ${state.setVariable('classType', type.classType)}`);\n        });\n        this.typeGuards.registerBinary(10, (type, state) => {\n            state.addSetter(`'string' === typeof ${state.accessor}`);\n        });\n    }\n}\n\nfunction assignAccessorTemplate(type: Type, state: TemplateState) {\n    state.addSetter(state.accessor);\n}\n\nexport const serializableKinds: ReflectionKind[] = [\n    ReflectionKind.any,\n    ReflectionKind.unknown,\n    ReflectionKind.object,\n    ReflectionKind.string,\n    ReflectionKind.number,\n    ReflectionKind.boolean,\n    ReflectionKind.symbol,\n    ReflectionKind.bigint,\n    ReflectionKind.null,\n    ReflectionKind.undefined,\n    ReflectionKind.literal,\n    ReflectionKind.templateLiteral,\n    ReflectionKind.property,\n    ReflectionKind.method,\n    ReflectionKind.function,\n    ReflectionKind.promise,\n    ReflectionKind.class,\n    ReflectionKind.enum,\n    ReflectionKind.union,\n    ReflectionKind.array,\n    ReflectionKind.tuple,\n    ReflectionKind.regexp,\n    ReflectionKind.objectLiteral,\n];\n\nexport class EmptySerializer extends Serializer {\n    constructor(name: string = 'empty') {\n        super(name);\n    }\n\n    protected registerValidators() {\n    }\n\n    protected registerSerializers() {\n        for (const kind of serializableKinds) this.serializeRegistry.register(kind, assignAccessorTemplate);\n        for (const kind of serializableKinds) this.deserializeRegistry.register(kind, assignAccessorTemplate);\n\n        this.deserializeRegistry.register(ReflectionKind.class, serializeObjectLiteral);\n        this.serializeRegistry.register(ReflectionKind.class, serializeObjectLiteral);\n        this.deserializeRegistry.register(ReflectionKind.objectLiteral, serializeObjectLiteral);\n        this.serializeRegistry.register(ReflectionKind.objectLiteral, serializeObjectLiteral);\n\n        this.deserializeRegistry.register(ReflectionKind.array, serializeArray);\n        this.serializeRegistry.register(ReflectionKind.array, serializeArray);\n\n        this.deserializeRegistry.register(ReflectionKind.tuple, serializeTuple);\n        this.serializeRegistry.register(ReflectionKind.tuple, serializeTuple);\n\n        this.deserializeRegistry.register(ReflectionKind.union, handleUnion);\n        this.serializeRegistry.register(ReflectionKind.union, handleUnion);\n\n        this.serializeRegistry.register(ReflectionKind.propertySignature, serializePropertyOrParameter);\n        this.serializeRegistry.register(ReflectionKind.property, serializePropertyOrParameter);\n        this.serializeRegistry.register(ReflectionKind.parameter, serializePropertyOrParameter);\n        this.deserializeRegistry.register(ReflectionKind.propertySignature, serializePropertyOrParameter);\n        this.deserializeRegistry.register(ReflectionKind.property, serializePropertyOrParameter);\n        this.deserializeRegistry.register(ReflectionKind.parameter, serializePropertyOrParameter);\n\n        this.serializeRegistry.registerBinary(assignAccessorTemplate);\n        this.serializeRegistry.registerClass(Date, assignAccessorTemplate);\n        this.serializeRegistry.registerClass(Map, assignAccessorTemplate);\n        this.serializeRegistry.registerClass(Set, assignAccessorTemplate);\n        this.deserializeRegistry.registerBinary(assignAccessorTemplate);\n        this.deserializeRegistry.registerClass(Date, assignAccessorTemplate);\n        this.deserializeRegistry.registerClass(Map, assignAccessorTemplate);\n        this.deserializeRegistry.registerClass(Set, assignAccessorTemplate);\n    }\n}\n\nexport const serializer: Serializer = new Serializer();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 16058, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16064, "column": 0}, "map": {"version":3,"file":"serializer-facade.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/serializer-facade.ts"],"sourcesContent":["import { getClassTypeFromInstance } from '@deepkit/core';\nimport { ReceiveType, resolveReceiveType } from './reflection/reflection.js';\nimport {\n    getPartialSerializeFunction,\n    getSerializeFunction,\n    NamingStrategy,\n    SerializationOptions,\n    SerializeFunction,\n    serializer,\n    Serializer,\n    TemplateRegistry\n} from './serializer.js';\nimport { JSONPartial, JSONSingle } from './utils.js';\nimport { typeInfer } from './reflection/processor.js';\nimport { assert } from './typeguard.js';\nimport { DeepPartial } from './changes.js';\nimport { findMember, getTypeJitContainer, ReflectionKind, Type, TypeClass, TypeObjectLiteral } from './reflection/type.js';\n\n/**\n * Casts/coerces a given data structure to the target data type and validates all attached validators.\n *\n * Same as validatedDeserialize().\n *\n * @throws ValidationError if casting or validation fails\n */\nexport function cast<T>(data: JSONPartial<T> | unknown, options?: SerializationOptions, serializerToUse: Serializer = serializer, namingStrategy?: NamingStrategy, type?: ReceiveType<T>): T {\n    const fn = getSerializeFunction(resolveReceiveType(type), serializerToUse.deserializeRegistry, namingStrategy);\n    const item = fn(data, options) as T;\n    assert(item, undefined, type);\n    return item;\n}\n\n/**\n * Same as cast but returns a ready to use function. Used to improve performance.\n */\nexport function castFunction<T>(serializerToUse: Serializer = serializer, namingStrategy?: NamingStrategy, type?: ReceiveType<T>): (data: JSONPartial<T> | unknown, options?: SerializationOptions) => T {\n    const fn = getSerializeFunction(resolveReceiveType(type), serializerToUse.deserializeRegistry, namingStrategy);\n    return (data: JSONPartial<T> | unknown, options?: SerializationOptions) => {\n        const item = fn(data, options);\n        assert(item, undefined, type);\n        return item;\n    }\n}\n\n/**\n * Deserialize given data structure from JSON data objects to JavaScript objects, without running any validators.\n *\n * Types that are already correct will be used as-is.\n *\n * ```typescript\n * interface Data {\n *     created: Date;\n * }\n *\n * const data = deserialize<Data>({created: '2009-02-13T23:31:30.123Z'});\n * //data is {created: Date(2009-02-13T23:31:30.123Z)}\n *\n * @throws ValidationError when deserialization fails.\n * ```\n */\nexport function deserialize<T>(data: JSONPartial<T> | unknown, options?: SerializationOptions, serializerToUse: Serializer = serializer, namingStrategy?: NamingStrategy, type?: ReceiveType<T>): T {\n    const fn = getSerializeFunction(resolveReceiveType(type), serializerToUse.deserializeRegistry, namingStrategy);\n    return fn(data, options) as T;\n}\n\n/**\n * Same as deserialize but returns a ready to use function. Used to improve performance.\n */\nexport function deserializeFunction<T>(serializerToUse: Serializer = serializer, namingStrategy?: NamingStrategy, type?: ReceiveType<T>): SerializeFunction<any, T> {\n    return getSerializeFunction(resolveReceiveType(type), serializerToUse.deserializeRegistry, namingStrategy);\n}\n\n/**\n * Patch serialization for deep dot paths, e.g. `{'user.shippingAddress.street': 'abc'}`\n * If a naming strategy is used, it could be converted to `{'user.shipping_address.street': 'abc'}`.\n */\nexport function patch<T>(data: DeepPartial<T>, options?: SerializationOptions, serializerToUse: Serializer = serializer, namingStrategy?: NamingStrategy, type?: ReceiveType<T>): (data: JSONPartial<T> | unknown) => T {\n    type = resolveReceiveType(type);\n    if (type.kind !== ReflectionKind.objectLiteral && type.kind !== ReflectionKind.class) throw new Error('patch() only works on object literals and classes');\n    return getPatchSerializeFunction(type, serializerToUse.deserializeRegistry, namingStrategy)(data, options);\n}\n\n/**\n * Create a serializer/deserializer function including validator for the given type for a patch structure.\n * This is handy for deep patch structures like e.g '{user.address.street: \"new street\"}'.\n */\nexport function getPatchSerializeFunction(type: TypeClass | TypeObjectLiteral, registry: TemplateRegistry, namingStrategy: NamingStrategy = new NamingStrategy()):\n    (data: any, state?: SerializationOptions, patch?: { normalizeArrayIndex: boolean }) => any {\n\n    const jitContainer = getTypeJitContainer(type);\n    const id = registry.id + '_' + namingStrategy.id + '_' + 'patch';\n    if (jitContainer[id]) return jitContainer[id];\n\n    const partialSerializer = getPartialSerializeFunction(type, registry, namingStrategy);\n    // const partialValidator = getValidatorFunction(registry.serializer, getPartialType(type));\n\n    return jitContainer[id] = function (data: any, state?: SerializationOptions, patch?: { normalizeArrayIndex: boolean }) {\n        const normalizeArrayIndex = patch?.normalizeArrayIndex ?? false;\n\n        const result = partialSerializer(data, state);\n        // disabled for the moment: we don't want to validate the patch structure yet since for database stuff it converts the structure to invalid TS representations\n        // e.g. reference objects -> primary keys\n        // const errors: ValidationErrorItem[] = [];\n        // partialValidator(result, { errors });\n        // if (errors.length) throw ValidationError.from(errors);\n\n        outer:\n            for (const i in data) {\n                if (i.includes('.')) {\n                    // serialize each `i` manually.\n                    //e.g. user.shippingAddress.streetNo\n                    // path could be renamed to user.shipping_address.street_no via naming strategy\n                    const path = i.split('.');\n                    let currentType: Type = type;\n                    let newPath = '';\n                    for (const part of path) {\n                        if (currentType.kind === ReflectionKind.objectLiteral || currentType.kind === ReflectionKind.class) {\n                            const next = findMember(part, currentType.types);\n                            if (!next) continue outer;\n                            if (next.kind === ReflectionKind.method || next.kind === ReflectionKind.methodSignature) continue outer;\n                            if (next.kind === ReflectionKind.propertySignature || next.kind === ReflectionKind.property) {\n                                newPath += (newPath ? '.' : '') + namingStrategy.getPropertyName(next, registry.serializer.name);\n                            } else {\n                                newPath += (newPath ? '.' : '') + part;\n                            }\n                            currentType = next.type;\n                        } else if (currentType.kind === ReflectionKind.indexSignature) {\n                            newPath += (newPath ? '.' : '') + part;\n                            currentType = currentType.type;\n                        } else if (currentType.kind === ReflectionKind.array) {\n                            const idx = Number(part);\n                            if (isNaN(idx) || idx < 0) continue outer;\n                            if (normalizeArrayIndex) {\n                                newPath += '[' + idx + ']';\n                            } else {\n                                newPath += (newPath ? '.' : '') + part;\n                            }\n                            currentType = currentType.type;\n                        } else if (currentType.kind === ReflectionKind.tuple) {\n                            const idx = Number(part);\n                            if (isNaN(idx) || idx < 0 || idx >= currentType.types.length) continue outer;\n                            if (normalizeArrayIndex) {\n                                newPath += '[' + idx + ']';\n                            } else {\n                                newPath += (newPath ? '.' : '') + part;\n                            }\n                            currentType = currentType.types[idx].type;\n                        }\n                    }\n                    if (newPath) {\n                        result[newPath] = getSerializeFunction(currentType, registry, namingStrategy)(data[i], state);\n                        // assert(result[newPath], undefined, currentType);\n                    }\n                }\n            }\n\n        return result;\n    };\n}\n\n\n/**\n * Serialize given data structure to JSON data objects (not a JSON string).\n *\n * The resulting JSON object can be stringified using JSON.stringify().\n *\n * ```typescript\n * interface Data {\n *     created: Date;\n * }\n *\n * const json = serialize<Data>({created: new Date(1234567890123)});\n * //json is {created: '2009-02-13T23:31:30.123Z'}\n *\n * const jsonString = JSON.stringify(json);\n * //jsonString is '{\"created\":\"2009-02-13T23:31:30.123Z\"}'\n * ```\n *\n * @throws ValidationError when serialization or validation fails.\n */\nexport function serialize<T>(data: T, options?: SerializationOptions, serializerToUse: Serializer = serializer, namingStrategy?: NamingStrategy, type?: ReceiveType<T>): JSONSingle<T> {\n    const fn = getSerializeFunction(resolveReceiveType(type), serializerToUse.serializeRegistry, namingStrategy);\n    return fn(data, options) as JSONSingle<T>;\n}\n\n/**\n * Same as serialize but returns a ready to use function. Used to improve performance.\n */\nexport function serializeFunction<T>(serializerToUse: Serializer = serializer, namingStrategy?: NamingStrategy, type?: ReceiveType<T>): SerializeFunction<T> {\n    return getSerializeFunction(resolveReceiveType(type), serializerToUse.serializeRegistry, namingStrategy);\n}\n\n/**\n * Clones a class instance deeply.\n */\nexport function cloneClass<T>(target: T, options?: SerializationOptions): T {\n    const classType = getClassTypeFromInstance(target);\n    const type = typeInfer(classType);\n    const serialize = getSerializeFunction(type, serializer.serializeRegistry);\n    const deserialize = getSerializeFunction(type, serializer.deserializeRegistry);\n    return deserialize(serialize(target, options));\n}\n\n/**\n * Tries to deserialize given data as T, and throws an error if it's not possible or validation after conversion fails.\n *\n * @deprecated use cast() instead\n *\n * @throws ValidationError when serialization or validation fails.\n */\nexport function validatedDeserialize<T>(data: any, options?: SerializationOptions, serializerToUse: Serializer = serializer, namingStrategy?: NamingStrategy, type?: ReceiveType<T>) {\n    const fn = getSerializeFunction(resolveReceiveType(type), serializerToUse.deserializeRegistry, namingStrategy);\n    const item = fn(data, options) as T;\n    assert(item, undefined, type);\n    return item;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 16379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16385, "column": 0}, "map": {"version":3,"file":"types.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/types.ts"],"sourcesContent":["import { AutoIncrement, PrimaryKey } from './reflection/type.js';\nimport { Positive } from './validator.js';\n\nexport type AutoId = number & PrimaryKey & AutoIncrement & Positive;\n"],"names":[],"mappings":";;;8BAA0C,sBAAsB;2CACvC,gBAAgB"}},
    {"offset": {"line": 16402, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16408, "column": 0}, "map": {"version":3,"file":"snapshot.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/snapshot.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport { CompilerContext, isObject, toFastProperties } from '@deepkit/core';\nimport { typeSettings, UnpopulatedCheck } from './core.js';\nimport { ReflectionClass, ReflectionProperty } from './reflection/reflection.js';\nimport { ContainerAccessor, executeTemplates, noopTemplate, serializer, Serializer, TemplateRegistry, TemplateState } from './serializer.js';\nimport { PrimaryKeyFields, ReflectionKind } from './reflection/type.js';\n\nfunction createJITConverterForSnapshot(\n    schema: ReflectionClass<any>,\n    properties: ReflectionProperty[],\n    registry: TemplateRegistry,\n) {\n    const compiler = new CompilerContext();\n    const setProperties: string[] = [];\n    const state = new TemplateState('', '', compiler, registry);\n\n    for (const property of properties) {\n        // if (isExcluded(schema, property.name, 'json')) continue;\n        const accessor = new ContainerAccessor('_value', JSON.stringify(property.getNameAsString()));\n        const setter = new ContainerAccessor('_result', JSON.stringify(property.getNameAsString()));\n\n        if (property.isReference()) {\n            const referenceCode: string[] = [];\n\n            for (const pk of property.getResolvedReflectionClass().getPrimaries()) {\n                const deepAccessor = new ContainerAccessor(accessor, JSON.stringify(pk.getNameAsString()));\n                const deepSetter = new ContainerAccessor(setter, JSON.stringify(pk.getNameAsString()));\n\n                referenceCode.push(`\n                //createJITConverterForSnapshot ${property.getNameAsString()}->${pk.getNameAsString()} class:snapshot:${property.type.kind} reference\n                ${executeTemplates(state.fork(deepSetter, deepAccessor), pk.type)}\n                `);\n            }\n\n            setProperties.push(`\n            //createJITConverterForSnapshot ${property.getNameAsString()} class:snapshot:${property.getKind()} reference\n            if (undefined === ${accessor} || null === ${accessor}) {\n                ${setter} = null;\n            } else {\n                ${setter} = {};\n                ${referenceCode.join('\\n')}\n            }\n            `);\n            continue;\n        }\n\n        setProperties.push(`\n            //createJITConverterForSnapshot ${property.getNameAsString()} class:snapshot:${property.getKind()}\n            if (undefined === ${accessor} || null === ${accessor}) {\n                ${setter} = null;\n            } else {\n                ${executeTemplates(state.fork(setter, accessor), property.type)}\n            }\n        `);\n    }\n\n    let circularCheckBeginning = '';\n    let circularCheckEnd = '';\n\n    if (schema.hasCircularReference()) {\n        circularCheckBeginning = `\n        if (state._stack) {\n            if (state._stack.includes(_value)) return undefined;\n        } else {\n            state._stack = [];\n        }\n        state._stack.push(_value);\n        `;\n        circularCheckEnd = `state._stack.pop();`;\n    }\n\n    const functionCode = `\n        var _result = {};\n        state = state || {};\n        ${circularCheckBeginning}\n        var oldUnpopulatedCheck = typeSettings.unpopulatedCheck;\n        typeSettings.unpopulatedCheck = UnpopulatedCheckNone;\n        ${setProperties.join('\\n')}\n        typeSettings.unpopulatedCheck = oldUnpopulatedCheck;\n        ${circularCheckEnd}\n        return _result;\n        `;\n\n    compiler.context.set('typeSettings', typeSettings);\n    compiler.context.set('UnpopulatedCheckNone', UnpopulatedCheck.None);\n\n    return compiler.build(functionCode, '_value', 'state');\n}\n\nfunction cloneValueDeep(value: any): any {\n    if (Array.isArray(value)) return value.map(v => cloneValueDeep(v));\n    if (value instanceof Date) return new Date(value.getTime());\n    if (value instanceof Set) return new Set(value);\n    if (value instanceof Map) return new Map(value);\n    if (value instanceof ArrayBuffer) return value.slice(0);\n    if (value instanceof Uint8Array) return new Uint8Array(value);\n    if (value instanceof Uint16Array) return new Uint16Array(value);\n    if (value instanceof Uint32Array) return new Uint32Array(value);\n    if (value instanceof Int8Array) return new Int8Array(value);\n    if (value instanceof Int16Array) return new Int16Array(value);\n    if (value instanceof Int32Array) return new Int32Array(value);\n    if (value instanceof Float32Array) return new Float32Array(value);\n    if (value instanceof Float64Array) return new Float64Array(value);\n    if (value instanceof BigInt64Array) return new BigInt64Array(value);\n    if (value instanceof BigUint64Array) return new BigUint64Array(value);\n    if (value instanceof DataView) return new DataView(value.buffer.slice(0));\n    if (value instanceof RegExp) return new RegExp(value.source, value.flags);\n    if (isObject(value)) {\n        const copy: any = {};\n        for (const i in value) {\n            copy[i] = cloneValueDeep(value[i]);\n        }\n        return copy;\n    }\n    return value;\n}\n\nclass SnapshotSerializer extends Serializer {\n    name = 'snapshot';\n\n    protected registerSerializers() {\n        super.registerSerializers();\n\n        //we keep bigint as is\n        this.serializeRegistry.register(ReflectionKind.bigint, noopTemplate);\n        this.deserializeRegistry.register(ReflectionKind.bigint, noopTemplate);\n\n        //any is cloned as is\n        this.serializeRegistry.register(ReflectionKind.any, (type, state) => {\n            state.setContext({ cloneValueDeep });\n            state.addSetter(`cloneValueDeep(${state.accessor})`);\n        });\n    }\n}\n\n\nexport const snapshotSerializer = new SnapshotSerializer;\n\n/**\n * Creates a new JIT compiled function to convert the class instance to a snapshot.\n * A snapshot is essentially the class instance as `plain` serialization while references are\n * stored only as their primary keys.\n *\n * Generated function is cached.\n */\nexport function getConverterForSnapshot(\n    reflectionClass: ReflectionClass<any>\n): (value: any) => any {\n    const jit = reflectionClass.getJitContainer();\n    if (jit.snapshotConverter) return jit.snapshotConverter;\n\n    jit.snapshotConverter = createJITConverterForSnapshot(reflectionClass, reflectionClass.getProperties(), snapshotSerializer.serializeRegistry);\n    toFastProperties(jit);\n    return jit.snapshotConverter;\n}\n\n/**\n * Creates a snapshot using getConverterForSnapshot().\n */\nexport function createSnapshot<T>(reflectionClass: ReflectionClass<T>, item: T) {\n    return getConverterForSnapshot(reflectionClass)(item);\n}\n\n/**\n * Extracts the primary key of a snapshot and converts to class type.\n */\nexport function getPrimaryKeyExtractor<T>(\n    reflectionClass: ReflectionClass<T>\n): (value: any) => Partial<T> {\n    const jit = reflectionClass.getJitContainer();\n    if (jit.primaryKey) return jit.primaryKey;\n\n    jit.primaryKey = createJITConverterForSnapshot(reflectionClass, reflectionClass.getPrimaries(), snapshotSerializer.deserializeRegistry);\n    toFastProperties(jit);\n    return jit.primaryKey;\n}\n\n/**\n * Creates a primary key hash generator that takes an item from any format\n * converts it to class format, then to plain, then uses the primitive values to create a string hash.\n *\n * This function is designed to work on the plain values (db records or json values)\n */\nexport function getPrimaryKeyHashGenerator(\n    reflectionClass: ReflectionClass<any>,\n    serializerToUse: Serializer = serializer\n): (value: any) => string {\n    const jit = reflectionClass.getJitContainer();\n\n    if (!jit.pkHash) {\n        jit.pkHash = {};\n        toFastProperties(jit);\n    }\n\n    if (jit.pkHash[serializerToUse.name]) return jit.pkHash[serializerToUse.name];\n\n    jit.pkHash[serializerToUse.name] = createPrimaryKeyHashGenerator(reflectionClass, serializerToUse);\n    toFastProperties(jit.pkHash);\n    return jit.pkHash[serializerToUse.name];\n}\n\n// export function getForeignKeyHash(row: any, property: PropertySchema): string {\n//     const foreignSchema = property.getResolvedClassSchema();\n//     return getPrimaryKeyHashGenerator(foreignSchema)(row[property.name]);\n// }\n\nfunction simplePrimaryKeyHash(value: any): string {\n    return '\\0' + value;\n}\n\nexport function getSimplePrimaryKeyHashGenerator(reflectionClass: ReflectionClass<any>) {\n    const primary = reflectionClass.getPrimary();\n    return (data: PrimaryKeyFields<any>) => simplePrimaryKeyHash(data[primary.name]);\n}\n\nfunction createPrimaryKeyHashGenerator(\n    reflectionClass: ReflectionClass<any>,\n    serializer: Serializer\n) {\n    const context = new CompilerContext();\n    const setProperties: string[] = [];\n    context.context.set('isObject', isObject);\n\n    const state = new TemplateState('', '', context, serializer.serializeRegistry);\n\n    for (const property of reflectionClass.getPrimaries()) {\n        // if (property.isParentReference) continue;\n\n        const accessor = new ContainerAccessor('_value', JSON.stringify(property.getNameAsString()));\n\n        if (property.isReference()) {\n            const referenceCode: string[] = [];\n\n            for (const pk of property.getResolvedReflectionClass().getPrimaries()) {\n                if (pk.type.kind === ReflectionKind.class && pk.type.types.length) {\n                    throw new Error(`Class as primary key (${property.getResolvedReflectionClass().getClassName()}.${pk.getNameAsString()}) is not supported`);\n                }\n\n                const deepAccessor = new ContainerAccessor(accessor, JSON.stringify(pk.getNameAsString()));\n\n                referenceCode.push(`\n                //getPrimaryKeyExtractor ${property.getNameAsString()}->${pk.getNameAsString()} class:snapshot:${property.getKind()} reference\n                lastValue = '';\n                if (${deepAccessor} !== null && ${deepAccessor} !== undefined) {\n                    ${executeTemplates(state.fork('lastValue', deepAccessor).forRegistry(serializer.deserializeRegistry), pk.type)}\n                    ${executeTemplates(state.fork('lastValue', 'lastValue'), pk.type)}\n                }\n                _result += '\\\\0' + lastValue;\n                `);\n            }\n\n            setProperties.push(`\n            //getPrimaryKeyExtractor ${property.getNameAsString()} class:snapshot:${property.getKind()} reference\n            if (undefined !== ${accessor} && null !== ${accessor}) {\n                if (isObject(${accessor})) {\n                    ${referenceCode.join('\\n')}\n                } else {\n                    //might be a primary key directly\n                    lastValue = '';\n                    ${executeTemplates(state.fork('lastValue', accessor).forRegistry(serializer.deserializeRegistry), property.getResolvedReflectionClass().getPrimary().type)}\n                    ${executeTemplates(state.fork('lastValue', 'lastValue'), property.getResolvedReflectionClass().getPrimary().type)}\n                    _result += '\\\\0' + lastValue;\n                    }\n            } else {\n                _result += '\\\\0';\n            }\n            `);\n            continue;\n        }\n\n        if (property.type.kind === ReflectionKind.class && property.type.types.length) {\n            throw new Error(`Class as primary key (${reflectionClass.getClassName()}.${property.getNameAsString()}) is not supported`);\n        }\n\n        setProperties.push(`\n            //getPrimaryKeyHashGenerator ${property.getNameAsString()} class:plain:${property.getKind()}\n            lastValue = '';\n            if (${accessor} !== null && ${accessor} !== undefined) {\n                ${executeTemplates(state.fork('lastValue', accessor).forRegistry(serializer.deserializeRegistry), property.type)}\n                ${executeTemplates(state.fork('lastValue', 'lastValue'), property.type)}\n            }\n            _result += '\\\\0' + lastValue;\n        `);\n    }\n\n    let circularCheckBeginning = '';\n    let circularCheckEnd = '';\n\n    if (reflectionClass.hasCircularReference()) {\n        circularCheckBeginning = `\n        if (state._stack) {\n            if (state._stack.includes(_value)) return undefined;\n        } else {\n            state._stack = [];\n        }\n        state._stack.push(_value);\n        `;\n        circularCheckEnd = `state._stack.pop();`;\n    }\n\n    const functionCode = `\n        var _result = '';\n        var lastValue;\n        state = state || {};\n        ${circularCheckBeginning}\n        ${setProperties.join('\\n')}\n        ${circularCheckEnd}\n        return _result;\n    `;\n\n    return context.build(functionCode, '_value', 'state');\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 16768, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16774, "column": 0}, "map": {"version":3,"file":"change-detector.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/change-detector.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport { CompilerContext, empty, toFastProperties } from '@deepkit/core';\nimport { Changes, changeSetSymbol, ItemChanges } from './changes.js';\nimport { getConverterForSnapshot } from './snapshot.js';\nimport { ReflectionClass } from './reflection/reflection.js';\nimport { ContainerAccessor, getIndexCheck, sortSignatures, TemplateRegistry, TemplateState } from './serializer.js';\nimport { referenceAnnotation, ReflectionKind, Type, TypeIndexSignature } from './reflection/type.js';\n\nfunction genericEqualArray(a: any[], b: any[]): boolean {\n    if (a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; i++) {\n        if (!genericEqual(a[i], b[i])) return false;\n    }\n\n    return true;\n}\n\nfunction genericEqualObject(a: { [name: string]: any }, b: { [name: string]: any }): boolean {\n    for (let i in a) {\n        if (!a.hasOwnProperty(i)) continue;\n        if (!genericEqual(a[i], b[i])) return false;\n    }\n\n    //is there a faster way?\n    for (let i in b) {\n        if (!b.hasOwnProperty(i)) continue;\n        if (!genericEqual(a[i], b[i])) return false;\n    }\n\n    return true;\n}\n\n/**\n * This is a comparator function for the snapshots. They are either string, number, boolean, array, or objects.\n * No date, moment, or custom classes involved here.\n */\nexport function genericEqual(a: any, b: any): boolean {\n    //is array, the fast way\n    const aIsArray = a && 'string' !== typeof a && 'function' === a.slice && 'number' === typeof a.length;\n    const bIsArray = b && 'string' !== typeof b && 'function' === b.slice && 'number' === typeof b.length;\n    if (aIsArray) return bIsArray ? genericEqualArray(a, b) : false;\n    if (bIsArray) return aIsArray ? genericEqualArray(a, b) : false;\n\n    const aIsObject = 'object' === typeof a && a !== null;\n    const bIsObject = 'object' === typeof b && b !== null;\n    if (aIsObject) return bIsObject ? genericEqualObject(a, b) : false;\n    if (aIsObject) return bIsObject ? genericEqualObject(a, b) : false;\n\n    return a === b;\n}\n\nfunction createJITChangeDetectorForSnapshot(schema: ReflectionClass<any>, stateIn?: TemplateState): (lastSnapshot: any, currentSnapshot: any) => ItemChanges<any> {\n    const compiler = new CompilerContext();\n    const state = new TemplateState('', '', compiler, stateIn ? stateIn.registry : new TemplateRegistry(), undefined, stateIn ? stateIn.jitStack : undefined);\n    state.setContext({\n        genericEqual, empty\n    });\n    const lines: string[] = [];\n\n    function has(accessor: string): string {\n        return `(changeSet.$inc && ${accessor} in changeSet.$inc) || (changeSet.$unset && ${accessor} in changeSet.$unset)`;\n    }\n\n    function getComparator(type: Type, last: ContainerAccessor, current: ContainerAccessor, accessor: ContainerAccessor, changedName: string, onChanged: string, state: TemplateState): string {\n        if (type.kind === ReflectionKind.array) {\n            const l = compiler.reserveName('l');\n\n            const lastAccessor = new ContainerAccessor(last, l);\n            const currentAccessor = new ContainerAccessor(current, l);\n            const itemAccessor = new ContainerAccessor(accessor, l);\n            return `\n                if (!${has(changedName)}) {\n                if (!${current} && !${last}) {\n\n                } else if ((${current} && !${last}) || (!${current} && ${last})) {\n                    changes[${changedName}] = item[${changedName}];\n                    ${onChanged}\n                } else if (${current}.length !== ${last}.length) {\n                    changes[${changedName}] = item[${changedName}];\n                    ${onChanged}\n                } else {\n                    let ${l} = ${last}.length;\n                    ${onChanged ? '' : 'root:'}\n                    while (${l}--) {\n                         ${getComparator(type.type, lastAccessor, currentAccessor, itemAccessor, changedName, 'break root;', state)}\n                    }\n                }\n                }\n            `;\n\n            // } else if (type.isMap || type.isPartial) {\n            //     compiler.context.set('getObjectKeysSize', getObjectKeysSize);\n            //     const i = reserveVariable(compiler.context, 'i');\n            //     return `\n            //         if (!${has(changedName)}) {\n            //         if (!${current} && !${last}) {\n            //\n            //         } else if ((${current} && !${last}) || (!${current} && ${last})) {\n            //             changes[${changedName}] = item[${changedName}];\n            //             ${onChanged}\n            //         } else if (getObjectKeysSize(${current}) !== getObjectKeysSize(${last})) {\n            //             changes[${changedName}] = item[${changedName}];\n            //             ${onChanged}\n            //         } else {\n            //             ${onChanged ? '' : 'root:'}\n            //             for (let ${i} in ${last}) {\n            //                 if (!${last}.hasOwnProperty(${i})) continue;\n            //                  ${getComparator(type.getSubType(), `${last}[${i}]`, `${current}[${i}]`, `${accessor}[${i}]`, changedName, 'break root;', jitStack)}\n            //             }\n            //         }\n            //         }\n            //     `;\n        } else if ((type.kind === ReflectionKind.class || type.kind === ReflectionKind.objectLiteral) && type.types.length) {\n            const classSchema = ReflectionClass.from(type);\n\n            if (referenceAnnotation.getFirst(type) !== undefined) {\n                const checks: string[] = [];\n\n                for (const primaryField of classSchema.getPrimaries()) {\n                    const name = JSON.stringify(primaryField.getNameAsString());\n                    const lastAccessor = new ContainerAccessor(last, name);\n                    const currentAccessor = new ContainerAccessor(current, name);\n                    const itemAccessor = new ContainerAccessor(accessor, name);\n                    checks.push(`\n                         ${getComparator(primaryField.type, lastAccessor, currentAccessor, itemAccessor, changedName, onChanged, state)}\n                    `);\n                }\n\n                return `\n                    if (!${has(changedName)}) {\n                    if (!${current} && !${last}) {\n\n                    } else if ((${current} && !${last}) || (!${current} && ${last})) {\n                        changes[${changedName}] = item[${changedName}];\n                        ${onChanged}\n                    } else {\n                        ${checks.join('\\n')}\n                    }\n                    }\n                `;\n            }\n\n            const jitChangeDetectorThis = compiler.reserveVariable('jitChangeDetector', state.jitStack.getOrCreate(state.registry, type, () => {\n                return createJITChangeDetectorForSnapshot(classSchema, state);\n            }));\n\n            return `\n                if (!${has(changedName)}) {\n                    if (!${current} && !${last}) {\n\n                    } else if ((${current} && !${last}) || (!${current} && ${last})) {\n                        changes[${changedName}] = item[${changedName}];\n                        ${onChanged}\n                    } else {\n                        const thisChanged = ${jitChangeDetectorThis}.fn(${last}, ${current}, ${accessor});\n                        if (!empty(thisChanged)) {\n                            changes[${changedName}] = item[${changedName}];\n                            ${onChanged}\n                        }\n                    }\n                }\n            `;\n        } else if (type.kind === ReflectionKind.any || type.kind === ReflectionKind.never || type.kind === ReflectionKind.union) {\n            return `\n                if (!${has(changedName)}) {\n                    if (!genericEqual(${last}, ${current})) {\n                        changes[${changedName}] = item[${changedName}];\n                        ${onChanged}\n                    }\n                }\n            `;\n        } else {\n            //binary, date, boolean, etc are encoded as simple JSON objects (number, boolean, or string) primitives\n            return `\n            if (!${has(changedName)}) {\n                if (${last} !== ${current}) {\n                    changes[${changedName}] = item[${changedName}];\n                    ${onChanged}\n                }\n            }\n            `;\n        }\n    }\n\n    const existing: string[] = [];\n\n    for (const property of schema.getProperties()) {\n        // if (property.isParentReference) continue;\n        if (property.isBackReference()) continue;\n        const name = JSON.stringify(property.getNameAsString());\n        existing.push(name);\n\n        const lastAccessor = new ContainerAccessor('last', name);\n        const currentAccessor = new ContainerAccessor('current', name);\n        const itemAccessor = new ContainerAccessor('item', name);\n        lines.push(getComparator(property.type, lastAccessor, currentAccessor, itemAccessor, JSON.stringify(property.getNameAsString()), '', state));\n    }\n\n    for (const t of schema.type.types) {\n\n    }\n\n    const signatures = (schema.type.types as Type[]).filter(v => v.kind === ReflectionKind.indexSignature) as TypeIndexSignature[];\n    if (signatures.length) {\n        const i = compiler.reserveName('i');\n        const existingCheck = existing.map(v => `${i} === ${v}`).join(' || ') || 'false';\n        const signatureLines: string[] = [];\n        sortSignatures(signatures);\n\n        const lastAccessor = new ContainerAccessor('last', i);\n        const currentAccessor = new ContainerAccessor('current', i);\n        const itemAccessor = new ContainerAccessor('item', i);\n\n        for (const signature of signatures) {\n            signatureLines.push(`else if (${getIndexCheck(state.compilerContext, i, signature.index)}) {\n            ${getComparator(signature.type, lastAccessor, currentAccessor, itemAccessor, i, '', state)}\n        }`);\n        }\n\n        //the index signature type could be: string, number, symbol.\n        //or a literal when it was constructed by a mapped type.\n        lines.push(`\n        for (const ${i} in current) {\n            if (!current.hasOwnProperty(${i})) continue;\n            if (${existingCheck}) continue;\n            if (false) {} ${signatureLines.join(' ')}\n        }\n\n        for (const ${i} in last) {\n            if (!last.hasOwnProperty(${i})) continue;\n            if (!current.hasOwnProperty(${i})) {\n               changes[${i}] = item[${i}];\n               break;\n            }\n        }\n        `);\n    }\n\n    compiler.context.set('changeSetSymbol', changeSetSymbol);\n    compiler.context.set('ItemChanges', ItemChanges);\n\n    const functionCode = `\n        var changeSet = item[changeSetSymbol] || new ItemChanges(undefined, item);\n        var changes = {};\n        ${lines.join('\\n')}\n        changeSet.mergeSet(changes);\n        return changeSet.empty ? undefined : changeSet;\n        `;\n\n    // console.log('functionCode', functionCode);\n\n    try {\n        const fn = compiler.build(functionCode, 'last', 'current', 'item');\n        // prepared(fn);\n        return fn;\n    } catch (error) {\n        console.log('functionCode', functionCode);\n        throw error;\n    }\n}\n\nconst changeDetectorSymbol = Symbol('changeDetector');\n\nexport function getChangeDetector<T extends object>(classSchema: ReflectionClass<T>): (last: any, current: any, item: T) => ItemChanges<T> | undefined {\n    const jit = classSchema.getJitContainer();\n    if (jit[changeDetectorSymbol]) return jit[changeDetectorSymbol];\n\n    jit[changeDetectorSymbol] = createJITChangeDetectorForSnapshot(classSchema);\n    toFastProperties(jit);\n\n    return jit[changeDetectorSymbol];\n}\n\nexport function buildChanges<T extends object>(classSchema: ReflectionClass<T>, lastSnapshot: any, item: T): Changes<T> {\n    const currentSnapshot = getConverterForSnapshot(classSchema)(item);\n    const detector = getChangeDetector(classSchema);\n    return detector(lastSnapshot, currentSnapshot, item) as Changes<T> || new Changes<T>();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 17123, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17129, "column": 0}, "map": {"version":3,"file":"path.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/path.ts"],"sourcesContent":["import { getTypeJitContainer, ReflectionKind, Type } from './reflection/type.js';\nimport { CompilerContext, toFastProperties } from '@deepkit/core';\nimport { ReceiveType, resolveReceiveType } from './reflection/reflection.js';\nimport { getIndexCheck, JitStack } from './serializer.js';\n\nexport type Resolver = (path: string) => Type | undefined;\n\nfunction pathResolverCode(type: Type, compilerContext: CompilerContext, jitStack: JitStack): string {\n    const typeVar = compilerContext.reserveVariable('type', type);\n\n    if (type.kind === ReflectionKind.array) {\n        return `\n        {\n            const dotIndex = path.indexOf('.');\n            if (dotIndex === -1) return ${compilerContext.reserveVariable('type', type.type)};\n            const pathName = dotIndex === -1 ? path : path.substr(0, dotIndex);\n            path = dotIndex === -1 ? '' : path.substr(dotIndex + 1);\n            ${pathResolverCode(type.type, compilerContext, jitStack)}\n        }\n        `;\n    } else if (type.kind === ReflectionKind.tupleMember) {\n        return `\n            if (!path) return ${compilerContext.reserveVariable('type', type)};\n            ${pathResolverCode(type.type, compilerContext, jitStack)};\n        `;\n    } else if (type.kind === ReflectionKind.tuple) {\n        const cases: string[] = [];\n        for (let i = 0; i < type.types.length; i++) {\n            cases.push(`\n            case \"${i}\": {\n                ${pathResolverCode(type.types[i], compilerContext, jitStack)}\n            }\n            `);\n        }\n\n        return `\n        {\n            const dotIndex = path.indexOf('.');\n            const segment = dotIndex === -1 ? path : path.substr(0, dotIndex);\n            path = dotIndex === -1 ? '' : path.substr(dotIndex + 1);\n            switch (segment) {\n                ${cases.join('\\n')}\n                default: {\n                    return undefined;\n                }\n            }\n        }\n        `;\n    } else if (type.kind === ReflectionKind.class && type.classType === Set) {\n    } else if (type.kind === ReflectionKind.class && type.classType === Map) {\n    } else if (type.kind === ReflectionKind.union) {\n        //todo: which type will be picked? return union?\n    } else if (type.kind === ReflectionKind.class || type.kind === ReflectionKind.objectLiteral) {\n        const jit = compilerContext.reserveVariable('jit', jitStack.getOrCreate(undefined, type, () => pathResolver(type, jitStack)));\n        return `return ${jit}.fn(path);`;\n    }\n\n    return `return ${typeVar}`;\n}\n\nexport function resolvePath<T>(path: string, type?: ReceiveType<T>): Type {\n    type = resolveReceiveType(type);\n    const resolver = pathResolver(type);\n    const t = resolver(path);\n    if (!t) throw new Error(`No type found for path ${path} in ${type.typeName}`);\n    return t;\n}\n\nexport function pathResolver<T>(type?: ReceiveType<T>, jitStack: JitStack = new JitStack()): Resolver {\n    type = resolveReceiveType(type);\n    const jit = getTypeJitContainer(type);\n    if (jit.pathResolver) return jit.pathResolver;\n\n    if (type.kind === ReflectionKind.objectLiteral || type.kind === ReflectionKind.class) {\n        const compilerContext = new CompilerContext();\n        const lines: string[] = [];\n        const defaultCase: string[] = [];\n\n        for (const member of type.types) {\n            if (member.kind === ReflectionKind.propertySignature || member.kind === ReflectionKind.property) {\n                if ('symbol' === typeof member.name) continue;\n                lines.push(`\n            case ${JSON.stringify(member.name)}: {\n                if (path === '') return ${compilerContext.reserveVariable('type', member)};\n                ${pathResolverCode(member.type, compilerContext, jitStack)}\n            }`);\n            } else if (member.kind === ReflectionKind.indexSignature) {\n                const checkValid = compilerContext.reserveName('check');\n                defaultCase.push(`else if (${getIndexCheck(compilerContext, 'pathName', member.index)}) {\n                    let ${checkValid} = false;\n                    if (!${checkValid}) {\n                        ${pathResolverCode(member.type, compilerContext, jitStack)}\n                    }\n                }`);\n            }\n        }\n\n        const code = `\n        const dotIndex = path.indexOf('.');\n        const pathName = dotIndex === -1 ? path : path.substr(0, dotIndex);\n        path = dotIndex === -1 ? '' : path.substr(dotIndex + 1);\n\n        if (!pathName) return ${compilerContext.reserveVariable('type', type)};\n\n        switch(pathName) {\n            ${lines.join('\\n')}\n            default: {\n                if (false) {} ${defaultCase.join('\\n')}\n            }\n        }\n        `;\n\n        jit.pathResolver = compilerContext.build(code, 'path');\n        toFastProperties(jit);\n\n        return jit.pathResolver;\n    }\n\n    throw new Error(`pathResolver requires TypeClass or TypeObjectLiteral`);\n}\n"],"names":[],"mappings":";;;;;+BAEgD,4BAA4B;AAF5E,OAAO,EAAE,mBAAmB,EAAE,cAAc,EAAQ,MAAM,sBAAsB,CAAC;AACjF,OAAO,EAAE,eAAe,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAElE,OAAO,EAAE,aAAa,EAAE,QAAQ,EAAE,MAAM,iBAAiB,CAAC;;;;;;;;;;;;;;;;AAI1D,SAAS,gBAAgB,CAAC,IAAU,EAAE,eAAgC,EAAE,QAAkB;IACtF,MAAM,OAAO,GAAG,eAAe,CAAC,eAAe,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IAE9D,IAAI,IAAI,CAAC,IAAI,KAAK,+LAAc,CAAC,KAAK,EAAE,CAAC;QACrC,OAAO,CAAA;;;0CAG2B,eAAe,CAAC,eAAe,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;;;cAG9E,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,eAAe,EAAE,QAAQ,CAAC,CAAA;;SAE3D,CAAC;IACN,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,mLAAK,iBAAc,CAAC,WAAW,EAAE,CAAC;QAClD,OAAO,CAAA;gCACiB,eAAe,CAAC,eAAe,CAAC,MAAM,EAAE,IAAI,CAAC,CAAA;cAC/D,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,eAAe,EAAE,QAAQ,CAAC,CAAA;SAC3D,CAAC;IACN,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,mLAAK,iBAAc,CAAC,KAAK,EAAE,CAAC;QAC5C,MAAM,KAAK,GAAa,EAAE,CAAC;QAC3B,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;YACzC,KAAK,CAAC,IAAI,CAAC,CAAA;oBACH,CAAC,CAAA;kBACH,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,eAAe,EAAE,QAAQ,CAAC,CAAA;;aAE/D,CAAC,CAAC;QACP,CAAC;QAED,OAAO,CAAA;;;;;;kBAMG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;;;;;;SAMzB,CAAC;IACN,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,mLAAK,iBAAc,CAAC,KAAK,IAAI,IAAI,CAAC,SAAS,KAAK,GAAG,EAAE,CACzE,AAD0E,CACzE,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,+LAAc,CAAC,KAAK,IAAI,IAAI,CAAC,SAAS,KAAK,GAAG,EAAE,CAAC,AAC1E,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,mLAAK,iBAAc,CAAC,KAAK,EAAE,CAAC;IAC5C,gDAAgD;IACpD,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,mLAAK,iBAAc,CAAC,KAAK,IAAI,IAAI,CAAC,IAAI,mLAAK,iBAAc,CAAC,aAAa,EAAE,CAAC;QAC1F,MAAM,GAAG,GAAG,eAAe,CAAC,eAAe,CAAC,KAAK,EAAE,QAAQ,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,EAAE,GAAG,CAAG,CAAD,WAAa,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC9H,OAAO,CAAA,OAAA,EAAU,GAAG,CAAA,UAAA,CAAY,CAAC;IACrC,CAAC;IAED,OAAO,CAAA,OAAA,EAAU,OAAO,EAAE,CAAC;AAC/B,CAAC;;;;;;;;;;;AAEK,SAAU,WAAW,CAAI,IAAY,EAAE,OAA7B,WAAW,CAAA,CAAA,EAAA,CAAA,EAAuC;IAAlD,WAAW,CAAA,CAAA,GAAA;IACvB,IAAI,2LAAG,qBAAA,AAAkB,EAAC,IAAI,CAAC,CAAC;IAChC,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;IACpC,MAAM,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;IACzB,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,CAAA,uBAAA,EAA0B,IAAI,CAAA,IAAA,EAAO,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC9E,OAAO,CAAC,CAAC;CACZ;;;;;;;;;AAEK,SAAU,YAAY,CAAI,OAAhB,YAAY,CAAA,CAAA,EAAA,CAAA,EAAyB,EAAE,WAAqB,IAAI,iLAAQ,EAAE;IAA1E,YAAY,CAAA,CAAA,GAAA;IACxB,IAAI,2LAAG,qBAAA,AAAkB,EAAC,IAAI,CAAC,CAAC;IAChC,MAAM,GAAG,GAAG,wMAAA,AAAmB,EAAC,IAAI,CAAC,CAAC;IACtC,IAAI,GAAG,CAAC,YAAY,EAAE,OAAO,GAAG,CAAC,YAAY,CAAC;IAE9C,IAAI,IAAI,CAAC,IAAI,mLAAK,iBAAc,CAAC,aAAa,IAAI,IAAI,CAAC,IAAI,KAAK,+LAAc,CAAC,KAAK,EAAE,CAAC;QACnF,MAAM,eAAe,GAAG,wKAAI,kBAAe,EAAE,CAAC;QAC9C,MAAM,KAAK,GAAa,EAAE,CAAC;QAC3B,MAAM,WAAW,GAAa,EAAE,CAAC;QAEjC,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,KAAK,CAAE,CAAC;YAC9B,IAAI,MAAM,CAAC,IAAI,mLAAK,iBAAc,CAAC,iBAAiB,IAAI,MAAM,CAAC,IAAI,mLAAK,iBAAc,CAAC,QAAQ,EAAE,CAAC;gBAC9F,IAAI,QAAQ,KAAK,OAAO,MAAM,CAAC,IAAI,EAAE,SAAS;gBAC9C,KAAK,CAAC,IAAI,CAAC,CAAA;mBACR,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;0CACJ,eAAe,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;kBACvE,gBAAgB,CAAC,MAAM,CAAC,IAAI,EAAE,eAAe,EAAE,QAAQ,CAAC,CAAA;cAC5D,CAAC,CAAC;YACJ,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,mLAAK,iBAAc,CAAC,cAAc,EAAE,CAAC;gBACvD,MAAM,UAAU,GAAG,eAAe,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;gBACxD,WAAW,CAAC,IAAI,CAAC,CAAA,SAAA,4KAAY,gBAAA,AAAa,EAAC,eAAe,EAAE,UAAU,EAAE,MAAM,CAAC,KAAK,CAAC,CAAA;0BAC3E,UAAU,CAAA;2BACT,UAAU,CAAA;0BACX,gBAAgB,CAAC,MAAM,CAAC,IAAI,EAAE,eAAe,EAAE,QAAQ,CAAC,CAAA;;kBAEhE,CAAC,CAAC;YACR,CAAC;QACL,CAAC;QAED,MAAM,IAAI,GAAG,CAAA;;;;;gCAKW,eAAe,CAAC,eAAe,CAAC,MAAM,EAAE,IAAI,CAAC,CAAA;;;cAG/D,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;;gCAEE,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;;;SAG7C,CAAC;QAEF,GAAG,CAAC,YAAY,GAAG,eAAe,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;4KACvD,mBAAA,AAAgB,EAAC,GAAG,CAAC,CAAC;QAEtB,OAAO,GAAG,CAAC,YAAY,CAAC;IAC5B,CAAC;IAED,MAAM,IAAI,KAAK,CAAC,CAAA,oDAAA,CAAsD,CAAC,CAAC;CAC3E"}},
    {"offset": {"line": 17283, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17289, "column": 0}, "map": {"version":3,"file":"registry.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/registry.ts"],"sourcesContent":["import { ClassType, isArray, isFunction } from '@deepkit/core';\nimport { binaryTypes, ReflectionKind, Type } from './reflection/type.js';\n\ninterface RegistryDecorator<T> {\n    predicate: (type: Type) => boolean,\n    v: T\n}\n\nexport class TypeRegistry<T> {\n    protected results: { [kind in ReflectionKind]?: T } = {};\n    public classes = new Map<ClassType, T>();\n    protected decorators: RegistryDecorator<T>[] = [];\n\n    clear(): void {\n        this.results = {};\n        this.classes.clear();\n    }\n\n    get(type: Type): T | undefined {\n        for (const d of this.decorators) {\n            if (d.predicate(type)) return d.v;\n        }\n\n        if (type.kind === ReflectionKind.class) {\n            const classResult = this.classes.get(type.classType);\n            if (classResult) return classResult;\n            if (type.classType === Set || type.classType === Map || binaryTypes.includes(type.classType)) return undefined;\n        }\n        return this.results[type.kind];\n    }\n\n    decorator(predicate: (type: Type) => boolean, v: T): void {\n        this.decorators.push({ predicate, v });\n    }\n\n    /**\n     * Registers a template for all binary classes: ArrayBuffer, Uint8Array, Int8Array, etc.\n     */\n    setBinary(v: T): void {\n        for (const classType of binaryTypes) this.setClass(classType, v);\n    }\n\n    setNumeric(v: T): void{\n        this.set([ReflectionKind.number, ReflectionKind.bigint], v);\n    }\n\n    /**\n     * Registers a template for a given class type.\n     *\n     * As soon as a single template has registered for the given classType the template registry\n     * only returns templates for this particular classType and omits all general purpose ReflectionKind.class templates for this particular classType.\n     */\n    setClass(classType: ClassType, v: T): void {\n        this.classes.set(classType, v);\n    }\n\n    /**\n     * Removes all registered templates.\n     */\n    remove(kind: ReflectionKind): void {\n        this.results[kind] = undefined;\n    }\n\n    /**\n     * Registers a new template and replaces all existing (added via register,prepend,append).\n     */\n    set(kind: ReflectionKind | ReflectionKind[] | ((type: Type) => boolean), v: T): void {\n        if (isFunction(kind)) return this.decorator(kind, v);\n        kind = isArray(kind) ? kind : [kind];\n        for (const k of kind) this.results[k] = v;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 17412, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17418, "column": 0}, "map": {"version":3,"file":"default.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/default.ts"],"sourcesContent":["import { binaryTypes, ReflectionKind, resolveTypeMembers, Type } from './reflection/type.js';\n\n/**\n * Returns a sensible default value for a given type.\n * Sensible means it satisfies the type checker, but not necessarily attached validators.\n */\nexport function defaultValue(type: Type): any {\n    switch (type.kind) {\n        case ReflectionKind.void:\n        case ReflectionKind.any:\n        case ReflectionKind.never:\n        case ReflectionKind.unknown:\n        case ReflectionKind.undefined:\n            return undefined;\n        case ReflectionKind.null:\n            return null;\n        case ReflectionKind.string:\n            return '';\n        case ReflectionKind.number:\n            return 0;\n        case ReflectionKind.boolean:\n            return false;\n        case ReflectionKind.bigint:\n            return BigInt(0);\n        case ReflectionKind.object:\n            return {};\n        case ReflectionKind.union: {\n            if (type.types.length) return defaultValue(type.types[0]);\n            break;\n        }\n        case ReflectionKind.promise:\n            return defaultValue(type.type);\n        case ReflectionKind.array:\n            return [];\n        case ReflectionKind.rest: {\n            return [defaultValue(type.type)];\n        }\n        case ReflectionKind.tupleMember: {\n            if (type.optional) return;\n            return defaultValue(type.type);\n        }\n        case ReflectionKind.tuple: {\n            const result: any[] = [];\n            for (const sub of type.types) {\n                const value = defaultValue(sub);\n                if (value === undefined) continue;\n                if (sub.type.kind === ReflectionKind.rest) {\n                    result.push(...value);\n                } else {\n                    result.push(value);\n                }\n            }\n            return result;\n        }\n        case ReflectionKind.enum: {\n            return type.values[0];\n        }\n        case ReflectionKind.objectLiteral: {\n            const result: any = {};\n            const types = resolveTypeMembers(type);\n            for (const type of types) {\n                if (type.kind === ReflectionKind.propertySignature) {\n                    if (type.optional) continue;\n                    result[type.name] = defaultValue(type.type);\n                }\n            }\n\n            return result;\n        }\n        case ReflectionKind.class: {\n            if (type.classType === Date) return new Date;\n            if (type.classType === Set) return new Set;\n            if (type.classType === Map) return new Map;\n            if (binaryTypes.includes(type.classType)) return new type.classType;\n\n            const result: any = {};\n            const types = resolveTypeMembers(type);\n            for (const type of types) {\n                if (type.kind === ReflectionKind.property) {\n                    if (type.optional) continue;\n                    result[type.name] = defaultValue(type.type);\n                }\n            }\n\n            return result;\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 17517, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17523, "column": 0}, "map": {"version":3,"file":"mixin.js","sources":["turbopack://[project]/node_modules/@deepkit/type/src/mixin.ts"],"sourcesContent":["import { ExtractClassType } from '@deepkit/core';\nimport { ClassType } from '@deepkit/core';\nimport { AbstractClassType } from '@deepkit/core';\nimport { ReflectionClass } from './reflection/reflection.js';\n\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;\n\n/**\n * Function to mixin multiple classes together and create a new class, which can be extended from.\n *\n * The first entry of the mixin() call will be used as base class.\n *\n * @example\n * ```typescript\n *\n *   class Timestampable {\n *       createdAt: Date = new Date;\n *       updatedAt: Date = new Date;\n *   }\n *\n *   class SoftDeleted {\n *       deletedAt?: Date;\n *       deletedBy?: string;\n *   }\n *\n *   class User extends mixin(Timestampable, SoftDeleted) {\n *       id: number = 0;\n *       constructor(public username: string) {}\n *   }\n * ```\n */\nexport function mixin<T extends AbstractClassType[]>(...classTypes: T): ClassType<UnionToIntersection<ExtractClassType<T[number]>>> {\n    const base = classTypes.shift();\n    if (!base) throw new Error('No classes given');\n\n    const constructors: Function[] = [];\n    /**\n     * @reflection never\n     */\n    const newClassType: any = class extends base {\n        constructor(...args: any[]) {\n            super();\n            for (const c of constructors) {\n                c.call(this, ...args);\n            }\n        }\n    };\n    const schema = ReflectionClass.from(newClassType);\n\n    for (const classType of classTypes) {\n        const foreignSchema = ReflectionClass.from(classType);\n\n        for (const i of Object.getOwnPropertyNames(classType.prototype)) {\n            if (i === 'constructor') continue;\n            newClassType.prototype[i] = classType.prototype[i];\n        }\n\n        for (const prop of foreignSchema.getProperties()) {\n            schema.registerProperty(prop.clone());\n        }\n\n        constructors.push(function (this: any, ...args: any[]) {\n            const item = new (classType as any)(...args);\n            for (const prop of foreignSchema.getProperties()) {\n                this[prop.name] = item[prop.name];\n            }\n        });\n    }\n    //make sure the processor picks up the newly computed type object instead of computing it itself\n    newClassType.__type = [];\n    newClassType.__type.__type = schema.type;\n    return newClassType as any;\n}\n"],"names":[],"mappings":";;;6BAC0B,eAAe;AAEzC,OAAO,EAAE,eAAe,EAAE,MAAM,4BAA4B,CAAC;;;;;;;;;;;;;;;;AA4BvD,SAAU,KAAK,CAAgC,GAAG,UAAa;IACjE,MAAM,IAAI,GAAG,UAAU,CAAC,KAAK,EAAE,CAAC;IAChC,IAAI,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;IAE/C,MAAM,YAAY,GAAe,EAAE,CAAC;IACpC;;OAEG,CACH,MAAM,YAAY,GAAQ,KAAM,SAAQ,IAAI;QACxC,YAAY,GAAG,IAAW,CAAA;YACtB,KAAK,EAAE,CAAC;YACR,KAAK,MAAM,CAAC,IAAI,YAAY,CAAE,CAAC;gBAC3B,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC;YAC1B,CAAC;QACL,CAAC;KACJ,CAAC;IACF,MAAM,MAAM,uLAAG,kBAAe,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAElD,KAAK,MAAM,SAAS,IAAI,UAAU,CAAE,CAAC;QACjC,MAAM,aAAa,sLAAG,mBAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAEtD,KAAK,MAAM,CAAC,IAAI,MAAM,CAAC,mBAAmB,CAAC,SAAS,CAAC,SAAS,CAAC,CAAE,CAAC;YAC9D,IAAI,CAAC,KAAK,aAAa,EAAE,SAAS;YAClC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QACvD,CAAC;QAED,KAAK,MAAM,IAAI,IAAI,aAAa,CAAC,aAAa,EAAE,CAAE,CAAC;YAC/C,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;QAC1C,CAAC;QAED,YAAY,CAAC,IAAI,CAAA,aAAC,SAAqB,GAAG,IAAW;YACjD,MAAM,IAAI,GAAG,IAAK,SAAiB,CAAC,GAAG,IAAI,CAAC,CAAC;YAC7C,KAAK,MAAM,IAAI,IAAI,aAAa,CAAC,aAAa,EAAE,CAAE,CAAC;gBAC/C,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACtC,CAAC;QACL,CAAC,EAAA;YAAA;YAAA;YAAA;YAAA;SAAA,EAAC,CAAC;IACP,CAAC;IACD,gGAAgG;IAChG,YAAY,CAAC,MAAM,GAAG,EAAE,CAAC;IACzB,YAAY,CAAC,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC;IACzC,OAAO,YAAmB,CAAC;AAC/B,CAAC"}},
    {"offset": {"line": 17592, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17598, "column": 0}, "map": {"version":3,"file":"index.js","sources":["turbopack://[project]/node_modules/@deepkit/type/index.ts"],"sourcesContent":["/*\n * Deepkit Framework\n * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nexport * from './src/core.js';\nexport * from './src/changes.js';\nexport * from './src/decorator.js';\nexport * from './src/decorator-builder.js';\nexport * from './src/reference.js';\nexport * from './src/serializer.js';\nexport * from './src/serializer-facade.js';\nexport * from './src/typeguard.js';\nexport * from './src/types.js';\nexport * from './src/utils.js';\nexport * from './src/validator.js';\nexport * from './src/validators.js';\nexport * from './src/snapshot.js';\nexport * from './src/change-detector.js';\nexport * from './src/path.js';\nexport * from './src/type-serialization.js';\nexport * from './src/registry.js';\nexport * from './src/default.js';\nexport * from './src/mixin.js';\n\nexport * from './src/reflection/type.js';\nexport * from './src/reflection/processor.js';\nexport * from './src/reflection/type.js';\nexport * from './src/reflection/extends.js';\nexport * from './src/reflection/reflection.js';\n\nexport { TypeNumberBrand } from '@deepkit/type-spec';\n"],"names":[],"mappings":"AAAA;;;;;;;;GAQG"}},
    {"offset": {"line": 17633, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}